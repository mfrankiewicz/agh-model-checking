 <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>BCG_READ manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
bcg_read - a simple interface to read a BCG graph  
<H2><A NAME="sect1" HREF="#sect1">Description</A></H2>
This
interface reads a BCG graph from an application program written in C or
C++. To keep things simple, this interface  views states as unsigned integer
numbers and labels as character strings. Note: this subset of BCG is equivalent
to the <B>.aut</B> format described in the <A HREF="aldebaran.html"><B>aldebaran</B></A>
 manual page, although
it is much more compact. <P>

<H2><A NAME="sect2" HREF="#sect2">Usage</A></H2>
The application program should start with
the following directive: <P>
<CODE>   #include "bcg_user.h"</CODE> <P>
Then the BCG library should
be initialized by invoking the following function: <P>
<CODE>   BCG_INIT ();</CODE> <P>
Not
invoking this function might cause a run-time error, e.g.,  a segmentation
fault. Invoking <CODE>BCG_INIT()</CODE> more than once is harmless, although not recommended.
 
<H2><A NAME="sect3" HREF="#sect3">Data Types</A></H2>
In order to read a BCG graph, declare a data structure having
the type <CODE>BCG_TYPE_OBJECT_TRANSITION</CODE> (this type is provided by the "bcg_user.h"
file), which contains information related to the graph. Assuming that this
data structure will be named <I>bcg_graph</I>, this declaration will have the
following form: <P>
<CODE>    BCG_TYPE_OBJECT_TRANSITION </CODE><I>bcg_graph</I><CODE>;</CODE> <P>
Note: this interface
is reentrant, in the sense that several BCG graphs can be read concurrently,
provided that each BCG graph is associated with a distinct data structure
of type <CODE>BCG_TYPE_OBJECT_TRANSITION</CODE>. <P>
The functions of this interface also
use the followings types, whose definitions are provided by the "bcg_user.h"
file: 
<DL><DD><DL COMPACT>

<DT><CODE>    BCG_TYPE_BOOLEAN</CODE> </DT>
<DD></DD><P>

<DT><CODE>    BCG_TYPE_NATURAL</CODE> </DT>
<DD></DD><P>

<DT><CODE>    BCG_TYPE_C_STRING</CODE> </DT>
<DD></DD><P>

<DT><CODE>
   BCG_TYPE_FILE_NAME</CODE> </DT>
<DD></DD><P>

<DT><CODE>    BCG_TYPE_STATE_NUMBER</CODE> </DT>
<DD></DD><P>

<DT><CODE>    BCG_TYPE_LABEL_NUMBER</CODE>
</DT>
<DD></DD><P>

<DT><CODE>    BCG_TYPE_EDGE_NUMBER</CODE> </DT>
<DD></DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect4" HREF="#sect4">Features</A></H2>
<P>
 <HR><BR>
 <P>

<H3><A NAME="sect5" HREF="#sect5"><CODE>BCG_OT_READ_BCG_BEGIN</CODE></A></H3>
<PRE> BCG_OT_READ_BCG_BEGIN (filename, bcg_graph, access_mode)

  BCG_TYPE_FILE_NAME         filename;
  BCG_TYPE_OBJECT_TRANSITION *bcg_graph;
  BCG_TYPE_NATURAL           access_mode;
  { ... }

</PRE>This function opens a BCG file.  
<DL><DD><DL COMPACT>

<DT><I>filename</I> </DT>
<DD>is a character string containing
the path name of the BCG file to be read. It should contain the  "<CODE>.bcg</CODE>" suffix
(if the "<CODE>.bcg</CODE>" suffix is missing, it will be added automatically); </DD><P>

<DT><I>bcg_graph</I>
</DT>
<DD>is a pointer to the data structure which will become associated with the
BCG graph and into which information about the BCG graph will be stored;
</DD><P>

<DT><I>access_mode</I> </DT>
<DD>is an integer indicating which kind of primitives are expected
for exploring the transition relation of the BCG graph. </DD><P>
</DL></DD><P></DL>
<P>
There are several
possible values for <I>access_mode</I>: 
<DL><DD><DL COMPACT>

<DT>0: </DT>
<DD>should be used when it is only necessary
to enumerate the edges in the BCG graph. </DD><P>

<DT>1: </DT>
<DD>should be used when one has
to enumerate the successors of a given state. </DD><P>

<DT>2: </DT>
<DD>should be used when one
has to enumerate the predecessors of a given state. </DD><P>

<DT>3: </DT>
<DD>should be used when
one has to enumerate both the successors and predecessors of a given state.
</DD><P>

<DT>4: </DT>
<DD>is similar to value 3, but uses a different data structure. </DD><P>
</DL></DD><P></DL>
<P>
By default,
if <I>filename</I> cannot be opened for reading, <CODE>BCG_OT_READ_BCG_BEGIN()</CODE> will
emit an error message and exit the program. However, if the following function
call: <P>
<CODE>    BCG_OT_READ_BCG_SURVIVE (BCG_TRUE);</CODE> <P>
has occured before the call
to <CODE>BCG_OT_READ_BCG_BEGIN()</CODE>, then <CODE>BCG_OT_READ_BCG_BEGIN()</CODE> will neither emit
an error message  nor exit the program, but return normally with its <I>bcg_graph</I>
parameter set to <CODE>NULL</CODE> if and only if <I>filename</I> cannot  be opened. <P>
Below,
we assume that the <I>*bcg_graph</I> data structure has been properly assigned
after a successful invocation of the <CODE>BCG_OT_READ_BCG_BEGIN()</CODE> function. <P>

<HR><BR>
 <P>

<H3><A NAME="sect6" HREF="#sect6"><CODE>BCG_OT_READ_BCG_SURVIVE</CODE></A></H3>
<PRE> BCG_OT_READ_BCG_SURVIVE (mode)

  BCG_TYPE_BOOLEAN mode;
  { ... }

</PRE>This function controls how the <CODE>BCG_OT_READ_BCG_BEGIN()</CODE> function defined
above will behave if the BCG file cannot be opened for writing: 
<UL>
<LI type=disc>If <I>mode</I>
equals <CODE>BCG_FALSE</CODE>, then <CODE>BCG_OT_READ_BCG_BEGIN()</CODE> will emit an error message
and exit the program. This is the default behaviour. </LI><P><LI type=disc>If <I>mode</I> equals <CODE>BCG_TRUE</CODE>,
then <CODE>BCG_OT_READ_BCG_BEGIN()</CODE> will neither emit an error message nor exit
the program, but return a boolean result. The default behaviour can be restored
by calling: </LI><P>
</UL>
<P>
<CODE>    BCG_OT_READ_BCG_SURVIVE (BCG_FALSE);</CODE> <P>
 <HR><BR>
 <P>

<H3><A NAME="sect7" HREF="#sect7"><CODE>BCG_OT_INITIAL_STATE</CODE></A></H3>
<PRE> BCG_TYPE_STATE_NUMBER BCG_OT_INITIAL_STATE (bcg_graph)

  BCG_TYPE_OBJECT_TRANSITION bcg_graph;
  { ... }

</PRE>This function returns the number of the initial state of the BCG graph.
<P>
 <HR><BR>
 <P>

<H3><A NAME="sect8" HREF="#sect8"><CODE>BCG_OT_NB_STATES</CODE></A></H3>
<PRE> BCG_STATE_NUMBER BCG_OT_NB_STATES (bcg_graph)

  BCG_TYPE_OBJECT_TRANSITION bcg_graph;
  { ... }

</PRE>This function returns the number of states of the BCG graph. States are
given unique numbers in the range <CODE>0</CODE> to <CODE>BCG_OT_NB_STATES (</CODE><I>bcg_graph</I><CODE>) - 1</CODE>.
<P>
 <HR><BR>
 <P>

<H3><A NAME="sect9" HREF="#sect9"><CODE>BCG_OT_NB_EDGES</CODE></A></H3>
<PRE> BCG_TYPE_EDGE_NUMBER BCG_OT_NB_EDGES (bcg_graph)

  BCG_TYPE_OBJECT_TRANSITION bcg_graph;
  { ... }

</PRE>This function returns the number of edges (i.e., transitions) of the BCG
graph. Edges are given unique numbers in the range <CODE>0</CODE> to <CODE>BCG_OT_NB_EDGES
(</CODE><I>bcg_graph</I><CODE>) - 1</CODE>. <P>
 <HR><BR>
 <P>

<H3><A NAME="sect10" HREF="#sect10"><CODE>BCG_OT_NB_LABELS</CODE></A></H3>
<PRE> BCG_TYPE_LABEL_NUMBER BCG_OT_NB_LABELS (bcg_graph)

  BCG_TYPE_OBJECT_TRANSITION bcg_graph;
  { ... }

</PRE>This function returns the number of labels of the BCG graph. Labels are
given unique numbers in the range <CODE>0</CODE> to <CODE>BCG_OT_NB_LABELS (</CODE><I>bcg_graph</I><CODE>) - 1</CODE>.
<P>
 <HR><BR>
 <P>

<H3><A NAME="sect11" HREF="#sect11"><CODE>BCG_OT_LABEL_STRING</CODE></A></H3>
<PRE> BCG_TYPE_C_STRING BCG_OT_LABEL_STRING (bcg_graph,
                                        bcg_label_number)

  BCG_TYPE_OBJECT_TRANSITION bcg_graph;
  BCG_TYPE_LABEL_NUMBER      bcg_label_number;
  { ... }

</PRE>This function returns a character string denoting the label whose index
is <I>bcg_label_number</I>. It assumes <I>bcg_label_number</I> belongs to the range <CODE>0</CODE>
to <CODE>BCG_OT_NB_LABELS (</CODE><I>bcg_graph</I><CODE>) - 1</CODE>. <P>
 <HR><BR>
 <P>

<H3><A NAME="sect12" HREF="#sect12"><CODE>BCG_OT_LABEL_VISIBLE</CODE></A></H3>
<PRE> BCG_TYPE_BOOLEAN BCG_OT_LABEL_VISIBLE (bcg_graph,
                                        bcg_label_number)

  BCG_TYPE_OBJECT_TRANSITION bcg_graph;
  BCG_TYPE_LABEL_NUMBER      bcg_label_number;
  { ... }

</PRE>This function returns a boolean that is equal to <CODE>BCG_FALSE</CODE>  if the label
whose index is <I>bcg_label_number</I> is not visible,  or <CODE>BCG_TRUE</CODE> if this label
is visible. It assumes <I>bcg_label_number</I> belongs to the range <CODE>0</CODE> to <CODE>BCG_OT_NB_LABELS
(</CODE><I>bcg_graph</I><CODE>) - 1</CODE>. <P>
 <HR><BR>
 <P>

<H3><A NAME="sect13" HREF="#sect13"><CODE>BCG_OT_LABEL_GATE</CODE></A></H3>
<PRE> BCG_TYPE_C_STRING BCG_OT_LABEL_GATE (bcg_graph,
                                        bcg_label_number)

  BCG_TYPE_OBJECT_TRANSITION bcg_graph;
  BCG_TYPE_LABEL_NUMBER      bcg_label_number;
  { ... }

</PRE>This function returns a character string that is equal to <CODE>"i"</CODE>  if the label
whose index is <I>bcg_label_number</I> is not visible,  or to the gate (i.e., first
element) of this label if this label is  visible. It assumes <I>bcg_label_number</I>
belongs to the range <CODE>0</CODE> to <CODE>BCG_OT_NB_LABELS (</CODE><I>bcg_graph</I><CODE>) - 1</CODE>. <P>
 <HR><BR>
 <P>

<H3><A NAME="sect14" HREF="#sect14"><CODE>BCG_OT_LABEL_HIDDEN_GATE</CODE></A></H3>
<PRE> BCG_TYPE_C_STRING BCG_OT_LABEL_HIDDEN_GATE (bcg_graph,
                                        bcg_label_number)

  BCG_TYPE_OBJECT_TRANSITION bcg_graph;
  BCG_TYPE_LABEL_NUMBER      bcg_label_number;
  { ... }

</PRE>This function returns a character string that is equal to <CODE>""</CODE>  if the label
whose index is <I>bcg_label_number</I> is visible,  or to the gate (i.e., first
element) of this label (if any) before it was hidden. It assumes <I>bcg_label_number</I>
belongs to the range <CODE>0</CODE> to <CODE>BCG_OT_NB_LABELS (</CODE><I>bcg_graph</I><CODE>) - 1</CODE>. <P>
 <HR><BR>
 <P>

<H3><A NAME="sect15" HREF="#sect15"><CODE>BCG_OT_LABEL_CARDINAL</CODE></A></H3>
<PRE> BCG_TYPE_NATURAL BCG_OT_LABEL_CARDINAL (bcg_graph,
                                        bcg_label_number)

  BCG_TYPE_OBJECT_TRANSITION bcg_graph;
  BCG_TYPE_LABEL_NUMBER      bcg_label_number;
  { ... }

</PRE>This function returns a natural number that is equal to the number of elements
in the label whose index is <I>bcg_label_number</I> (this number is always equal
to 1 if the label is not visible). It assumes <I>bcg_label_number</I> belongs to
the range <CODE>0</CODE> to <CODE>BCG_OT_NB_LABELS (</CODE><I>bcg_graph</I><CODE>) - 1</CODE>. <P>
 <HR><BR>
 <P>
 
<H3><A NAME="sect16" HREF="#sect16"><CODE>BCG_OT_ITERATE_PLN</CODE></A></H3>
<PRE>
  BCG_TYPE_OBJECT_TRANSITION bcg_graph;
  BCG_TYPE_STATE_NUMBER      bcg_state_1;
  BCG_TYPE_LABEL_NUMBER      bcg_label_number;
  BCG_TYPE_STATE_NUMBER      bcg_state_2;

  BCG_OT_ITERATE_PLN (bcg_graph, bcg_state_1,
                        bcg_label_number, bcg_state_2)
  {
  /* loop body */
  } BCG_OT_END_ITERATE;

</PRE>This iterator enumerates all the edges in the BCG graph associated to <I>bcg_graph</I>.
<P>
<I>bcg_state_1</I> is the number of the origin state of the edge,  <I>bcg_state_2</I>
is the number of the destination state of the edge, and <I>bcg_label_number</I>
is the number of the label of the edge.  These three variables are assigned
by the iterator. They are visible  in the loop body, where they can be read
but not assigned. <P>
For each edge <I>(bcg_state_1, bcg_label_number, bcg_state_2)</I>,
the loop body is executed. The loop body can be any statement block of the
 C language. In particular, it may contain "<B>break</B>" and  "<B>continue</B>" statements
with their usual semantics. The order in which the edges are enumerated
by this iterator is  left unspecified. <P>
This iterator is available whatever
value was given to  <I>access_mode</I> when the BCG file associated to <I>bcg_graph</I>
was opened using <CODE>BCG_OT_READ_BCG_BEGIN()</CODE>. <P>
There is also a whole family of
iterators that allow the enumeration of all the edges for which <I>bcg_state_1</I>
and/or <I>bcg_label_number</I> and/or <I>bcg_state_2</I> are given fixed values. The availability
of these iterators depends upon the value given to <I>access_mode</I> when the
BCG file associated to <I>bcg_graph</I> was opened. We describe below a representative
iterator (named <CODE>BCG_OT_ITERATE_P_LN</CODE>) in this family. <P>
 <HR><BR>
 <P>
 
<H3><A NAME="sect17" HREF="#sect17"><CODE>BCG_OT_ITERATE_P_LN</CODE></A></H3>
<PRE>
  BCG_TYPE_OBJECT_TRANSITION bcg_graph;
  BCG_TYPE_STATE_NUMBER      bcg_state_1;
  BCG_TYPE_LABEL_NUMBER      bcg_label_number;
  BCG_TYPE_STATE_NUMBER      bcg_state_2;

  BCG_OT_ITERATE_P_LN (bcg_graph, bcg_state_1,
                         bcg_label_number, bcg_state_2)
  {
  /* loop body */
  } BCG_OT_END_ITERATE;

</PRE>This iterator enumerates all the edges in the BCG graph with origin state
equal to <I>bcg_state_1</I>. <I>bcg_state_1</I> is a variable or an expression whose value
is evaluated when the iterator is started. <I>bcg_state_1</I> is not assigned by
the iterator. <P>
<I>bcg_state_2</I> is the number of the destination state of the
edge,  and <I>bcg_label_number</I> is the number of the label of the edge. These
two variables are assigned by the iterator. They are visible in the loop
body, where they can be read but not assigned. <P>
For each edge <I>(bcg_state_1,
bcg_label_number, bcg_state_2)</I>, the loop body is executed. The loop body
can be any statement block of the  C language. In particular, it may contain
"<B>break</B>" and  "<B>continue</B>" statements with their usual semantics. The order
in which the edges going out of a given state <I>bcg_state_1</I> are enumerated
by this iterator is left unspecified. <P>
This iterator is available if <I>access_mode</I>
was given the value 1, 3, or 4 when the BCG file associated to <I>bcg_graph</I>
was opened using <CODE>BCG_OT_READ_BCG_BEGIN()</CODE>. <P>
There are several others iterators
available. They are defined in  file "<B>$CADP/incl/bcg_iterator.h</B>". <P>
 <HR><BR>
 <P>

<H3><A NAME="sect18" HREF="#sect18"><CODE>BCG_OT_READ_BCG_END</CODE></A></H3>
<PRE> BCG_TYPE_BOOLEAN BCG_OT_READ_BCG_END (bcg_graph);
 BCG_TYPE_OBJECT_TRANSITION *bcg_graph;
  { ... }

</PRE>This function closes a BCG graph and erases the contents of the <I>*bcg_graph</I>
data structure. <P>
 <HR><BR>
  
<H2><A NAME="sect19" HREF="#sect19">Example</A></H2>
<PRE>#include "bcg_user.h"

/* The following function prints information about a BCG graph */
void bcg_print_info (bcg_graph)
BCG_TYPE_OBJECT_TRANSITION bcg_graph;
{
   printf ("initial state = %lu\n", BCG_OT_INITIAL_STATE (bcg_graph));
   printf ("nb states = %lu\n", BCG_OT_NB_STATES (bcg_graph));
   printf ("nb edges = %lu\n", BCG_OT_NB_EDGES (bcg_graph));
   printf ("nb labels = %u\n", BCG_OT_NB_LABELS (bcg_graph));
}

/* The following function displays an edge */

void bcg_print_edge (bcg_graph, bcg_state_1, bcg_label_number, bcg_state_2)
BCG_TYPE_OBJECT_TRANSITION bcg_graph;
BCG_TYPE_STATE_NUMBER bcg_state_1;
BCG_TYPE_LABEL_NUMBER bcg_label_number;
BCG_TYPE_STATE_NUMBER bcg_state_2;
{
   BCG_TYPE_C_STRING bcg_label_string;
   BCG_TYPE_BOOLEAN bcg_visible;
   BCG_TYPE_NATURAL bcg_cardinal;
   BCG_TYPE_C_STRING bcg_gate;

   bcg_label_string = BCG_OT_LABEL_STRING (bcg_graph, bcg_label_number);
   bcg_visible = BCG_OT_LABEL_VISIBLE (bcg_graph, bcg_label_number);
   bcg_cardinal = BCG_OT_LABEL_CARDINAL (bcg_graph, bcg_label_number);

   printf ("transition from state %lu to state %lu\n", 
           bcg_state_1, bcg_state_2);
   printf ("label unique number = %u\n", bcg_label_number);
   printf ("label string = %s\n", bcg_label_string);
   printf ("label cardinal = %u\n", bcg_cardinal);
   if (bcg_visible) {
      bcg_gate = BCG_OT_LABEL_GATE (bcg_graph, bcg_label_number);
      printf ("visible label (gate = %s)\n", bcg_gate);
   } else {
      bcg_gate = BCG_OT_LABEL_HIDDEN_GATE (bcg_graph, bcg_label_number);
      printf ("hidden label (hidden gate = %s)\n", bcg_gate);
   }
}

int main ()
{
   BCG_TYPE_OBJECT_TRANSITION bcg_graph;
   BCG_TYPE_STATE_NUMBER bcg_s1;
   BCG_TYPE_LABEL_NUMBER bcg_label_number;
   BCG_TYPE_STATE_NUMBER bcg_s2;
   BCG_TYPE_STATE_NUMBER bcg_nb_states;

   BCG_INIT ();

   /* The following fragment of code reads and prints all the edges 
      of a BCG graph, in an undefined order */

   BCG_OT_READ_BCG_BEGIN ("test.bcg", &amp;bcg_graph, 0);
   bcg_print_info (bcg_graph);
   BCG_OT_ITERATE_PLN (bcg_graph, bcg_s1, bcg_label_number, bcg_s2) {
      bcg_print_edge (bcg_graph, bcg_s1, bcg_label_number, bcg_s2);
   } BCG_OT_END_ITERATE;
   BCG_OT_READ_BCG_END (&amp;bcg_graph);

   /* The following fragment of code reads and prints all the edges 
      of a BCG graph, sorted by origin states in increasing order */

   BCG_OT_READ_BCG_BEGIN ("test.bcg", &amp;bcg_graph, 1);
   bcg_print_info (bcg_graph);
   bcg_nb_states = BCG_OT_NB_STATES (bcg_graph);
   for (bcg_s1 = 0; bcg_s1 &lt; bcg_nb_states; bcg_s1++) {
      printf ("successors of state %lu:\n", bcg_s1);
      BCG_OT_ITERATE_P_LN (bcg_graph, bcg_s1, bcg_label_number, bcg_s2)
{
        bcg_print_edge (bcg_graph, bcg_s1, bcg_label_number, bcg_s2);
      } BCG_OT_END_ITERATE;
   }
   BCG_OT_READ_BCG_END (&amp;bcg_graph);
   exit (0);
}
</PRE>
<H2><A NAME="sect20" HREF="#sect20">Compiling and Link Editing</A></H2>
To compile the application tool, the following
options must be passed to the C or C++ compiler: <P>
<B>-I$CADP/incl -L$CADP/bin.`$CADP/com/arch`
-lBCG_IO -lBCG -lm</B> <P>
as in, e.g., <P>
<PRE>   $CADP/src/com/cadp_cc tool.c -o tool -I$CADP/incl \
   -L$CADP/bin.`$CADP/com/arch` -lBCG_IO -lBCG -lm
</PRE>
<H2><A NAME="sect21" HREF="#sect21">Exit Status</A></H2>
Application tools share common conventions with respect to diagnostics.
Exit status is 0 if everything is alright, 1 otherwise. 
<H2><A NAME="sect22" HREF="#sect22">Authors</A></H2>
Hubert Garavel
(definition of the BCG format) and  Renaud Ruffiot (implementation of the
BCG environment). 
<H2><A NAME="sect23" HREF="#sect23">Files</A></H2>
See the <A HREF="bcg.html"><B>bcg</B></A>
 manual page for a description
of the files. 
<H2><A NAME="sect24" HREF="#sect24">See Also</A></H2>
<A HREF="bcg.html"><B>bcg</B></A>
 <P>
Additional information is available from
the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives for installation
are given in files <B>$CADP/INSTALLATION_*.</B> <P>
Recent changes and improvements
to this software are reported and commented in file <B>$CADP/HISTORY.</B> 
<H2><A NAME="sect25" HREF="#sect25">Bugs</A></H2>
Please
report bugs to <A HREF="mailto:Hubert.Garavel@inria.fr?Subject=CADP-Bug-Report">Hubert.Garavel@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Description</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Usage</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Data Types</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Features</A></LI>
<UL>
<LI><A NAME="toc5" HREF="#sect5">BCG_OT_READ_BCG_BEGIN</A></LI>
<LI><A NAME="toc6" HREF="#sect6">BCG_OT_READ_BCG_SURVIVE</A></LI>
<LI><A NAME="toc7" HREF="#sect7">BCG_OT_INITIAL_STATE</A></LI>
<LI><A NAME="toc8" HREF="#sect8">BCG_OT_NB_STATES</A></LI>
<LI><A NAME="toc9" HREF="#sect9">BCG_OT_NB_EDGES</A></LI>
<LI><A NAME="toc10" HREF="#sect10">BCG_OT_NB_LABELS</A></LI>
<LI><A NAME="toc11" HREF="#sect11">BCG_OT_LABEL_STRING</A></LI>
<LI><A NAME="toc12" HREF="#sect12">BCG_OT_LABEL_VISIBLE</A></LI>
<LI><A NAME="toc13" HREF="#sect13">BCG_OT_LABEL_GATE</A></LI>
<LI><A NAME="toc14" HREF="#sect14">BCG_OT_LABEL_HIDDEN_GATE</A></LI>
<LI><A NAME="toc15" HREF="#sect15">BCG_OT_LABEL_CARDINAL</A></LI>
<LI><A NAME="toc16" HREF="#sect16">BCG_OT_ITERATE_PLN</A></LI>
<LI><A NAME="toc17" HREF="#sect17">BCG_OT_ITERATE_P_LN</A></LI>
<LI><A NAME="toc18" HREF="#sect18">BCG_OT_READ_BCG_END</A></LI>
</UL>
<LI><A NAME="toc19" HREF="#sect19">Example</A></LI>
<LI><A NAME="toc20" HREF="#sect20">Compiling and Link Editing</A></LI>
<LI><A NAME="toc21" HREF="#sect21">Exit Status</A></LI>
<LI><A NAME="toc22" HREF="#sect22">Authors</A></LI>
<LI><A NAME="toc23" HREF="#sect23">Files</A></LI>
<LI><A NAME="toc24" HREF="#sect24">See Also</A></LI>
<LI><A NAME="toc25" HREF="#sect25">Bugs</A></LI>
</UL>
</BODY></HTML>
