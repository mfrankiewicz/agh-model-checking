  <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>caesar_diagnostic_1 manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
caesar_diagnostic_1 - the ``diagnostic_1'' library of OPEN/CAESAR 
<H2><A NAME="sect1" HREF="#sect1">Purpose</A></H2>
The
``diagnostic_1'' library provides primitives for managing diagnostics. <P>

<H2><A NAME="sect2" HREF="#sect2">Usage</A></H2>
The
``diagnostic_1'' library consists of: 
<UL>
<LI type=disc>a predefined header file <CODE>caesar_diagnostic_1.h</CODE>;
</LI><P><LI type=disc>the precompiled library file <CODE>libcaesar.a</CODE>, which implements the features
described in <CODE>caesar_diagnostic_1.h</CODE>. </LI><P>
</UL>
<P>
Note: The ``diagnostic_1'' library is a software
layer built above the primitives offered by the ``standard'', ``edge'' and ``stack_1''
libraries, and by the <I>OPEN/CAESAR</I> graph module. <P>
Note: The ``diagnostic_1'' library
relies on the ``edge'' and ``stack_1'' libraries. Therefore, when using the ``diagnostic_1''
library, there are restrictions concerning the use of the ``edge'' and ``stack_1''
library primitives. These restrictions are listed in the sequel. <P>

<H2><A NAME="sect3" HREF="#sect3">Description</A></H2>
A
``diagnostic'' is an execution sequence, i.e., a list of states and transitions
starting from the initial state of the graph and leading to a given state.
<P>
The ``size'' of a diagnostic is defined to be the number of states (not the
number of transitions) in the corresponding execution sequence. This definition
is compatible with the convention used for function <CODE>CAESAR_DEPTH_STACK_1()</CODE>.
<P>
Diagnostics are to be used during depth-first graph exploration. For this
reason, this library uses (and is compatible with) stacks provided by the
``stack_1'' library. Let's consider, for instance, an <I>OPEN/CAESAR</I> user program
that searches for deadlocks. Every time a deadlock state is detected, the
appropriate diagnostic is the contents of the stack, i.e., the execution
sequence leading from the initial state to the current deadlock state. <P>
The
``diagnostic_1'' allows to control the way diagnostics are printed. For instance,
it allows to display only the shortest diagnostic sequence detected. Other
``strategies'' are also available. The data structure used to store diagnostics
and related information is called a ``diagnostic structure''. <P>

<H2><A NAME="sect4" HREF="#sect4">Features</A></H2>
<P>
 <HR><BR>
 
<H3><A NAME="sect5" HREF="#sect5"><CODE>CAESAR_TYPE_DIAGNOSTIC_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_ABSTRACT (...) CAESAR_TYPE_DIAGNOSTIC_1;

</PRE>This type denotes a pointer to the concrete representation of a diagnostic
structure, which is supposed to be ``opaque''. <P>
 <HR><BR>
 
<H3><A NAME="sect6" HREF="#sect6"><CODE>CAESAR_TYPE_STRATEGY_DIAGNOSTIC_1</CODE></A></H3>
<PRE>typedef enum {
     CAESAR_NONE_DIAGNOSTIC_1,
     CAESAR_ALL_DIAGNOSTIC_1,
     CAESAR_FIRST_DIAGNOSTIC_1,
     CAESAR_DECREASING_DIAGNOSTIC_1,
     CAESAR_SHORTEST_DIAGNOSTIC_1
}    CAESAR_TYPE_STRATEGY_DIAGNOSTIC_1;

</PRE>This enumerated type defines the ``strategy'' used to print diagnostics during
graph exploration. Two steps are to be distinguished: every time an execution
sequence of interest is detected, it is ``recorded'' using the <CODE>CAESAR_RECORD_DIAGNOSTIC_1()</CODE>
function defined below. When the depth-first exploration is completed, a
``summary request'' is performed using the <CODE>CAESAR_SUMMARIZE_DIAGNOSTIC_1()</CODE>
function defined below. The effect of these two functions depends on the
chosen strategy: <P>

<UL>
<LI type=disc>With <CODE>CAESAR_NONE_DIAGNOSTIC_1</CODE>, only the result of the
exploration is printed (i.e., some diagnostic has been found or not). Diagnostics
themselves are not printed. </LI><P><LI type=disc>With <CODE>CAESAR_ALL_DIAGNOSTIC_1</CODE>, all diagnostics
are printed when they are recorded. </LI><P><LI type=disc>With <CODE>CAESAR_FIRST_DIAGNOSTIC_1</CODE>, only
the first diagnostic is printed when it is recorded; the next ones will
not be printed. </LI><P><LI type=disc>With <CODE>CAESAR_DECREASING_DIAGNOSTIC_1</CODE>, the first diagnostic
is printed when it is recorded; the next ones will be printed iff their
size is strictly smaller than all previously recorded diagnostics. </LI><P><LI type=disc>With
<CODE>CAESAR_SHORTEST_DIAGNOSTIC_1</CODE>, diagnostics are not printed when they are
recorded, but the diagnostic with the smallest size is stored in a diagnostic
structure. This shortest diagnostic (if any) will be printed when a summary
request is emitted. </LI><P>
</UL>
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect7" HREF="#sect7"><CODE>CAESAR_CREATE_DIAGNOSTIC_1</CODE></A></H3>
<PRE>void CAESAR_CREATE_DIAGNOSTIC_1 (CAESAR_D, CAESAR_STRATEGY,
                                 CAESAR_DEPTH, CAESAR_FILE,
                                 CAESAR_PROGRESS, CAESAR_HEADER,
                                 CAESAR_FOOTER, CAESAR_SEPARATOR,
                                 CAESAR_REPORT)
   CAESAR_TYPE_DIAGNOSTIC_1 *CAESAR_D;
   CAESAR_TYPE_STRATEGY_DIAGNOSTIC_1 CAESAR_STRATEGY;
   CAESAR_TYPE_NATURAL CAESAR_DEPTH;
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_STRING CAESAR_PROGRESS;
   CAESAR_TYPE_STRING CAESAR_HEADER;
   CAESAR_TYPE_STRING CAESAR_FOOTER;
   CAESAR_TYPE_STRING CAESAR_SEPARATOR;
   CAESAR_TYPE_STRING CAESAR_REPORT;
   { ... }

</PRE>This procedure allocates a diagnostic structure using <CODE>CAESAR_CREATE()</CODE> and
assigns its address to <CODE>*CAESAR_D</CODE>. If the allocation fails, the <CODE>NULL</CODE> value
is assigned to <CODE>*CAESAR_D</CODE>. <P>
Note: because <CODE>CAESAR_TYPE_DIAGNOSTIC_1</CODE> is a pointer
type, any variable <CODE>CAESAR_D</CODE> of type <CODE>CAESAR_TYPE_DIAGNOSTIC_1</CODE> must be allocated
before used, for instance using: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_CREATE_DIAGNOSTIC_1 (&amp;CAESAR_D,
...);</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
Note: Before calling this procedure, the <CODE>CAESAR_INIT_STACK_1()</CODE> procedure
of the ``stack_1'' library should have been invoked (because the ``diagnostic_1''
library uses the ``stack_1'' library). Also, the restrictions concerning the
<CODE>CAESAR_INIT_STACK_1()</CODE> procedure should be observed. <P>
The actual values of
the remaining formal parameters will be stored and associated to the diagnostic
structure pointed to by <CODE>*CAESAR_D</CODE>. <P>
The value of <CODE>CAESAR_STRATEGY</CODE> determines
the strategy used for this diagnostic structure. <P>
The value of <CODE>CAESAR_DEPTH</CODE>
determines the ``maximal depth'' used for this diagnostic structure, i.e., an
upper bound on the sizes of the diagnostics. If <CODE>CAESAR_DEPTH</CODE> is equal to
zero, there is no upper bound. <P>
The value of <CODE>CAESAR_FILE</CODE> determines the output
file to which the diagnostics will be printed. Before any diagnostic is
printed, <CODE>CAESAR_FILE</CODE> must have been properly opened, for instance using
<CODE>fopen(3)</CODE>. <P>
The values of <CODE>CAESAR_PROGRESS</CODE>, <CODE>CAESAR_HEADER</CODE>, <CODE>CAESAR_FOOTER</CODE>, <CODE>CAESAR_SEPARATOR</CODE>,
and <CODE>CAESAR_REPORT</CODE> are character strings to be used for printing the diagnostics.
The exact semantics of these parameters will not be defined here. For interoperability
with the other tools of the CADP toolset (see the <CODE>seq</CODE> manual page for a
definition of the SEQ format), it is advised to use the following actual
values: <P>
<PRE>   CAESAR_PROGRESS  = "*** sequence(s) found at depth "
   CAESAR_HEADER    = "*** sequence found at depth %u\n\n\001&lt;initial state&gt;\002\n"
   CAESAR_FOOTER    = "\001&lt;goal state&gt;\002\n\n"
   CAESAR_SEPARATOR = "[]\n\n"
   CAESAR_REPORT    = "*** no sequence found\n\n"

</PRE>or, depending on the context: <P>
<PRE>    CAESAR_PROGRESS  = "*** deadlock(s) found at depth "
    CAESAR_HEADER    = "*** deadlock found at depth %u\n\n\001&lt;initial state&gt;\002\n"
    CAESAR_FOOTER    = "&lt;deadlock&gt;\n\n"
    CAESAR_SEPARATOR = "[]\n\n"
    CAESAR_REPORT    = "*** no deadlock found\n\n"

</PRE><P>
 <HR><BR>
 
<H3><A NAME="sect8" HREF="#sect8"><CODE>CAESAR_DELETE_DIAGNOSTIC_1</CODE></A></H3>
<PRE>void CAESAR_DELETE_DIAGNOSTIC_1 (CAESAR_D)
   CAESAR_TYPE_DIAGNOSTIC_1 *CAESAR_D;
   { ... }

</PRE>This procedure frees the memory space corresponding to the diagnostic structure
pointed to by <CODE>*CAESAR_D</CODE> using <CODE>CAESAR_DELETE()</CODE>. Afterwards, the <CODE>NULL</CODE> value
is assigned to <CODE>*CAESAR_D</CODE>. <P>
 <HR><BR>
 
<H3><A NAME="sect9" HREF="#sect9"><CODE>CAESAR_RECORD_DIAGNOSTIC_1</CODE></A></H3>
<PRE>void CAESAR_RECORD_DIAGNOSTIC_1 (CAESAR_D, CAESAR_K)
   CAESAR_TYPE_DIAGNOSTIC_1 CAESAR_D;
   CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This procedure records into the diagnostic structure pointed to by <CODE>*CAESAR_D</CODE>
the diagnostic contained in the stack pointed to by <CODE>*CAESAR_K</CODE>. The stack
pointed to by <CODE>*CAESAR_K</CODE> should contain at least one item (the initial state
of the sequence); if it is empty, the result is undefined. The effects of
this procedure depend on the strategy and maximal depth associated with
the diagnostic structure: <P>

<UL>
<LI type=disc>With <CODE>CAESAR_NONE_DIAGNOSTIC_1</CODE>, the diagnostic
is not printed but stored into the diagnostic structure. </LI><P><LI type=disc>With <CODE>CAESAR_ALL_DIAGNOSTIC_1</CODE>,
the diagnostic is immediately printed. </LI><P><LI type=disc>With <CODE>CAESAR_FIRST_DIAGNOSTIC_1</CODE>, the
diagnostic is immediately printed if it is the first one to be recorded;
otherwise nothing is done. </LI><P><LI type=disc>With <CODE>CAESAR_DECREASING_DIAGNOSTIC_1</CODE>, the diagnostic
is immediately printed if its size is less or equal than the maximal depth
(if the maximal depth is not equal to zero) and strictly less than the
sizes of all previously recorded diagnostics. </LI><P><LI type=disc>With <CODE>CAESAR_SHORTEST_DIAGNOSTIC_1</CODE>,
the diagnostic is not printed but stored into the diagnostic structure
if its size os less or equal than the maximal depth (if the maximal depth
is not equal to zero) and strictly less than the sizes of all previously
recorded diagnostics. If the character string <CODE>CAESAR_PROGRESS</CODE> specified
for <CODE>*CAESAR_D</CODE> is not the <CODE>NULL</CODE> pointer, it is printed, together with the
size of the recorded diagnostic. </LI><P>
</UL>
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect10" HREF="#sect10"><CODE>CAESAR_SUMMARIZE_DIAGNOSTIC_1</CODE></A></H3>
<PRE>void CAESAR_SUMMARIZE_DIAGNOSTIC_1 (CAESAR_D)
   CAESAR_TYPE_DIAGNOSTIC_1 CAESAR_D;
   { ... }

</PRE>This procedure summarizes the current status of the diagnostic structure
pointed to by <CODE>*CAESAR_D</CODE>. The effects of this procedure depends on the strategy
associated with the diagnostic structure: <P>

<UL>
<LI type=disc>With <CODE>CAESAR_NONE_DIAGNOSTIC_1</CODE>,
the result of the exploration is displayed: if diagnostics have been recorded,
the size of the most recently recorded one is printed; otherwise, the character
string <CODE>CAESAR_REPORT</CODE> is printed if no diagnostic has been recorded into
the diagnostic structure. </LI><P><LI type=disc>With <CODE>CAESAR_ALL_DIAGNOSTIC_1</CODE>, the character string
<CODE>CAESAR_REPORT</CODE> is printed if no diagnostic has been previously recorded
into the diagnostic structure. </LI><P><LI type=disc>With <CODE>CAESAR_FIRST_DIAGNOSTIC_1</CODE>, same as for
<CODE>CAESAR_ALL_DIAGNOSTIC_1</CODE>. </LI><P><LI type=disc>With <CODE>CAESAR_DECREASING_DIAGNOSTIC_1</CODE>, same as for
<CODE>CAESAR_ALL_DIAGNOSTIC_1</CODE>. </LI><P><LI type=disc>With <CODE>CAESAR_SHORTEST_DIAGNOSTIC_1</CODE>, the shortest
diagnostic recorded is printed, or the character string <CODE>CAESAR_REPORT</CODE> is
printed if no diagnostic has been recorded into the diagnostic structure.
</LI><P>
</UL>
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect11" HREF="#sect11"><CODE>CAESAR_EMPTY_DIAGNOSTIC_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_EMPTY_DIAGNOSTIC_1 (CAESAR_D)
   CAESAR_TYPE_DIAGNOSTIC_1 CAESAR_D;
   { ... }

</PRE>This function returns the boolean value <CODE>CAESAR_TRUE</CODE> iff at least one diagnostic
has been previously recorded (using the <CODE>CAESAR_RECORD_DIAGNOSTIC_1()</CODE> function)
into the diagnostic structure pointed to by <CODE>*CAESAR_D</CODE>. <P>
 <HR><BR>
 
<H3><A NAME="sect12" HREF="#sect12"><CODE>CAESAR_BACKTRACK_DIAGNOSTIC_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_BACKTRACK_DIAGNOSTIC_1 (CAESAR_D, CAESAR_DEPTH)
   CAESAR_TYPE_DIAGNOSTIC_1 CAESAR_D;
   CAESAR_TYPE_NATURAL CAESAR_DEPTH;
   { ... }

</PRE>This function returns the boolean value <CODE>CAESAR_TRUE</CODE> iff the exploration
should stop and backtrack when reaching depth <CODE>CAESAR_DEPTH</CODE>. For instance,
in a depth-first search, the actual value of <CODE>CAESAR_DEPTH</CODE> should be equal
to the current depth of the stack. The result depends on the strategy and
maximal depth associated with the diagnostic structure pointed to by <CODE>*CAESAR_D</CODE>:
<P>

<UL>
<LI type=disc>With <CODE>CAESAR_NONE_DIAGNOSTIC_1</CODE>, the result is <CODE>CAESAR_TRUE</CODE> iff <CODE>CAESAR_DEPTH</CODE>
is strictly greater than the maximal depth (if the maximal depth is not
equal to zero). </LI><P><LI type=disc>With <CODE>CAESAR_ALL_DIAGNOSTIC_1</CODE>, same as for <CODE>CAESAR_NONE_DIAGNOSTIC_1</CODE>.
</LI><P><LI type=disc>With <CODE>CAESAR_FIRST_DIAGNOSTIC_1</CODE>, the result is <CODE>CAESAR_TRUE</CODE> iff <CODE>CAESAR_DEPTH</CODE>
is strictly greater than the maximal depth (if the maximal depth is not
equal to zero) or if some diagnostic has been previously recorded into
the diagnostic structure. </LI><P><LI type=disc>With <CODE>CAESAR_DECREASING_DIAGNOSTIC_1</CODE>, the result
is <CODE>CAESAR_TRUE</CODE> iff <CODE>CAESAR_DEPTH</CODE> is strictly greater than the maximal depth
(if the maximal depth is not equal to zero) or if it is greater or equal
to the size of some previously recorded diagnostic. </LI><P><LI type=disc>With <CODE>CAESAR_SHORTEST_DIAGNOSTIC_1</CODE>,
same as for <CODE>CAESAR_DECREASING_DIAGNOSTIC_1</CODE>. </LI><P>
</UL>
<P>
<P>
 <HR><BR>
 
<H2><A NAME="sect13" HREF="#sect13">Author(s)</A></H2>
Hubert Garavel 
<H2><A NAME="sect14" HREF="#sect14">Files</A></H2>
 
<DL><DD><DL COMPACT>

<DT><B>$CADP/incl/caesar_graph.h</B> </DT>
<DD>interface of the
graph module </DD><P>

<DT><B>$CADP/incl/caesar_*.h</B> </DT>
<DD>interfaces of the storage module </DD><P>

<DT><B>$CADP/bin.`arch`/libcaesar.a</B>
</DT>
<DD>object code of the storage module </DD><P>

<DT><B>$CADP/src/open_caesar/*.c</B> </DT>
<DD>source code
of various exploration modules </DD><P>

<DT><B>$CADP/com/lotos.open</B> </DT>
<DD>shell script to run
OPEN/CAESAR  </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect15" HREF="#sect15">See Also</A></H2>
Reference Manuals of OPEN/CAESAR, CAESAR, and CAESAR.ADT,
<A HREF="lotos.open.html"><B>lotos.open</B></A>
, <A HREF="caesar.html"><B>caesar</B></A>
, <A HREF="caesar.adt.html"><B>caesar.adt</B></A>
 <P>
Additional information
is available from the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives
for installation are given in files <B>$CADP/INSTALLATION_*.</B> <P>
Recent changes
and improvements to this software are reported and commented in file <B>$CADP/HISTORY.</B>

<H2><A NAME="sect16" HREF="#sect16">Bugs</A></H2>
Known bugs are described in the Reference Manual of OPEN/CAESAR. Please
report new bugs to <A HREF="mailto:cadp@inria.fr?Subject=CADP-Bug-Report">cadp@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Purpose</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Usage</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Description</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Features</A></LI>
<UL>
<LI><A NAME="toc5" HREF="#sect5">CAESAR_TYPE_DIAGNOSTIC_1</A></LI>
<LI><A NAME="toc6" HREF="#sect6">CAESAR_TYPE_STRATEGY_DIAGNOSTIC_1</A></LI>
<LI><A NAME="toc7" HREF="#sect7">CAESAR_CREATE_DIAGNOSTIC_1</A></LI>
<LI><A NAME="toc8" HREF="#sect8">CAESAR_DELETE_DIAGNOSTIC_1</A></LI>
<LI><A NAME="toc9" HREF="#sect9">CAESAR_RECORD_DIAGNOSTIC_1</A></LI>
<LI><A NAME="toc10" HREF="#sect10">CAESAR_SUMMARIZE_DIAGNOSTIC_1</A></LI>
<LI><A NAME="toc11" HREF="#sect11">CAESAR_EMPTY_DIAGNOSTIC_1</A></LI>
<LI><A NAME="toc12" HREF="#sect12">CAESAR_BACKTRACK_DIAGNOSTIC_1</A></LI>
</UL>
<LI><A NAME="toc13" HREF="#sect13">Author(s)</A></LI>
<LI><A NAME="toc14" HREF="#sect14">Files</A></LI>
<LI><A NAME="toc15" HREF="#sect15">See Also</A></LI>
<LI><A NAME="toc16" HREF="#sect16">Bugs</A></LI>
</UL>
</BODY></HTML>
