  <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>caesar_graph manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
caesar_graph - the ``graph'' library of OPEN/CAESAR 
<H2><A NAME="sect1" HREF="#sect1">Purpose</A></H2>
The ``graph
module'' provides a C representation for the states and the labels of the
transition system generated from the source program. It provides primitives
to handle those states and labels. <P>
It also provides primitives to compute
the transition relation (i.e., primitives to compute the initial state and
the successors of any given state). <P>
The application programming interface
specified by the graph module is language-independent: various languages
can be implemented so as to comply with the ``graph module'' interface. <P>
Note:
The functions and procedures specified below should not perform input/output
operations on the standard input and standard output, especially reading
from the standard input or writing to the standard output. As a general
principle, access to standard input and standard output is reserved to
the <I>OPEN/CAESAR</I> application programs (and not to the graph module). If the
functions of the graph module want to emit debugging information, this
information should be sent to the standard error or, preferably, to a named,
unbuffered log file. Otherwise, some <I>OPEN/CAESAR</I> application programs that
rely on the standard input and standard output (e.g., the <I>OPEN/CAESAR</I> Interactive
Simulator) might not function properly if the graph module performs conflicting
accesses to the standard input or the standard output. <P>

<H2><A NAME="sect2" HREF="#sect2">Usage</A></H2>
The graph module
consists of: <P>

<UL>
<LI type=disc>A predefined header file <CODE>caesar_graph.h</CODE>, which can be found
in the <I>OPEN/CAESAR</I> package. This file is an interface specification describing
a set of C types, procedures, and functions. Conceptually, it can be seen
as an abstract data type, with sorts and operations. </LI><P><LI type=disc>A C file <CODE>spec.c</CODE>, which
is generated from the source program (where <CODE>spec</CODE> can be any valid filename).
For instance, in the case of a LOTOS program <CODE>spec.lotos</CODE>, file <CODE>spec.c</CODE> is generated
by <I>CAESAR</I> with the <CODE>-open</CODE> option. The <CODE>spec.c</CODE> file provides an implementation
for all the features described in <CODE>caesar_graph.h</CODE>. </LI><P>
</UL>
<P>
The <CODE>spec.c</CODE> must start with
the two following directives: <P>
<PRE>         #define CAESAR_GRAPH_IMPLEMENTATION ...
         #include "caesar_graph.h"

</PRE>where <CODE>...</CODE> should be replaced by an integer number corresponding to the version
of the graph module interface for which <CODE>spec.c</CODE> has been produced. As far
as possible, this integer number will be used to preserve backward compatibility
in case of future modifications of the graph module interface. Concretely,
this integer number is obtained by taking the version number given for
<I>OPEN/CAESAR</I> at the bottom of file <CODE>$CADP/VERSION</CODE>, then by multiplying by
10 this version number (considered as real number) in order to turn it
into an integer number (since the C preprocessor only handles integers).
For instance, if the version of <I>OPEN/CAESAR</I> is 2.4 in the <CODE>$CADP/VERSION</CODE>
file, then <CODE>CAESAR_GRAPH_IMPLEMENTATION</CODE> should be set to 24. <P>
The features
defined in `<CODE>caesar_graph.h</CODE>'' are described below. <P>
Note: The graph module uses
the primitives offered by the ``standard'' and ``version'' libraries. <P>

<H2><A NAME="sect3" HREF="#sect3">General Features</A></H2>
<P>

<HR><BR>
 
<H3><A NAME="sect4" HREF="#sect4"><CODE>CAESAR_GRAPH_COMPILER</CODE></A></H3>
<PRE>CAESAR_TYPE_STRING CAESAR_GRAPH_COMPILER ()
   { ... }

</PRE>This function returns a character string containing the name (in upper
case letters) of the compiler tool which generated the C program <CODE>spec.c</CODE>.
For instance, if <CODE>spec.c</CODE> is generated by <I>CAESAR</I> from a LOTOS program, the
result of function <CODE>CAESAR_GRAPH_COMPILER()</CODE> is the character string <CODE>"CAESAR"</CODE>.
<P>
Note: It is not allowed to modify the character string returned by <CODE>CAESAR_GRAPH_COMPILER()</CODE>
nor to free it, for instance using <CODE>free(3)</CODE>. <P>
Note: The contents of the character
string returned by <CODE>CAESAR_GRAPH_COMPILER()</CODE> may be destroyed by a subsequent
call to this function. <P>
 <HR><BR>
 
<H3><A NAME="sect5" HREF="#sect5"><CODE>CAESAR_GRAPH_VERSION</CODE></A></H3>
<PRE>CAESAR_TYPE_VERSION CAESAR_GRAPH_VERSION ()
   { ... }

</PRE>This function returns the version number of the compiler tool which generated
the C program <CODE>spec.c</CODE>. <P>
 <HR><BR>
 
<H3><A NAME="sect6" HREF="#sect6"><CODE>CAESAR_INIT_GRAPH</CODE></A></H3>
<PRE>void CAESAR_INIT_GRAPH ()
   { ... }

</PRE>This procedure contains initialization actions for the graph module. It
must be invoked once before using any routine of this module. <P>
Implementation
note: This procedure should invoke the <CODE>CAESAR_CHECK_VERSION()</CODE> procedure
(see the corresponding description in the ``version'' library) in order to
detect version clashes between <CODE>spec.c</CODE> and <CODE>caesar_graph.h</CODE>. 
<H2><A NAME="sect7" HREF="#sect7">State Features</A></H2>
<P>
 <HR><BR>
 
<H3><A NAME="sect8" HREF="#sect8"><CODE>CAESAR_BODY_STATE</CODE></A></H3>
<PRE>typedef struct CAESAR_STRUCT_STATE { ... } CAESAR_BODY_STATE;

</PRE>This type denotes the actual implementation of states in the labelled transition
system. Each state is basically a structure named <CODE>CAESAR_STRUCT_STATE</CODE>. Thus,
each state can be seen as a byte string of fixed size (see function <CODE>CAESAR_SIZE_STATE()</CODE>
below) with definite alignment constraints (see function <CODE>CAESAR_ALIGNMENT_STATE()</CODE>
below), and all the states have the same size. <P>
State definition is ``opaque'':
the detailed definition of <CODE>CAESAR_STRUCT_STATE</CODE> and <CODE>CAESAR_BODY_STATE</CODE> is
only available in include mode, but not in link mode. Therefore, making
assumptions about the fields of structure <CODE>CAESAR_STRUCT_STATE</CODE> is not advisable.
<P>
 <HR><BR>
 
<H3><A NAME="sect9" HREF="#sect9"><CODE>CAESAR_TYPE_STATE</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_ABSTRACT (...) CAESAR_TYPE_STATE;

</PRE>This type denotes a pointer to the (opaque) representation of states. It
is given an abstract definition in file <CODE>caesar_graph.h</CODE> and should be redefined
in <CODE>spec.c</CODE>. <P>
Concretely, <CODE>CAESAR_TYPE_STATE</CODE> should be defined as a pointer to
a structure named <CODE>CAESAR_STRUCT_STATE</CODE> or, equivalently, a pointer to type
<CODE>CAESAR_BODY_STATE</CODE> (see above). <P>
 <HR><BR>
 
<H3><A NAME="sect10" HREF="#sect10"><CODE>CAESAR_SIZE_STATE</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_SIZE_STATE ()
   { ... }

</PRE>This function returns the state size (in bytes), which is always greater
than 0. <P>
Implementation note: Practically, in <CODE>caesar_graph.h</CODE>, function <CODE>CAESAR_SIZE_STATE()</CODE>
is defined as follows: <PRE>         #define CAESAR_SIZE_STATE() CAESAR_HINT_SIZE_STATE

</PRE>where <CODE>CAESAR_HINT_SIZE_STATE</CODE> is a variable defined by: <PRE>         extern CAESAR_TYPE_NATURAL CAESAR_HINT_SIZE_STATE;

</PRE>This variable should be defined, properly initialized, and exported by
<CODE>spec.c</CODE>. It should neither be used nor assigned in any other program than
<CODE>spec.c</CODE>. This variable is only introduced for efficiency reasons, i.e., to avoid
the cost of a function call. <P>
 <HR><BR>
 
<H3><A NAME="sect11" HREF="#sect11"><CODE>CAESAR_HASH_SIZE_STATE</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_HASH_SIZE_STATE ()
   { ... }

</PRE>This function returns a number of bytes N such that, for any state pointed
to by a variable <CODE>CAESAR_S</CODE>, one can compute a hash function which takes
into account the value of the following bytes: <CODE>CAESAR_S</CODE> [0], <CODE>CAESAR_S</CODE> [1],
... and <CODE>CAESAR_S</CODE> [N-1]. <P>
Note: It is always true that: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> 0 &lt; <CODE>CAESAR_HASH_SIZE_STATE
()</CODE> &lt;= <CODE>CAESAR_SIZE_STATE ()</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>but it is possible that: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_HASH_SIZE_STATE
()</CODE> &lt; <CODE>CAESAR_SIZE_STATE ()</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>especially if the state vector contains variables
of pointer types. By using this function, users can write their own hash
functions. <P>
Implementation note: Practically, in <CODE>caesar_graph.h</CODE>, function
<CODE>CAESAR_HASH_SIZE_STATE()</CODE> is defined as follows: <PRE>         #define CAESAR_HASH_SIZE_STATE() CAESAR_HINT_HASH_SIZE_STATE

</PRE>where <CODE>CAESAR_HINT_HASH_SIZE_STATE</CODE> is a variable defined by: <PRE>         extern CAESAR_TYPE_NATURAL CAESAR_HINT_HASH_SIZE_STATE;

</PRE>This variable should be defined, properly initialized, and exported by
<CODE>spec.c</CODE>. It should neither be used nor assigned in any other program than
<CODE>spec.c</CODE>. This variable is only introduced for efficiency reasons, i.e., to avoid
the cost of a function call. <P>
 <HR><BR>
 
<H3><A NAME="sect12" HREF="#sect12"><CODE>CAESAR_ALIGNMENT_STATE</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_ALIGNMENT_STATE ()
   { ... }

</PRE>This function returns the alignment factor (in bytes) for states. The alignment
factor is always a power of two, usually 1, 2, 4, or 8. Any byte string
representing a state must be aligned on a boundary that is an even multiple
of the alignment factor. <P>
Implementation note: Practically, in <CODE>caesar_graph.h</CODE>,
function <CODE>CAESAR_ALIGNMENT_STATE()</CODE> is defined as follows: <PRE>         #define CAESAR_ALIGNMENT_STATE() CAESAR_HINT_ALIGNMENT_STATE

</PRE>where <CODE>CAESAR_HINT_ALIGNMENT_STATE</CODE> is a variable defined by: <PRE>         extern CAESAR_TYPE_NATURAL CAESAR_HINT_ALIGNMENT_STATE;

</PRE>This variable should be defined, properly initialized, and exported by
<CODE>spec.c</CODE>. It should neither be used nor assigned in any other program than
<CODE>spec.c</CODE>. This variable is only introduced for efficiency reasons, i.e., to avoid
the cost of a function call. <P>
 <HR><BR>
 
<H3><A NAME="sect13" HREF="#sect13"><CODE>CAESAR_CREATE_STATE</CODE></A></H3>
<PRE>void CAESAR_CREATE_STATE (CAESAR_S)
   CAESAR_TYPE_STATE *CAESAR_S;
   { ... }

</PRE>This procedure allocates a byte string of length <CODE>CAESAR_SIZE_STATE()</CODE> using
<CODE>CAESAR_CREATE()</CODE> and assigns its address to <CODE>*CAESAR_S</CODE>. If the allocation
fails, the <CODE>NULL</CODE> value is assigned to <CODE>*CAESAR_S</CODE>. <P>
Note: because <CODE>CAESAR_TYPE_STATE</CODE>
is a pointer type, any variable <CODE>CAESAR_S</CODE> of type <CODE>CAESAR_TYPE_STATE</CODE> must
be allocated before used, for instance using: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_CREATE_STATE (&amp;CAESAR_S);</CODE>
</TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>However, it is not necessary to use <CODE>CAESAR_CREATE_STATE()</CODE> to perform the
allocation. Instead, users can allocate states into their own data structures
(tables, lists, ...) <P>
Implementation note: It is not necessary to define <CODE>CAESAR_CREATE_STATE()</CODE>
in <CODE>spec.c</CODE> because <CODE>caesar_graph.h</CODE> already implements this procedure using
a macro-definition. <P>
 <HR><BR>
 
<H3><A NAME="sect14" HREF="#sect14"><CODE>CAESAR_DELETE_STATE</CODE></A></H3>
<PRE>void CAESAR_DELETE_STATE (CAESAR_S)
   CAESAR_TYPE_STATE *CAESAR_S;
   { ... }

</PRE>This procedure frees the byte string of length <CODE>CAESAR_SIZE_STATE()</CODE> pointed
to by <CODE>*CAESAR_S</CODE> using <CODE>CAESAR_DELETE()</CODE>. Afterwards, the <CODE>NULL</CODE> value is assigned
to <CODE>*CAESAR_S</CODE>. <P>
Implementation note: It is not necessary to define <CODE>CAESAR_DELETE_STATE()</CODE>
in <CODE>spec.c</CODE> because <CODE>caesar_graph.h</CODE> already implements this procedure using
a macro-definition. <P>
 <HR><BR>
 
<H3><A NAME="sect15" HREF="#sect15"><CODE>CAESAR_COPY_STATE</CODE></A></H3>
<PRE>void CAESAR_COPY_STATE (CAESAR_S1, CAESAR_S2)
   CAESAR_TYPE_STATE CAESAR_S1;
   CAESAR_TYPE_STATE CAESAR_S2;
   { ... }

</PRE>This procedure copies the state pointed to by <CODE>CAESAR_S2</CODE> onto the state
pointed to by <CODE>CAESAR_S1</CODE>. <P>
Note: Parameter <CODE>CAESAR_S2</CODE> must point to a memory
location allocated before procedure <CODE>CAESAR_COPY_STATE()</CODE> is invoked. <P>
Implementation
note: It is not necessary to define <CODE>CAESAR_COPY_STATE()</CODE> in <CODE>spec.c</CODE> because
<CODE>caesar_graph.h</CODE> already implements this procedure using a macro-definition.
<P>
 <HR><BR>
 
<H3><A NAME="sect16" HREF="#sect16"><CODE>CAESAR_COMPARE_STATE</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_COMPARE_STATE (CAESAR_S1, CAESAR_S2)
   CAESAR_TYPE_STATE CAESAR_S1;
   CAESAR_TYPE_STATE CAESAR_S2;
   { ... }

</PRE>This function returns a value different from 0 if both states pointed to
by <CODE>CAESAR_S1</CODE> and <CODE>CAESAR_S2</CODE> are identical, or 0 if they are not. <P>
 <HR><BR>
 
<H3><A NAME="sect17" HREF="#sect17"><CODE>CAESAR_HASH_STATE</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_HASH_STATE (CAESAR_S, CAESAR_MODULUS)
   CAESAR_TYPE_STATE CAESAR_S;
   CAESAR_TYPE_NATURAL CAESAR_MODULUS;
   { ... }

</PRE>This function computes a hash-code value for the state pointed to by <CODE>CAESAR_S</CODE>
and returns this value, which must be in the range 0..<CODE>CAESAR_MODULUS</CODE>-1. <P>
 <HR><BR>
 
<H3><A NAME="sect18" HREF="#sect18"><CODE>CAESAR_FORMAT_STATE</CODE></A></H3>
<PRE>void CAESAR_FORMAT_STATE (CAESAR_FORMAT)
   CAESAR_TYPE_FORMAT CAESAR_FORMAT;
   { ... }

</PRE>This procedure allows to control the format under which states are printed
by procedures <CODE>CAESAR_PRINT_STATE_HEADER()</CODE>, <CODE>CAESAR_PRINT_STATE()</CODE>, and <CODE>CAESAR_DELTA_STATE()</CODE>
(see below). Currently, the following formats are available: <P>

<UL>
<LI type=disc>If the current
state format is 0, each state is printed on a single line, which should
not be terminated by a new-line character (``\<CODE>n</CODE>''). <P>
<I>CAESAR</I>-specific note: states
generated from LOTOS programs are printed as a pair consisting of a marking
part (marked places in the parallel components) and a context part (values
of state variables). <P>
<I>CAESAR</I>-specific note: only one state format (numbered
0) is available. </LI><P><LI type=disc>(no other format available yet). </LI><P>
</UL>
<P>
By default, the current
state format is initialized to 0. <P>
When called with <CODE>CAESAR_FORMAT</CODE> between
0 and the maximal format value supported, this fonction sets the current
state format to <CODE>CAESAR_FORMAT</CODE> and returns an undefined result. <P>
When called
with another value of <CODE>CAESAR_FORMAT</CODE>, this function does not modify the
current state format but returns a result defined as follows. If <CODE>CAESAR_FORMAT</CODE>
is equal to the constant <CODE>CAESAR_CURRENT_FORMAT</CODE>, the result is the value
of the current state format. If <CODE>CAESAR_FORMAT</CODE> is equal to the constant <CODE>CAESAR_MAXIMAL_FORMAT</CODE>,
the result is the maximal format value (e.g., 0 in the case of <I>CAESAR</I>). In
all other cases, the effect of this function is undefined. <P>
 <HR><BR>
 
<H3><A NAME="sect19" HREF="#sect19"><CODE>CAESAR_MAX_FORMAT_STATE</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_MAX_FORMAT_STATE ()
   { ... }

</PRE>Caution! This function is deprecated. It should no longer be used, as it
might be removed from future versions of the <I>OPEN/CAESAR</I>. Use function <CODE>CAESAR_FORMAT_STATE()</CODE>
instead, called with argument <CODE>CAESAR_MAXIMAL_FORMAT</CODE>. <P>
This function returns
the highest format available for state printing, i.e., the highest acceptable
value for the parameter <CODE>CAESAR_FORMAT</CODE> of function <CODE>CAESAR_FORMAT_STATE()</CODE>.
<P>
 <HR><BR>
 
<H3><A NAME="sect20" HREF="#sect20"><CODE>CAESAR_PRINT_STATE_HEADER</CODE></A></H3>
<PRE>void CAESAR_PRINT_STATE_HEADER (CAESAR_FILE)
   CAESAR_TYPE_FILE CAESAR_FILE;
   { ... }

</PRE>This procedure prints to file <CODE>CAESAR_FILE</CODE> information about the structure
of states. The nature of the information is determined by the current state
format (see procedure <CODE>CAESAR_FORMAT_STATE()</CODE> above). This procedure is to
be used in conjunction with the next one. <P>
Before this procedure is called,
<CODE>CAESAR_FILE</CODE> must have been properly opened, for instance using <CODE>fopen(3)</CODE>.
<P>
 <HR><BR>
 
<H3><A NAME="sect21" HREF="#sect21"><CODE>CAESAR_PRINT_STATE</CODE></A></H3>
<PRE>void CAESAR_PRINT_STATE (CAESAR_FILE, CAESAR_S)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_STATE CAESAR_S;
   { ... }

</PRE>This procedure prints to file <CODE>CAESAR_FILE</CODE> information about the contents
of the state pointed to by <CODE>CAESAR_S</CODE>. The nature of the information is determined
by the current state format (see procedure <CODE>CAESAR_FORMAT_STATE()</CODE> above).
<P>
Before this procedure is called, <CODE>CAESAR_FILE</CODE> must have been properly opened,
for instance using <CODE>fopen(3)</CODE>. <P>
 <HR><BR>
 
<H3><A NAME="sect22" HREF="#sect22"><CODE>CAESAR_DELTA_STATE</CODE></A></H3>
<PRE>void CAESAR_DELTA_STATE (CAESAR_FILE, CAESAR_S1, CAESAR_S2)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_STATE CAESAR_S1;
   CAESAR_TYPE_STATE CAESAR_S2;
   { ... }

</PRE>This procedure prints to file <CODE>CAESAR_FILE</CODE> information about the differences
(``delta'') between both states pointed to by <CODE>CAESAR_S1</CODE> and <CODE>CAESAR_S2</CODE> respectively.
The nature of the information is determined by the current state format
(see procedure <CODE>CAESAR_FORMAT_STATE()</CODE> above). <P>
Before this procedure is called,
<CODE>CAESAR_FILE</CODE> must have been properly opened, for instance using <CODE>fopen(3)</CODE>.

<H2><A NAME="sect23" HREF="#sect23">Label Features</A></H2>
<P>
 <HR><BR>
 
<H3><A NAME="sect24" HREF="#sect24"><CODE>CAESAR_BODY_LABEL</CODE></A></H3>
<PRE>typedef struct CAESAR_STRUCT_LABEL { ... } CAESAR_BODY_LABEL;

</PRE>This type denotes the actual implementation of labels in the labelled transition
system. Each label is basically a structure named <CODE>CAESAR_STRUCT_LABEL</CODE>. Thus,
each label is a byte string of fixed size (see function <CODE>CAESAR_SIZE_LABEL()</CODE>
below) with definite alignment constraints (see function <CODE>CAESAR_ALIGNMENT_LABEL()</CODE>
below), and all the labels have the same size. In a first approach, the
label representation is supposed to be ``opaque'': the detailed definition
of <CODE>CAESAR_STRUCT_LABEL</CODE> and <CODE>CAESAR_BODY_LABEL</CODE> is only available in include
mode, but not in link mode. Therefore, making assumptions about the fields
of structure <CODE>CAESAR_STRUCT_LABEL</CODE> is not advisable. <P>
In a refined approach,
it is assumed that labels have an internal structure consisting of a <I>gate</I>
(i.e., an identifier representing the name of a communication port) and a
finite list of <I>experiment offers</I> (i.e., typed data parameters exchanged on
the gate). This assumption is made without loss of generality: although
the names <I>gate</I> and <I>experiment offer</I> are borrowed from the LOTOS vocabulary,
most formal description techniques for concurrent systems make a distinction
between communication ports and the parameters sent or received on these
ports. <P>
Implementation note: If the transition system generated from the
source program has only a single state and no transition, there are no
labels at all. In such case, the C program <CODE>spec.c</CODE> generated by the compiler
tool shall nevertheless provide an implementation for all types, functions,
and procedures defined in this section and related to labels. Such an implementation
will not be used (since there are no labels) but it is needed to ensure
that everything compiles properly. The implementation details are left undefined:
any implementation that complies with the requirements stated below, is
acceptable. <P>
 <HR><BR>
 
<H3><A NAME="sect25" HREF="#sect25"><CODE>CAESAR_TYPE_LABEL</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_ABSTRACT (...) CAESAR_TYPE_LABEL;

</PRE>This type denotes a pointer to the (opaque) representation of labels. It
is given an abstract definition in file <CODE>caesar_graph.h</CODE> and should be redefined
in <CODE>spec.c</CODE>. <P>
Concretely, <CODE>CAESAR_TYPE_LABEL</CODE> should be defined as a pointer to
a structure named <CODE>CAESAR_STRUCT_LABEL</CODE> or, equivalently, a pointer to type
<CODE>CAESAR_BODY_LABEL</CODE> (see above). <P>
 <HR><BR>
 
<H3><A NAME="sect26" HREF="#sect26"><CODE>CAESAR_SIZE_LABEL</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_SIZE_LABEL ()
   { ... }

</PRE>This function returns the label size (in bytes), which is always greater
than 0. <P>
Implementation note: Practically, in <CODE>caesar_graph.h</CODE>, function <CODE>CAESAR_SIZE_LABEL()</CODE>
is defined as follows: <PRE>         #define CAESAR_SIZE_LABEL() CAESAR_HINT_SIZE_LABEL

</PRE>where <CODE>CAESAR_HINT_SIZE_LABEL</CODE> is a variable defined by: <PRE>         extern CAESAR_TYPE_NATURAL CAESAR_HINT_SIZE_LABEL;

</PRE>This variable should be defined, properly initialized, and exported by
<CODE>spec.c</CODE>. It should neither be used nor assigned in any other program than
<CODE>spec.c</CODE>. This variable is only introduced for efficiency reasons, i.e., to avoid
the cost of a function call. <P>
 <HR><BR>
 
<H3><A NAME="sect27" HREF="#sect27"><CODE>CAESAR_HASH_SIZE_LABEL</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_HASH_SIZE_LABEL ()
   { ... }

</PRE>This function returns a number of bytes N such that, for any label pointed
to by a variable <CODE>CAESAR_L</CODE>, one can compute a hash function which takes
into account the value of the following bytes: <CODE>CAESAR_L</CODE> [0], <CODE>CAESAR_L</CODE> [1],
... and <CODE>CAESAR_L</CODE> [N-1]. <P>
Note: It is always true that: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> 0 &lt; <CODE>CAESAR_HASH_SIZE_LABEL
()</CODE> &lt;= <CODE>CAESAR_SIZE_LABEL ()</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>but it is possible that: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_HASH_SIZE_LABEL
()</CODE> &lt; <CODE>CAESAR_SIZE_LABEL ()</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>especially if the label vector contains variables
of pointer types. By using this function, users can write their own hash
functions. <P>
Implementation note: Practically, in <CODE>caesar_graph.h</CODE>, function
<CODE>CAESAR_HASH_SIZE_LABEL()</CODE> is defined as follows: <PRE>         #define CAESAR_HASH_SIZE_LABEL() CAESAR_HINT_HASH_SIZE_LABEL

</PRE>where <CODE>CAESAR_HINT_HASH_SIZE_LABEL</CODE> is a variable defined by: <PRE>         extern CAESAR_TYPE_NATURAL CAESAR_HINT_HASH_SIZE_LABEL;

</PRE>This variable should be defined, properly initialized, and exported by
<CODE>spec.c</CODE>. It should neither be used nor assigned in any other program than
<CODE>spec.c</CODE>. This variable is only introduced for efficiency reasons, i.e., to avoid
the cost of a function call. <P>
 <HR><BR>
 
<H3><A NAME="sect28" HREF="#sect28"><CODE>CAESAR_ALIGNMENT_LABEL</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_ALIGNMENT_LABEL ()
   { ... }

</PRE>This function returns the alignment factor (in bytes) for labels. The alignment
factor is always a power of two, usually 1, 2, 4, or 8. Any byte string
representing a label must be aligned on a boundary that is an even multiple
of the alignment factor. <P>
Implementation note: Practically, in <CODE>caesar_graph.h</CODE>,
function <CODE>CAESAR_ALIGNMENT_LABEL()</CODE> is defined as follows: <PRE>         #define CAESAR_ALIGNMENT_LABEL() CAESAR_HINT_ALIGNMENT_LABEL

</PRE>where <CODE>CAESAR_HINT_ALIGNMENT_LABEL</CODE> is a variable defined by: <PRE>         extern CAESAR_TYPE_NATURAL CAESAR_HINT_ALIGNMENT_LABEL;

</PRE>This variable should be defined, properly initialized, and exported by
<CODE>spec.c</CODE>. It should neither be used nor assigned in any other program than
<CODE>spec.c</CODE>. This variable is only introduced for efficiency reasons, i.e., to avoid
the cost of a function call. <P>
 <HR><BR>
 
<H3><A NAME="sect29" HREF="#sect29"><CODE>CAESAR_CREATE_LABEL</CODE></A></H3>
<PRE>void CAESAR_CREATE_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL *CAESAR_L;
   { ... }

</PRE>This procedure allocates a byte string of length <CODE>CAESAR_SIZE_LABEL()</CODE> using
<CODE>CAESAR_CREATE()</CODE> and assigns its address to <CODE>*CAESAR_L</CODE>. If the allocation
fails, the <CODE>NULL</CODE> value is assigned to <CODE>*CAESAR_L</CODE>. <P>
Note: because <CODE>CAESAR_TYPE_LABEL</CODE>
is a pointer type, any variable <CODE>CAESAR_L</CODE> of type <CODE>CAESAR_TYPE_LABEL</CODE> must
be allocated before used, for instance using: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_CREATE_LABEL (&amp;CAESAR_L);</CODE>
</TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>However, it is not necessary to use <CODE>CAESAR_CREATE_LABEL</CODE> to perform the
allocation. Instead, users can allocate labels into their own data structures
(tables, lists, ...) <P>
Implementation note: It is not necessary to define <CODE>CAESAR_CREATE_LABEL()</CODE>
in <CODE>spec.c</CODE> because <CODE>caesar_graph.h</CODE> already implements this procedure using
a macro-definition. <P>
 <HR><BR>
 
<H3><A NAME="sect30" HREF="#sect30"><CODE>CAESAR_DELETE_LABEL</CODE></A></H3>
<PRE>void CAESAR_DELETE_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL *CAESAR_L;
   { ... }

</PRE>This procedure frees the byte string of length <CODE>CAESAR_SIZE_LABEL()</CODE> pointed
to by <CODE>*CAESAR_L</CODE> using <CODE>CAESAR_DELETE()</CODE>. Afterwards, the <CODE>NULL</CODE> value is assigned
to <CODE>*CAESAR_L</CODE>. <P>
Implementation note: It is not necessary to define <CODE>CAESAR_DELETE_LABEL()</CODE>
in <CODE>spec.c</CODE> because <CODE>caesar_graph.h</CODE> already implements this procedure using
a macro-definition. <P>
 <HR><BR>
 
<H3><A NAME="sect31" HREF="#sect31"><CODE>CAESAR_VISIBLE_LABEL</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_VISIBLE_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }

</PRE>This function returns a value different from 0 if the label pointed to
by <CODE>CAESAR_L</CODE> is visible, or 0 if it is not visible (i.e., ``tau''). <P>
 <HR><BR>
 
<H3><A NAME="sect32" HREF="#sect32"><CODE>CAESAR_GATE_LABEL</CODE></A></H3>
<PRE>CAESAR_TYPE_STRING CAESAR_GATE_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }

</PRE>This function returns a pointer to a character string containing the name
of the gate associated with the label pointed to by <CODE>CAESAR_L</CODE>. If this label
is not visible (i.e., ``tau''), a pointer to the constant string <CODE>i</CODE> is returned.
<P>
Note: in order to determine if the gate of the label pointed to by <CODE>CAESAR_L</CODE>
is not ``tau'', using: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_VISIBLE_LABEL (CAESAR_L)</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>is more efficient
than performing a string comparison: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>strcmp (CAESAR_GATE_LABEL (CAESAR_L),
"i") != 0</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
Note: It is not allowed to modify the character string returned
by <CODE>CAESAR_GATE_LABEL()</CODE> nor to free it, for instance using <CODE>free(3)</CODE>. <P>
Note:
The contents of the character string returned by <CODE>CAESAR_GATE_LABEL()</CODE> may
be destroyed by a subsequent call to this function. <P>
 <HR><BR>
 
<H3><A NAME="sect33" HREF="#sect33"><CODE>CAESAR_CARDINAL_LABEL</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_CARDINAL_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }

</PRE>This function returns the number of experiment offers associated with the
label pointed to by <CODE>CAESAR_L</CODE>. The gate itself does not count. <P>
 <HR><BR>
 
<H3><A NAME="sect34" HREF="#sect34"><CODE>CAESAR_COPY_LABEL</CODE></A></H3>
<PRE>void CAESAR_COPY_LABEL (CAESAR_L1, CAESAR_L2)
   CAESAR_TYPE_LABEL CAESAR_L1;
   CAESAR_TYPE_LABEL CAESAR_L2;
   { ... }

</PRE>This procedure copies the label pointed to by <CODE>CAESAR_L2</CODE> onto the label
pointed to by <CODE>CAESAR_L1</CODE>. <P>
Note: Parameter <CODE>CAESAR_L2</CODE> must point to a memory
location allocated before procedure <CODE>CAESAR_COPY_LABEL()</CODE> is invoked. <P>
Implementation
note: It is not necessary to define <CODE>CAESAR_COPY_LABEL()</CODE> in <CODE>spec.c</CODE> because
<CODE>caesar_graph.h</CODE> already implements this procedure using a macro-definition.
<P>
 <HR><BR>
 
<H3><A NAME="sect35" HREF="#sect35"><CODE>CAESAR_COMPARE_LABEL</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_COMPARE_LABEL (CAESAR_L1, CAESAR_L2)
   CAESAR_TYPE_LABEL CAESAR_L1;
   CAESAR_TYPE_LABEL CAESAR_L2;
   { ... }

</PRE>This function returns a value different from 0 if both labels pointed to
by <CODE>CAESAR_L1</CODE> and <CODE>CAESAR_L2</CODE> are identical, or 0 if they are not. <P>
 <HR><BR>
 
<H3><A NAME="sect36" HREF="#sect36"><CODE>CAESAR_HASH_LABEL</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_HASH_LABEL (CAESAR_L, CAESAR_MODULUS)
   CAESAR_TYPE_LABEL CAESAR_L;
   CAESAR_TYPE_NATURAL CAESAR_MODULUS;
   { ... }

</PRE>This function computes a hash-code value for the label pointed to by <CODE>CAESAR_L</CODE>
and returns this value, which must be in the range 0..<CODE>CAESAR_MODULUS</CODE>-1. <P>
 <HR><BR>
 
<H3><A NAME="sect37" HREF="#sect37"><CODE>CAESAR_PRINT_LABEL</CODE></A></H3>
<PRE>void CAESAR_PRINT_LABEL (CAESAR_FILE, CAESAR_L)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }

</PRE>This procedure prints to file <CODE>CAESAR_FILE</CODE> a character string describing
the contents of the label pointed to by <CODE>CAESAR_L</CODE>. This string should not
contain the special characters new-line (``\<CODE>n</CODE>'') or carriage-return (``\<CODE>r</CODE>''). If the
label is not visible, the string printed is <CODE>i</CODE>. <P>
Before this procedure is
called, <CODE>CAESAR_FILE</CODE> must have been properly opened, for instance using
<CODE>fopen(3)</CODE>. <P>
 <HR><BR>
 
<H3><A NAME="sect38" HREF="#sect38"><CODE>CAESAR_STRING_LABEL</CODE></A></H3>
<PRE>CAESAR_TYPE_STRING CAESAR_STRING_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }

</PRE>This function returns a pointer to a character string (terminated by the
<CODE>`</CODE>\<CODE>0'</CODE> character) describing the contents of the label pointed to by <CODE>CAESAR_L</CODE>.
This string should not contain the special characters new-line (``\<CODE>n</CODE>'') or carriage-return
(``\<CODE>r</CODE>''). If the label is not visible, the string returned is <CODE>i</CODE>. <P>
Note: It is not
allowed to modify the character string returned by <CODE>CAESAR_STRING_LABEL()</CODE>
nor to free it, for instance using <CODE>free(3)</CODE>. <P>
Note: The contents of the character
string returned by <CODE>CAESAR_STRING_LABEL()</CODE> may be destroyed by a subsequent
call to this function. <P>
 <HR><BR>
 
<H3><A NAME="sect39" HREF="#sect39"><CODE>CAESAR_FORMAT_LABEL</CODE></A></H3>
<PRE>void CAESAR_FORMAT_LABEL (CAESAR_FORMAT)
   CAESAR_TYPE_FORMAT CAESAR_FORMAT;
   { ... }

</PRE>This procedure allows to control the format under which the information
attached to labels is displayed by the procedure <CODE>CAESAR_INFORMATION_LABEL()</CODE>
(see below). <P>
<I>CAESAR</I>-specific note: 3 different label formats (numbered from
0 to 2) are available. <P>
By default, the current label format is initialized
to 0. <P>
When called with <CODE>CAESAR_FORMAT</CODE> between 0 and the maximal format value
supported, this fonction sets the current label format to <CODE>CAESAR_FORMAT</CODE>
and returns an undefined result. <P>
When called with another value of <CODE>CAESAR_FORMAT</CODE>,
this function does not modify the current label format but returns a result
defined as follows. If <CODE>CAESAR_FORMAT</CODE> is equal to the constant <CODE>CAESAR_CURRENT_FORMAT</CODE>,
the result is the value of the current label format. If <CODE>CAESAR_FORMAT</CODE> is
equal to the constant <CODE>CAESAR_MAXIMAL_FORMAT</CODE>, the result is the maximal
format value (e.g., 2 in the case of <I>CAESAR</I>). In all other cases, the effect
of this function is undefined. <P>
 <HR><BR>
 
<H3><A NAME="sect40" HREF="#sect40"><CODE>CAESAR_MAX_FORMAT_LABEL</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_MAX_FORMAT_LABEL ()
   { ... }

</PRE>Caution! This function is deprecated. It should no longer be used, as it
might be removed from future versions of the <I>OPEN/CAESAR</I>. Use function <CODE>CAESAR_FORMAT_LABEL()</CODE>
instead, called with argument <CODE>CAESAR_MAXIMAL_FORMAT</CODE>. <P>
This function returns
the highest format available for label printing, i.e., the highest acceptable
value for the parameter <CODE>CAESAR_FORMAT</CODE> of function <CODE>CAESAR_FORMAT_LABEL()</CODE>.
<P>
 <HR><BR>
 
<H3><A NAME="sect41" HREF="#sect41"><CODE>CAESAR_INFORMATION_LABEL</CODE></A></H3>
<PRE>CAESAR_TYPE_STRING CAESAR_INFORMATION_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }

</PRE>This function returns a character string containing additional information
about the label pointed to by <CODE>CAESAR_L</CODE>. The nature of the information is
determined by the current label format (see procedure <CODE>CAESAR_FORMAT_LABEL()</CODE>
above). If the current label format is null, this function returns the empty
string ``''. <P>
Note: It is not allowed to modify the character string returned
by <CODE>CAESAR_INFORMATION_LABEL()</CODE> nor to free it, for instance using <CODE>free(3)</CODE>.
<P>
Note: The contents of the character string returned by <CODE>CAESAR_INFORMATION_LABEL()</CODE>
may be destroyed by a subsequent call to this function. <P>
<I>CAESAR</I>-specific note:
Currently, the following formats are available: <P>

<UL>
<LI type=disc>If the current label format
is 0: the empty string ``'' is returned. </LI><P><LI type=disc>If the current label format is 1: if
the label L pointed to by <CODE>CAESAR_L</CODE> is visible, the empty string ``'' is returned;
if L is not visible and derives from some gate G hidden by a <CODE>hide</CODE> instruction,
a character string containing the name of G, its definition file and definition
line is returned; if L is not visible and derives from an <CODE>exit</CODE> statement,
the constant character string <CODE>exit</CODE> is returned; if L is not visible and
derives from an <CODE>i; ...</CODE> statement, the constant character string <CODE>i</CODE> is returned.
</LI><P><LI type=disc>If the current label format is 2: a character string containing the (unique)
number of the Petri Net transition corresponding to the edge whose label
is pointed to by <CODE>CAESAR_L</CODE> is returned. This transition can be found in the
<CODE>.net</CODE> file generated by <I>CAESAR</I> with <CODE>-network</CODE> option. </LI><P>
</UL>
<P>

<H2><A NAME="sect42" HREF="#sect42">Edge Features</A></H2>
<P>
 <HR><BR>
 
<H3><A NAME="sect43" HREF="#sect43"><CODE>CAESAR_START_STATE</CODE></A></H3>
<PRE>void CAESAR_START_STATE (CAESAR_S)
   CAESAR_TYPE_STATE CAESAR_S;
   { ... }

</PRE>This procedure copies into the state pointed to by <CODE>CAESAR_S</CODE> the contents
of the initial state of the labelled transition system. <P>
Note: Parameter
<CODE>CAESAR_S</CODE> must point to a memory location allocated before procedure <CODE>CAESAR_START_STATE()</CODE>
is invoked. <P>
 <HR><BR>
 
<H3><A NAME="sect44" HREF="#sect44"><CODE>CAESAR_ITERATE_STATE</CODE></A></H3>
<PRE>void CAESAR_ITERATE_STATE (CAESAR_S1, CAESAR_L, CAESAR_S2, CAESAR_LOOP)
   CAESAR_TYPE_STATE CAESAR_S1;
   CAESAR_TYPE_LABEL CAESAR_L;
   CAESAR_TYPE_STATE CAESAR_S2;
   void (*CAESAR_LOOP) (CAESAR_TYPE_STATE, CAESAR_TYPE_LABEL,
      CAESAR_TYPE_STATE);
   { ... }

</PRE>This procedure provides an iterator which enumerates all successors of
the state pointed to by <CODE>CAESAR_S1</CODE>. At each iteration, the label pointed
to by <CODE>CAESAR_L</CODE> and the state pointed to by <CODE>CAESAR_S2</CODE> are assigned a new
value, such that ``(<CODE>CAESAR_S1</CODE>, <CODE>CAESAR_L</CODE>, <CODE>CAESAR_S2</CODE>)'' is an edge of the labelled
transition system. At each iteration, the C function pointed to by <CODE>CAESAR_LOOP</CODE>
is invoked, with the following parameters: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>(*CAESAR_LOOP) (CAESAR_S1,
CAESAR_L, CAESAR_S2)</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
<P>
Therefore, any actual parameter supplied for the
formal parameter <CODE>CAESAR_LOOP</CODE> must be a pointer to a function, say <CODE>caesar_f</CODE>,
whose declaration is: <P>
<PRE>        void caesar_f (caesar_s1, caesar_l, caesar_s2)
           CAESAR_TYPE_STATE caesar_s1;
           CAESAR_TYPE_LABEL caesar_l;
           CAESAR_TYPE_STATE caesar_s2;
           {...}

</PRE>Note: Parameters <CODE>CAESAR_S1</CODE>, <CODE>CAESAR_L</CODE>, and <CODE>CAESAR_S2</CODE> must point to (distinct)
memory locations allocated before procedure <CODE>CAESAR_ITERATE_STATE()</CODE> is invoked.
In no event will <CODE>CAESAR_ITERATE_STATE()</CODE> and <CODE>CAESAR_LOOP()</CODE> allocate memory
for storing <CODE>CAESAR_L</CODE> and <CODE>CAESAR_S2</CODE>. <P>
Note: More often than not, this function
will have side-effects. For instance, this function may count the number
of successors, or store them in a list, a table, ... <P>
Note: It is probably
a good programming style to keep the body of this function as short as
possible. <P>
Note: The C code that implements <CODE>CAESAR_ITERATE_STATE()</CODE> in <CODE>spec.c</CODE>
may be not reentrant. In such case, nested iterations will not work properly.
This implies that any actual parameter <CODE>caesar_f</CODE> supplied to formal parameter
<CODE>CAESAR_LOOP</CODE> must not call (directly, nor transitively) <CODE>CAESAR_ITERATE_STATE</CODE>.
Practically, this restriction has no effect on breadth-first explorations.
However, it affects the way of writing depth-first explorations: for a given
state S, it is necessary first to compute all successors of S and to store
them in some data structure, before starting to explore these successors.
<P>
<I>CAESAR</I>-specific note: The C code generated by <I>CAESAR</I> for <CODE>CAESAR_ITERATE_STATE()</CODE>
is not reentrant (at least in the current version). 
<H2><A NAME="sect45" HREF="#sect45">Obsolete Features</A></H2>
<P>
 <HR><BR>
 
<H3><A NAME="sect46" HREF="#sect46"><CODE>CAESAR_DUMP_LABEL</CODE></A></H3>
<PRE>void CAESAR_DUMP_LABEL (CAESAR_STRING, CAESAR_L)
   CAESAR_TYPE_STRING CAESAR_STRING;
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }

</PRE>This procedure has been removed from the ``graph module'' application programming
interface in October 2002 and should no longer be implemented, nor used
in <I>OPEN/CAESAR</I> application programs. <P>
 <HR><BR>
 
<H3><A NAME="sect47" HREF="#sect47"><CODE>CAESAR_RANK_LABEL</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_RANK_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }

</PRE>This function has been removed from the ``graph module'' application programming
interface in October 2002 and should no longer be implemented, nor used
in <I>OPEN/CAESAR</I> application programs. <P>
 <HR><BR>
 
<H2><A NAME="sect48" HREF="#sect48">Author(s)</A></H2>
Hubert Garavel 
<H2><A NAME="sect49" HREF="#sect49">Files</A></H2>
 
<DL><DD><DL COMPACT>

<DT><B>$CADP/incl/caesar_graph.h</B> </DT>
<DD>interface of the
graph module </DD><P>

<DT><B>$CADP/incl/caesar_*.h</B> </DT>
<DD>interfaces of the storage module </DD><P>

<DT><B>$CADP/bin.`arch`/libcaesar.a</B>
</DT>
<DD>object code of the storage module </DD><P>

<DT><B>$CADP/src/open_caesar/*.c</B> </DT>
<DD>source code
of various exploration modules </DD><P>

<DT><B>$CADP/com/lotos.open</B> </DT>
<DD>shell script to run
OPEN/CAESAR  </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect50" HREF="#sect50">See Also</A></H2>
Reference Manuals of OPEN/CAESAR, CAESAR, and CAESAR.ADT,
<A HREF="lotos.open.html"><B>lotos.open</B></A>
, <A HREF="caesar.html"><B>caesar</B></A>
, <A HREF="caesar.adt.html"><B>caesar.adt</B></A>
 <P>
Additional information
is available from the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives
for installation are given in files <B>$CADP/INSTALLATION_*.</B> <P>
Recent changes
and improvements to this software are reported and commented in file <B>$CADP/HISTORY.</B>

<H2><A NAME="sect51" HREF="#sect51">Bugs</A></H2>
Known bugs are described in the Reference Manual of OPEN/CAESAR. Please
report new bugs to <A HREF="mailto:cadp@inria.fr?Subject=CADP-Bug-Report">cadp@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Purpose</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Usage</A></LI>
<LI><A NAME="toc3" HREF="#sect3">General Features</A></LI>
<UL>
<LI><A NAME="toc4" HREF="#sect4">CAESAR_GRAPH_COMPILER</A></LI>
<LI><A NAME="toc5" HREF="#sect5">CAESAR_GRAPH_VERSION</A></LI>
<LI><A NAME="toc6" HREF="#sect6">CAESAR_INIT_GRAPH</A></LI>
</UL>
<LI><A NAME="toc7" HREF="#sect7">State Features</A></LI>
<UL>
<LI><A NAME="toc8" HREF="#sect8">CAESAR_BODY_STATE</A></LI>
<LI><A NAME="toc9" HREF="#sect9">CAESAR_TYPE_STATE</A></LI>
<LI><A NAME="toc10" HREF="#sect10">CAESAR_SIZE_STATE</A></LI>
<LI><A NAME="toc11" HREF="#sect11">CAESAR_HASH_SIZE_STATE</A></LI>
<LI><A NAME="toc12" HREF="#sect12">CAESAR_ALIGNMENT_STATE</A></LI>
<LI><A NAME="toc13" HREF="#sect13">CAESAR_CREATE_STATE</A></LI>
<LI><A NAME="toc14" HREF="#sect14">CAESAR_DELETE_STATE</A></LI>
<LI><A NAME="toc15" HREF="#sect15">CAESAR_COPY_STATE</A></LI>
<LI><A NAME="toc16" HREF="#sect16">CAESAR_COMPARE_STATE</A></LI>
<LI><A NAME="toc17" HREF="#sect17">CAESAR_HASH_STATE</A></LI>
<LI><A NAME="toc18" HREF="#sect18">CAESAR_FORMAT_STATE</A></LI>
<LI><A NAME="toc19" HREF="#sect19">CAESAR_MAX_FORMAT_STATE</A></LI>
<LI><A NAME="toc20" HREF="#sect20">CAESAR_PRINT_STATE_HEADER</A></LI>
<LI><A NAME="toc21" HREF="#sect21">CAESAR_PRINT_STATE</A></LI>
<LI><A NAME="toc22" HREF="#sect22">CAESAR_DELTA_STATE</A></LI>
</UL>
<LI><A NAME="toc23" HREF="#sect23">Label Features</A></LI>
<UL>
<LI><A NAME="toc24" HREF="#sect24">CAESAR_BODY_LABEL</A></LI>
<LI><A NAME="toc25" HREF="#sect25">CAESAR_TYPE_LABEL</A></LI>
<LI><A NAME="toc26" HREF="#sect26">CAESAR_SIZE_LABEL</A></LI>
<LI><A NAME="toc27" HREF="#sect27">CAESAR_HASH_SIZE_LABEL</A></LI>
<LI><A NAME="toc28" HREF="#sect28">CAESAR_ALIGNMENT_LABEL</A></LI>
<LI><A NAME="toc29" HREF="#sect29">CAESAR_CREATE_LABEL</A></LI>
<LI><A NAME="toc30" HREF="#sect30">CAESAR_DELETE_LABEL</A></LI>
<LI><A NAME="toc31" HREF="#sect31">CAESAR_VISIBLE_LABEL</A></LI>
<LI><A NAME="toc32" HREF="#sect32">CAESAR_GATE_LABEL</A></LI>
<LI><A NAME="toc33" HREF="#sect33">CAESAR_CARDINAL_LABEL</A></LI>
<LI><A NAME="toc34" HREF="#sect34">CAESAR_COPY_LABEL</A></LI>
<LI><A NAME="toc35" HREF="#sect35">CAESAR_COMPARE_LABEL</A></LI>
<LI><A NAME="toc36" HREF="#sect36">CAESAR_HASH_LABEL</A></LI>
<LI><A NAME="toc37" HREF="#sect37">CAESAR_PRINT_LABEL</A></LI>
<LI><A NAME="toc38" HREF="#sect38">CAESAR_STRING_LABEL</A></LI>
<LI><A NAME="toc39" HREF="#sect39">CAESAR_FORMAT_LABEL</A></LI>
<LI><A NAME="toc40" HREF="#sect40">CAESAR_MAX_FORMAT_LABEL</A></LI>
<LI><A NAME="toc41" HREF="#sect41">CAESAR_INFORMATION_LABEL</A></LI>
</UL>
<LI><A NAME="toc42" HREF="#sect42">Edge Features</A></LI>
<UL>
<LI><A NAME="toc43" HREF="#sect43">CAESAR_START_STATE</A></LI>
<LI><A NAME="toc44" HREF="#sect44">CAESAR_ITERATE_STATE</A></LI>
</UL>
<LI><A NAME="toc45" HREF="#sect45">Obsolete Features</A></LI>
<UL>
<LI><A NAME="toc46" HREF="#sect46">CAESAR_DUMP_LABEL</A></LI>
<LI><A NAME="toc47" HREF="#sect47">CAESAR_RANK_LABEL</A></LI>
</UL>
<LI><A NAME="toc48" HREF="#sect48">Author(s)</A></LI>
<LI><A NAME="toc49" HREF="#sect49">Files</A></LI>
<LI><A NAME="toc50" HREF="#sect50">See Also</A></LI>
<LI><A NAME="toc51" HREF="#sect51">Bugs</A></LI>
</UL>
</BODY></HTML>
