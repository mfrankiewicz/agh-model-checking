  <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>XTL-LANG manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
xtl - language for value-based temporal logic formulas 
<H2><A NAME="sect1" HREF="#sect1">Description</A></H2>
XTL
(eXecutable Temporal Language) is a functional programming language interpreted
over LTSs (Labelled Transition Systems) encoded in the BCG (Binary Coded
Graph) file format. XTL can typically be used for implementing temporal
logic operators, by describing their fixed point semantics as iterative
or recursive computations over sets of states. More generally, XTL enables
one to perform any computation on a BCG graph: for instance, it can compute
the branching factor of a graph, print its list of labels, etc. XTL programs
are compiled and evaluated on BCG graphs by using the <A HREF="xtl.html"><B>xtl</B></A>
 model
checker. 
<H2><A NAME="sect2" HREF="#sect2">LTS Model</A></H2>
An XTL program is evaluated over an LTS model generated
from a source program to be verified. This LTS, encoded in a BCG file, contains
the following elements: 
<UL>
<LI type=disc>a set of <I>states</I> of the source program. A state is
represented as a tuple containing the values of all the variables of the
program (the so-called "state vector"). </LI><P><LI type=disc>a set of <I>labels</I> performed by the
program. An label is represented  as a list of typed values. In BCG files
generated from LOTOS programs,  the labels have the form <I>G</I> <I>v1</I> ... <I>vm</I> (with
m &gt;= 0), where <I>G</I> is a gate name. </LI><P><LI type=disc>a <I>transition relation</I> between the states
of the program. A transition, represented as a triple (<I>s1</I>, <I>a</I>, <I>s2</I>), means
that the program can move from state <I>s1</I> to state <I>s2</I> by performing a transition
labelled with <I>a</I>. </LI><P><LI type=disc>the <I>initial state</I> of the program. </LI><P>
</UL>

<H2><A NAME="sect3" HREF="#sect3">Syntax and Semantics of
XTL</A></H2>
The syntax of each XTL construct is defined by a BNF grammar and the
semantics is described informally. Terminal symbols are enclosed in double
quotes. Optional elements are enclosed in square brackets. Suspension points
are used to denote zero or more repetitions of an element.  The meaning
of grammar symbols is given in the table below. The axiom of the grammar
is the non-terminal symbol <I>PG</I>.   <PRE>         +--------+-------------------------------+
         | Symbol |          Description          |
         +========+===============================+
         |   K    | constant                      |
         |   x    | variable                      |
         |   T    | simple type                   |
         |   G    | gate                          |
         |   F    | function                      |
         |   M    | macro                         |
         |   P    | macro parameter               |
         |   E    | expression                    |
         |   O    | offer                         |
         |   D    | variable declaration          |
         |   RT   | result type                   |
         |   OP   | operator                      |
         |   FD   | function definition           |
         |   MD   | macro definition              |
         |   LI   | library inclusion             |
         |   ETD  | external type declaration     |
         |   EFD  | external function declaration |
         |   EID  | external include directive    |
         |   ELD  | external compile directive    |
         |   PG   | program                       |
         +--------+-------------------------------+
</PRE>  <P>

<H3><A NAME="sect4" HREF="#sect4">Lexical Elements</A></H3>
The lexical units of XTL are: <I>keywords</I>, <I>identifiers</I> and
<I>separators</I>. The keywords, listed below, must be written in lower-case letters.
<P>
<CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT><CODE>any</CODE></TD><TD ALIGN=LEFT><CODE>end_def</CODE></TD><TD ALIGN=LEFT><CODE>exists</CODE></TD><TD ALIGN=LEFT><CODE>of</CODE></TD></TR>
<TR><TD ALIGN=LEFT><CODE>apply</CODE></TD><TD ALIGN=LEFT><CODE>end_exists</CODE></TD><TD ALIGN=LEFT><CODE>for</CODE></TD><TD ALIGN=LEFT><CODE>on</CODE></TD></TR>
<TR><TD ALIGN=LEFT><CODE>assert</CODE></TD><TD ALIGN=LEFT><CODE>end_for</CODE></TD><TD ALIGN=LEFT><CODE>forall</CODE></TD><TD ALIGN=LEFT><CODE>then</CODE></TD></TR>
<TR><TD ALIGN=LEFT><CODE>def</CODE></TD><TD ALIGN=LEFT><CODE>end_forall</CODE></TD><TD ALIGN=LEFT><CODE>from</CODE></TD><TD ALIGN=LEFT><CODE>to</CODE></TD></TR>
<TR><TD ALIGN=LEFT><CODE>else</CODE></TD><TD ALIGN=LEFT><CODE>end_if</CODE></TD><TD ALIGN=LEFT><CODE>if</CODE></TD><TD ALIGN=LEFT><CODE>use</CODE></TD></TR>
<TR><TD ALIGN=LEFT><CODE>else_if</CODE></TD><TD ALIGN=LEFT><CODE>end_let</CODE></TD><TD ALIGN=LEFT><CODE>in</CODE></TD><TD ALIGN=LEFT><CODE>where</CODE></TD></TR>
<TR><TD ALIGN=LEFT><CODE>end_assert</CODE></TD><TD ALIGN=LEFT><CODE>end_use</CODE></TD><TD ALIGN=LEFT><CODE>let</CODE></TD></TR>
</TABLE>
</CENTER><P>
The
identifiers are grouped into two classes: 
<UL>
<LI type=disc><I>external identifiers</I> denote the
objects defined in the source program to be verified (these objects are
contained in the BCG file). These identifiers may be written like the internal
ones, as long as there is no clash between them and the normal identifiers
or the XTL keywords. In the latter case, external identifiers must be preceded
by a dollar character (e.g., <CODE>$let</CODE>) to avoid clashes. </LI><P><LI type=disc><I>internal identifiers</I>
denote the objects defined in the XTL program (or predefined in the XTL
language). These identifiers may be either <I>normal</I>, i.e., built from letters,
digits and underscores (beginning with a letter or an underscore), or <I>special</I>,
i.e., built from the characters #, %, &amp;, *, +, -, ., /, &gt;, =, &lt;, @, \, ^, and ~.
In normal identifiers, no difference is made between lower- and uppercase
letters. The special identifiers are useful for mathematical and/or logical
notations (e.g., '+', '/\', etc.). </LI><P>
</UL>
<P>
The separators are sequences containing space,
tab, and newline characters, as well as <I>comments</I>, enclosed between <CODE>(*</CODE> and
<CODE>*)</CODE>.  
<H3><A NAME="sect5" HREF="#sect5">Internal and External Types</A></H3>
XTL is a strongly-typed language: every object
used in an XTL program must have a unique type, which is statically determined.
XTL does not provide a mechanism for type definition, although anonymous
tuple types (see below) can be implicitly created. The types allowed in
XTL fall into the following classes: 
<UL>
<LI type=disc><I>external types</I> are imported from the
source program to be verified. These types are contained in the type area
of the BCG file and can be referenced in XTL programs using external identifiers.
Other externally defined types can be included in the XTL programs by means
of special directives (see DIRECTIVES below). </LI><P><LI type=disc><I>internal types</I> are either
predefined in the language, or defined by the user.  </LI><P>
</UL>

<H3><A NAME="sect6" HREF="#sect6">Internal and External
Functions</A></H3>
The functions (also called <I>operators</I>) that can be used in an XTL
program fall into the following classes: 
<UL>
<LI type=disc><I>external functions</I> are defined
in the source program to be verified. They are contained in the function
area of the BCG file and can be referenced in XTL programs using external
identifiers. </LI><P><LI type=disc><I>internal functions</I> are either predefined in XTL (a list of
the predefined functions has been given in the above paragraphs), or user-defined
(see FUNCTIONS below for the syntax of function definitions). </LI><P>
</UL>
<P>
In XTL, functions
can be <I>overloaded</I>, i.e., have the same identifier but different types for
their arguments and/or result. The XTL compiler resolves overloading statically
(i.e., at compile-time) or issues an error message if the context does not
permit to resolve overloading (in such case, the "<CODE>of</CODE>" operator can be used
to supply typing information). <P>
In XTL, a function <I>F</I> can be either <I>prefixed</I>,
i.e., its calls are written "<I>F</I> (<I>E1</I>, ..., <I>En</I>)", or <I>infixed</I>, i.e., <I>F</I> has two arguments
and its calls are written "<I>E1</I> <I>F</I> <I>E2</I>".  <P>
Most predefined functions are infixed,
except "<CODE>extract</CODE>" and  "<CODE>replace</CODE>". For user-defined functions, the prefix or
infix nature is specified when the function is declared. <P>
Also, unary minus
operators must be written in functional notation,  i.e., <CODE>-(1)</CODE> instead of <CODE>-1</CODE>,
<CODE>-(X)</CODE> instead of <CODE>-X</CODE>, etc. 
<H3><A NAME="sect7" HREF="#sect7">Boolean Type and Functions</A></H3>
The Boolean type is named
<CODE>boolean</CODE>. The Boolean constants <CODE>true</CODE> and <CODE>false</CODE> are defined as 0-ary  functions.
The table below gives the predefined functions for this type:   <PRE>+----------------------------------------+--------------------------+
|                Operator                |         Meaning          |
+========================================+==========================+
| true, false : -&gt; boolean               | boolean constants        |
| not : boolean -&gt; boolean               | negation                 |
| or, and, implies,                      | connectors and           |
|   =, &lt;&gt; : boolean, boolean -&gt; boolean  |   relational operators   |
| replace : boolean, boolean -&gt; boolean  | replacement operator     |
+----------------------------------------+--------------------------+
</PRE> The "<CODE>replace</CODE>" operator (which is overloaded for all types) takes  two
arguments of the same type and returns the second one. It is useful  for
use within the "<CODE>for</CODE>" expressions (see EXPRESSIONS below). 
<H3><A NAME="sect8" HREF="#sect8">Integer Type and
Functions</A></H3>
The signed integer type is named <CODE>integer</CODE>. Integer constants are
noted with a C-like syntax and should be preceded of a sign "<CODE>+</CODE>" or "<CODE>-</CODE>", e.g.,
<CODE>-123</CODE>, <CODE>+123</CODE>, <CODE>+0</CODE>, etc. The table below gives the predefined functions for this
type:   <PRE>+----------------------------------------+--------------------------+
|                Operator                |         Meaning          |
+========================================+==========================+
| -, +    : integer, integer -&gt; integer  | binary minus, plus       |
| -       : integer -&gt; integer           | unary minus              |
| *, div  : integer, integer -&gt; integer  | multiplication, division |
| mod     : integer, integer -&gt; integer  | modulo                   |
| **      : integer, integer -&gt; integer  | power                    |
| integer : real -&gt; integer              | real to integer          |
| integer : character -&gt; integer         | character to integer     |
| &lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt; :                  | relational operators     |
|     integer, integer -&gt; boolean        |                          |
| replace : integer, integer -&gt; integer  | replacement operator     |
+----------------------------------------+--------------------------+
</PRE> 
<H3><A NAME="sect9" HREF="#sect9">Natural Type and Functions</A></H3>
The unsigned integer type is named <CODE>natural</CODE>. Natural
constants are noted with a C-like syntax and should never be preceded of
a sign, e.g., <CODE>123</CODE>, <CODE>0</CODE>, etc. The table below gives the predefined functions
for this type:   <PRE>+----------------------------------------+--------------------------+
|                Operator                |         Meaning          |
+========================================+==========================+
| -, +    : natural, natural -&gt; natural  | binary minus, plus       |
| *, div  : natural, natural -&gt; natural  | multiplication, division |
| mod     : natural, natural -&gt; natural  | modulo                   |
| **      : natural, natural -&gt; natural  | power                    |
| natural : real -&gt; natural              | real to integer          |
| natural : character -&gt; natural         | character to natural     |
| &lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt; :                  | relational operators     |
|     natural, natural -&gt; boolean        |                          |
| replace : natural, natural -&gt; natural  | replacement operator     |
+----------------------------------------+--------------------------+
</PRE> <P>
By default, an unsigned number <CODE>123</CODE> denotes either a value of type <CODE>natural</CODE>
or a value of type <CODE>integer</CODE>. Such overloading can be resolved explicitly
by the user (using an "<CODE>of</CODE>" operator) or implicitly by the context (for
instance, in <CODE>(X + 123)</CODE>, the type of <CODE>X</CODE> will determine the type of <CODE>123</CODE>). If
the context does not permit to resolve overloading, then the constant will
ultimately be given the type Natural. To summarize: <BR>
- <CODE>+123</CODE> has the <CODE>integer</CODE> type. <BR>
- <CODE>-123</CODE> has the <CODE>integer</CODE> type. <BR>
- <CODE>123 of integer</CODE> has the <CODE>integer</CODE> type. <BR>
- <CODE>123 of natural</CODE> has the <CODE>natural</CODE> type. <BR>
- <CODE>123</CODE> has either the <CODE>natural</CODE> or <CODE>integer</CODE> type (with a final priority for
<CODE>natural</CODE>). 
<H3><A NAME="sect10" HREF="#sect10">Real Type and Functions</A></H3>
The floating-point number type is named
<CODE>real</CODE>. Real constants are noted with a C-like syntax, e.g., <CODE>3.1416</CODE>, <CODE>-9.98E-6</CODE>, etc.
The table below gives the predefined functions for this type:  <PRE>+----------------------------------------+--------------------------+
|                Operator                |         Meaning          |
+========================================+==========================+
| -, + : real, real -&gt; real              | binary minus, plus       |
| -    : real -&gt; real                    | unary minus              |
| *, / : real, real -&gt; real              | multiplication, division |
| **   : real, real -&gt; real              | power                    |
| real : integer -&gt; real                 | integer to real          |
| &lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt; :                  | relational operators     |
|     real, real -&gt; boolean              |                          |
| replace : real, real -&gt; real           | replacement operator     |
+----------------------------------------+--------------------------+
</PRE> 
<H3><A NAME="sect11" HREF="#sect11">Character Type and Functions</A></H3>
The character type is named <CODE>character</CODE>. Character
constants are noted with a C-like syntax,  e.g., <CODE>'a'</CODE>, <CODE>'\n'</CODE>, <CODE>'\012'</CODE>, <CODE>'\x1A'</CODE>, etc. The table
below gives the predefined functions for this type:  <PRE>+----------------------------------------+--------------------------+
|                Operator                |         Meaning          |
+========================================+==========================+
| -, + : character, integer -&gt; character | subtract, add integer    |
| character : integer -&gt; character       | integer to character     |
| &lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt; :                  | relational operators     |
|     character, character -&gt; boolean    |                          |
| replace :                              |                          |
|     character, character -&gt; character  | replacement operator     |
+----------------------------------------+--------------------------+
</PRE> 
<H3><A NAME="sect12" HREF="#sect12">String Type and Functions</A></H3>
The character-string type is named <CODE>string</CODE>. String
constants are noted with a C-like syntax, e.g., <CODE>"abc"</CODE>, <CODE>"123"</CODE>, <CODE>"Hello\n"</CODE>, etc.
The table below gives the predefined functions for this type:   <PRE>+----------------------------------------+--------------------------+
|                Operator                |         Meaning          |
+========================================+==========================+
| null    : -&gt; string                    | empty string             |
| length  : string -&gt; integer            | string length            |
| extract : string, integer -&gt; character | character extraction     |
| =, &lt;&gt;   : string, string -&gt; boolean    | relational operators     |
| replace : string, string -&gt; string     | replacement operator     |
+----------------------------------------+--------------------------+
</PRE> 
<H3><A NAME="sect13" HREF="#sect13">Raw Type and Functions</A></H3>
The <CODE>raw</CODE> type represents a byte string that denotes
a value of  unknown type, i.e., whose type is not one of the other predefined
types. Raw constants are noted with a C-like syntax but using backquotes
rather than double quotes, e.g., <CODE>`foo`</CODE>, <CODE>`CONS (0, NIL)`</CODE>, or <CODE>`{0, 1}`</CODE>, etc. The table
below gives the predefined functions for this type:  <PRE>+----------------------------------------+--------------------------+
|                Operator                |         Meaning          |
+========================================+==========================+
| null    : -&gt; raw                       | empty raw data           |
| length  : raw -&gt; integer               | raw data length          |
| extract : raw, integer -&gt; character    | character extraction     |
| =, &lt;&gt;   : raw, raw -&gt; boolean          | relational operators     |
| replace : raw, raw -&gt; raw              | replacement operator     |
+----------------------------------------+--------------------------+
</PRE> <P>
By default, the string notation <CODE>"..."</CODE> denotes either a value of type <CODE>string</CODE>
or a value of type <CODE>raw</CODE>. Such overloading can be resolved explicitly by the
user (using an "<CODE>of</CODE>" operator) or  implicitly by the context (for instance,
in <CODE>(X = "foo")</CODE>, the type of <CODE>X</CODE> will determine the type of <CODE>"abc"</CODE>). If the
context does not permit to resolve overloading, then the constant will
ultimately be given the type String. To summarize: <BR>
- <CODE>`foo`</CODE> has the <CODE>raw</CODE> type. <BR>
- <CODE>"foo" of string</CODE> has the <CODE>string</CODE> type. <BR>
- <CODE>"foo" of raw</CODE> has the <CODE>raw</CODE> type. <BR>
- <CODE>"foo"</CODE> has either the <CODE>string</CODE> or <CODE>raw</CODE> type (with a final priority for <CODE>string</CODE>).

<H3><A NAME="sect14" HREF="#sect14">Meta-types and Functions</A></H3>
The types <CODE>state</CODE>, <CODE>label</CODE>, <CODE>edge</CODE>, <CODE>stateset</CODE>, <CODE>labelset</CODE>,
and <CODE>edgeset</CODE> (also called <I>meta-types</I> because they refer to the LTS model
rather than to the objects defined in the source program to be verified)
denote the states, labels, edges, sets of states, sets of labels, and sets
of edges of the LTS, respectively. <P>
The table below gives the predefined
operators over these types ("<CODE>set</CODE>" denoting either <CODE>stateset</CODE>, <CODE>labelset</CODE>, or
<CODE>edgeset</CODE>). These operators allow to explore (forward and/or backward) the
transition relation of the LTS, to combine sets of states, labels and edges,
and also to obtain information about the LTS.  <PRE>+-----------------------------------+-------------------------+
|             Operator              |         Meaning         |
+===================================+=========================+
| init   : -&gt; state                 | initial state           |
| succ   : state -&gt; stateset        | successor states        |
| pred   : state -&gt; stateset        | predecessor states      |
| out    : state -&gt; edgeset         | successor transitions   |
| in     : state -&gt; edgeset         | predecessor transitions |
| =, &lt;&gt;  : state, state -&gt; boolean  | comparison operators    |
| replace : state, state -&gt; state   | replacement operator    |
+-----------------------------------+-------------------------+
| visible : label -&gt; boolean        | visibility test         |
| string  : label -&gt; string         | label to string         |
| =, &lt;&gt;   : label, label -&gt; boolean | comparison operators    |
| replace : label, label -&gt; label   | replacement operator    |
+-----------------------------------+-------------------------+
| source : edge -&gt; state            | transition source state |
| target : edge -&gt; state            | transition target state |
| label  : edge -&gt; label            | transition label        |
| succ   : edge -&gt; edgeset          | successor transitions   |
| pred   : edge -&gt; edgeset          | predecessor transitions |
| =, &lt;&gt;  : edge, edge -&gt; boolean    | comparison operators    |
| replace : edge, edge -&gt; edge      | replacement operator    |
+-----------------------------------+-------------------------+
| empty, false : -&gt; set             | empty set               |
| full, true   : -&gt; set             | full set                |
| comp, not  : set -&gt; set           | complementation         |
| union, or  : set, set -&gt; set      | union                   |
| inter, and : set, set -&gt; set      | intersection            |
| implies    : set, set -&gt; set      | implication             |
| iff        : set, set -&gt; set      | equivalence             |
| diff       : set, set -&gt; set      | difference              |
| includes   : set, set -&gt; boolean  | inclusion test          |
| insert, remove : set, elem -&gt; set | insertion, removal      |
| among : elem, set -&gt; boolean      | membership              |
| card  : set -&gt; number             | cardinal                |
| =, &lt;&gt; : set, set -&gt; boolean       | comparison operators    |
| replace : set, set -&gt; set         | replacement operator    |
+-----------------------------------+-------------------------+
</PRE> For convenience, some of the operators above are overloaded (see FUNCTIONS
below). Also, some of the set operators have synonyms (e.g., <CODE>union</CODE> has the
synonym <CODE>or</CODE>) allowing a more intuitive writing of boolean properties.  
<H3><A NAME="sect15" HREF="#sect15">Number
Type and Functions</A></H3>
The BCG file format associates a unique number to every
state, label, and edge of the LTS. The XTL language provides the <CODE>number</CODE>
type for the manipulation of state, label, and edge numbers. The table below
gives the predefined operators of type <CODE>number</CODE>.  <PRE>+------------------------------------+--------------------------+
|             Operator               |       Meaning            |
+====================================+==========================+
| number_of_states : -&gt; number       | number of states         |
| number_of_labels : -&gt; number       | number of labels         |
| number_of_edges  : -&gt; number       | number of edges          |
| number : state -&gt; number           | state number             |
| number : label -&gt; number           | label number             |
| number : edge -&gt; number            | edge number              |
+------------------------------------+--------------------------+
| -, +   : number, number -&gt; number  | binary minus, plus       |
| *, div : number, number -&gt; number  | multiplication, division |
| mod    : number, number -&gt; number  | modulo                   |
| **     : number, number -&gt; number  | power                    |
| number : character -&gt; number       | conversion from/to       |
| character : number -&gt; character    |   character              |
| number : integer -&gt; number         | conversion from/to       |
| integer : number -&gt; integer        |   integer                |
| number : real -&gt; number            | conversion from/to       |
| real : number -&gt; real              |   real                   |
| &lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt; :              | relational operators     |
|     number, number -&gt; boolean      |                          |
| replace : number, number -&gt; number | replacement operator     |
+------------------------------------+--------------------------+
</PRE> All arithmetic operators (except unary minus) and relational operators
of type <CODE>integer</CODE> are also available for type <CODE>number</CODE>. Moreover, the values
belonging to these two types can be freely mixed within arithmetic and
relational expressions. The main difference between these two types concerns
the manipulation of large numbers: the maximum value of type <CODE>integer</CODE> is
<CODE>2^31-1</CODE> = <CODE>2,147,483,647</CODE> on 32-bit machines and <CODE>2^63-1</CODE> = <CODE>9,223,372,036,854,775,807</CODE>
on 64-bit machines, whereas the maximum value of type <CODE>number</CODE> is <CODE>2^32-1</CODE> = <CODE>4,294,967,295</CODE>
on 32-bit machines and <CODE>2^64-1</CODE> = <CODE>18,446,744,073,709,551,615</CODE> on 64-bit machines.
Therefore, for large LTSs, any information concerning the LTS structure
(e.g., cardinality of state/edge/label subsets, depth/breadth of the LTS,
number of breadth-first levels, etc.) should be manipulated using values
of type <CODE>number</CODE> instead of type <CODE>integer</CODE> in order to avoid overflows. <P>
Conversion
operators between the <CODE>number</CODE> type and the types <CODE>character</CODE>, <CODE>integer</CODE>, and
<CODE>real</CODE> are also provided. Constants of type <CODE>number</CODE> are written in decimal
notation preceded by a <CODE>'#'</CODE> character (e.g., <CODE>#4294967295</CODE>). An alternative way
of representing constants of type <CODE>number</CODE> that fit in the range of type
<CODE>integer</CODE> is by means of the conversion operator from <CODE>integer</CODE> to <CODE>number</CODE> (e.g.,
the values <CODE>number(2147483647)</CODE> and <CODE>#2147483647</CODE> are the same). 
<H3><A NAME="sect16" HREF="#sect16">Action Type
and Functions</A></H3>
The XTL language has an action type associated to XTL expressions
that return no value but perform side effects. These are used to print data
values on the POSIX standard output stream (<B>stdout</B>). The table below gives
the predefined operators of type <CODE>action</CODE> (T may be any type). <P>
The <CODE>print</CODE> and
<CODE>printf</CODE> operators behave differently on strings: <CODE>print</CODE> prints the string
enclosed between double quotes and  converts unprintable characters and
escape sequences to three-digit  octal notation, whereas <CODE>printf</CODE> does not
add double quotes and interprets execute sequences. For instance, <CODE>print
("Hello!\n")</CODE> displays <CODE>"Hello!\012"</CODE>, whereas <CODE>printf ("Hello!\n")</CODE> displays <CODE>Hello!</CODE>
followed by a line-feed. So, <CODE>print</CODE> should be used to display string values
(e.g., label offers of the string type), whereas <CODE>printf</CODE> should be used to
display messages.  <PRE>+--------------------------------+---------------------------+
|            Operator            |        Meaning            |
+================================+===========================+
| nop : -&gt; action                | inaction                  |
| fby : action, action -&gt; action | sequential composition    |
| print : T -&gt; action            | value printing            |
| printf : string -&gt; action      | string formatted printing |
+--------------------------------+---------------------------+
</PRE> 
<H3><A NAME="sect17" HREF="#sect17">Anonymous Tuple Types</A></H3>
These types denote structures containing fields of
different types. The fields can be of any type (including anonymous tuples,
which enables nesting of tuples).  These types are noted "(" <I>T0</I>"," ..."," <I>Tn</I>
")" and are essentially used in situations when several values must be
computed and returned simultaneously. The equivalence of tuple types is
defined structurally.  The tuple values are noted "(" <I>E0</I>"," ..."," <I>En</I> ")" (see
EXPRESSIONS below). 
<H3><A NAME="sect18" HREF="#sect18">Expressions</A></H3>
The expressions allowed in XTL use the following
auxiliary constructs. 
<DL><DD><DL COMPACT>

<DT> Offers </DT>
<DD>An <I>offer</I> is a construct allowing to match
a value contained in a transition label. The offers have the following syntax:
  <PRE>O       ::=  "?" x ":" T

         |   "!" E

         |   "_"
</PRE>  An offer "?" <I>x</I> ":" <I>T</I> matches a value <I>v</I> iff <I>v</I> has the type <I>T</I>; in case
of matching, the variable <I>x</I> is also assigned the value <I>v</I>. An offer "!" <I>E</I>
matches a value <I>v</I> iff the expression <I>E</I> evaluates to <I>v</I>. An offer "_" (wildcard)
matches a value <I>v</I> of any type. </DD><P>
</DL></DD><P></DL>
<P>

<DL><DD><DL COMPACT>

<DT> Result types </DT>
<DD>The result types denote either
simple types, or anonymous tuple types. They have the following syntax:
  <PRE>RT      ::= T

         |  "(" RT0"," ..."," RTn ")"
</PRE>  These types may occur in variable declarations (see the next paragraph)
as well as in function declarations (see FUNCTIONS below). </DD><P>
</DL></DD><P></DL>
<P>

<DL><DD><DL COMPACT>

<DT> Variable declarations
</DT>
<DD>The variable declarations have the following syntax:   <PRE>D ::= x ":" RT

   |  "any" RT

   |  "(" D0"," ..."," Dn ")"
</PRE>  A declaration <I>x</I> ":" <I>RT</I> defines the variable <I>x</I> of type <I>RT</I>. A declaration
"any" <I>RT</I>, which is meaningful only inside a declaration of anonymous tuple
type, defines a placeholder of type <I>RT</I> standing for a field of the tuple.
Declarations of the form "any" <I>RT</I> can occur only in the "let" expressions
(see below). A declaration "(" <I>D0</I>"," ..."," <I>Dn</I> ")" defines a tuple whose fields
are denoted by the variables and placeholders occurring inside <I>D0</I>, ..., <I>Dn</I>.
</DD><P>
</DL></DD><P></DL>
<P>

<DL><DD><DL COMPACT>

<DT> Operators </DT>
<DD>The operators occur in the "<CODE>for</CODE>" expressions (see below); they
denote calls of binary functions on two arguments. They have the following
syntax:   <PRE>OP        ::= F

           |  "(" OP0"," ..."," OPn ")"
</PRE>  An <I>F</I> operator denotes a call of the binary function <I>F</I>. An "(" <I>OP0</I>"," ...","
<I>OPn</I> ")" operator denotes a call of a binary function on two arguments of
tuple type; the result is a tuple whose fields are the results of the calls
of <I>OP0</I>, ..., <I>OPn</I> on the corresponding fields of the arguments. There is a static
semantics constraint on the operators <I>OP</I>: their left arguments must have
the same types as their results. </DD><P>
</DL></DD><P></DL>
<P>
 The syntax of expressions is given by
the following grammar: <P>
   <PRE>E ::=  K
 
   |   F "(" E0"," ..."," En ")"
 
   |   E0 "of" RT
 
   |   E0 "-&gt;" "[" O0 ... On [ "..." ] [ "where" E1 ] "]"
 
   |   "{" E0"," ..."," En "}"
 
   |   "(" E0"," ..."," En ")"
 
   |   "let" D0 "=" E0"," ..."," Dn "=" En "in"
           En+1
       "end_let"
 
   |   "if" E0 "then" E'0
           "else_if" E1 "then" E'1
           ...
           "else_if" En "then" E'n
           "else" E'n+1
       "end_if"
 
   |   "assert" E0"," ..."," En "in"
           En+1
       "end_assert"
 
   |   "use" x0"," ..."," xn "in"
           E
       "end_use"
 
   |   "for" [ x0 ":" T0 [ "among" E0 ]"," ...","
               xn ":" Tn [ "among" En ] ]
           [ "in" D ]
           [ "while" E'1 ]
           [ "where" E'2 ]
           "apply" OP
           "from" E'3
           "to" E'4
       "end_for"
 
   |   "forall" x0 ":" T0 [ "among" E0 ]"," ...","
                xn ":" Tn [ "among" En ]
       "in"
           En+1
       "end_forall"
 
   |   "exists" x0 ":" T0 [ "among" E0 ]"," ...","
                xn ":" Tn [ "among" En ]
       "in"
           En+1
       "end_exists"
 
   |   "&lt;|" OP "on" x0 ":" T0 [ "among" E0 ]"," ...","
                    xn ":" Tn [ "among" En ]
            [ "where" E' ]
       "|&gt;" En+1
 
   |   "{" x ":" T [ "among" E0 ] "where" E1 "}"
</PRE>  The semantics of expressions is described informally below. <PRE>K
</PRE>
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is a literal constant of a predefined type (see TYPES, FUNCTIONS AND CONSTANTS
above). </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>F "(" E0"," ..."," En ")"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>denotes a call of the function <I>F</I> on the arguments <I>E0</I>, ..., <I>En</I>. The arguments
must be compatible (in number and types) with the formal parameters given
in the definition of <I>F</I> (see FUNCTIONS below). </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>E0 "of" RT
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>specifies that expression <I>E0</I> has type <I>RT</I>. This mechanism allows to solve
ambiguities that may be caused by function overloading (see FUNCTIONS below).
 </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>E0 "-&gt;" "[" O0 ... On [ "..." ] [ "where" E1 ] "]"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is an expression of type <CODE>boolean</CODE>, called matching expression. <I>E0</I> must
be of type <CODE>label</CODE> or <CODE>edge</CODE>. The construct between "<CODE>[</CODE>" and "<CODE>]</CODE>" is called an
label pattern: it allows to match the content of the label denoted by <I>E0</I>
(if <I>E0</I> is of type <CODE>label</CODE>) or by <CODE>label</CODE> (<I>E0</I>) (if <I>E0</I> is of type <CODE>edge</CODE>), possibly
extracting the values of its different fields. The optional construct "..."
matches a sequence of zero or more values of any type.  <P>
For convenience,
in the verification of LOTOS programs, the first offer <I>O0</I> (intended to
match a gate) can be simply written <I>G</I> (i.e., without the "<CODE>!</CODE>" sign). <P>
The variables
contained in <I>O0</I>, ..., <I>On</I> (if any) are visible in the optional expression <I>E1</I>,
which must be of type <CODE>boolean</CODE>. <P>
The XTL compiler examines the labels present
in the BCG graph to check if there exist labels that correspond, in the
number of fields and types of their fields, to the list of offers <I>O0</I>, ...,
<I>On</I>. If no such label is found, then the compiler issues a warning message
(this is a form of <I>vacuity checking</I>). <P>
The compiler also uses the types of
field labels to resolve overloading ambiguities (if any) in offers. For
instance, the offer <CODE>1</CODE> in the label pattern "<CODE>G !1</CODE>" will be considered of
<CODE>integer</CODE> if only integer values are passed on gate <CODE>G</CODE> in the BCG graph on
which the XTL program is evaluated. <P>
A matching expression matches a label
<I>G</I> <I>v1</I> ... <I>vm</I> iff: m = n if "..." is absent, or m &gt;= n otherwise; <I>O0</I> matches <I>G</I>;
<I>O1</I>, ..., <I>On</I> match <I>v1</I>, ..., <I>vn</I>; <I>E1</I>, if present, evaluates to <CODE>true</CODE> in the context
of the variables assigned in the offers. A matching expression evaluates
to <CODE>true</CODE> in case of successful matching of a label (in this case, all the
variables contained in the offers have been initialized) and to <CODE>false</CODE> otherwise.
</DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"{" E0"," ..."," En "}"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>denotes a value of type set defined explicitly (i.e., by enumerating all
its elements). The expressions <I>E0</I>, ..., <I>En</I> must all be of type <CODE>stateset</CODE>, <CODE>labelset</CODE>,
or <CODE>edgeset</CODE>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"(" E0"," ..."," En ")"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>denotes a value of type tuple, containing n fields whose values are
given by <I>E0</I>, ..., <I>En</I>. </DD><P>
</DL></DD><P></DL>
<P>
   <PRE>"let" D0 "=" E0"," ..."," Dn "=" En "in"
    En+1
"end_let"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>allows to declare and initialize variables. The types of the initialization
expressions <I>E0</I>, ..., <I>En</I> must be compatible with the types corresponding to
the declarations <I>D0</I>, ..., <I>Dn</I>. All the variables occurring in the declarations
<I>Di</I> are initialized with the values of <I>Ei</I>, and are visible in the expression
<I>En+1</I>. The "<CODE>let</CODE>" expression also allows to extract the fields of tuple values
and to assign them to variables. </DD><P>
</DL></DD><P></DL>
<P>
   <PRE>"if" E0 "then" E'0
    "else_if" E1 "then" E'1
     ...
    "else_if" En "then" E'n
    "else" E'n+1
"end_if"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>allows the conditional evaluation of expressions. The expressions <I>E0</I>,
..., <I>En</I> must be of type <CODE>boolean</CODE>, whereas <I>E'0</I>, ..., <I>E'n+1</I> must be of the same type
(which is also the type of the "if" expression). The evaluation of an "if"
expression proceeds as follows: the conditions <I>Ei</I> are evaluated (for 1
&lt;= i &lt;= n) and the value of the "if" expression is equal to the value of
the first <I>E'i</I> for which <I>Ei</I> is true. If none of the conditions evaluates to
true, the resulting value is given by <I>E'n+1</I>.  If a condition <I>Ei</I> is a matching
operator, the variables assigned by the offers inside <I>Ei</I> are visible only
in the corresponding expression <I>E'i</I>. </DD><P>
</DL></DD><P></DL>
<P>
   <PRE>"assert" E0"," ..."," En "in"
    En+1
"end_assert"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>allows to stop the execution of an XTL program if a given condition
does not hold. The expressions <I>E0</I>, ..., <I>En</I> must be of type <CODE>boolean</CODE>. If all the
assertions evaluate to <CODE>true</CODE>, the value of the "assert" expression is equal
to the value of <I>En+1</I>; otherwise, the execution of the XTL program is interrupted
and an error message is displayed on the POSIX standard output stream (<CODE>stdout</CODE>).
</DD><P>
</DL></DD><P></DL>
<P>
   <PRE>"use" x0"," ..."," xn "in"
    E
"end_use"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>uses the values of variables <I>x0</I>, ..., <I>xn</I> without changing their value and
then evaluates the expression <I>E</I>. The "use" expression allows to write XTL
programs in which every variable defined is used, which avoids the warnings
of the form "variable set but not used" issued during compilation of the
C code generated by XTL. Although the usage of the "use" expression is harmless
and does not impact in any way the evaluation of XTL expressions, it should
be employed only in the (rare) situations where it is really needed. </DD><P>
</DL></DD><P></DL>
<P>
  
<PRE>"for" [ x0 ":" T0 [ "among" E0 ]"," ...","
        xn ":" Tn [ "among" En ] ]
    [ "in" D ]
    [ "while" E'1 ]
    [ "where" E'2 ]
    "apply" OP
    "from" E'3
    "to" E'4
"end_for"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>allows the iterative evaluation of expressions. The <I>iteration variables</I>
<I>x0</I>, ..., <I>xn</I> range over the iteration domains <I>T0</I> [ "among" <I>E0</I> ], ..., <I>Tn</I> [ "among"
<I>En</I> ], respectively. The expressions <I>Ei</I> must be of type "<CODE>set of </CODE><I>Ti</I>": thus,
iterations over sets of states, labels, or edges are allowed. There is an
exception concerning integer numbers and characters: for these types, domains
of the form "{" <I>E1</I> "..." <I>E2</I> "}", meaning all the integers (resp. characters)
between <I>E1</I> and <I>E2</I>, are also allowed. The variables declared in the "in"
<I>D</I> declaration (if present) are called <I>accumulators</I>. Both iteration variables
and accumulators are visible in the expressions <I>E'1</I>, <I>E'2</I> (if present), and
<I>E'4</I>, but not in <I>E'3</I>.  The expressions <I>E'1</I> and <I>E'2</I> must be of type <CODE>boolean</CODE>. <P>
Assuming
that all the optional constructs are present, the evaluation of a "<CODE>for</CODE>"
expression proceeds as follows. The accumulators are initialized to the
value of <I>E'3</I>. Let us note <I>v</I> the current values of the accumulators (<I>v</I> may
be of type tuple). Then, for each value of the iteration variables in their
corresponding domains, the expression <I>v</I> <I>OP</I> <I>E'4</I> is evaluated and its result
is stored in the accumulators. The value of the "<CODE>for</CODE>" expression is equal
to the value of the accumulators obtained after the last iteration. The
"where" clause allows to perform only those iterations for which the expression
<I>E'2</I> evaluates to <CODE>true</CODE>. The "while" clause allows to stop the iterations when
the expression <I>E'1</I> becomes <CODE>false</CODE>. <P>
Particular cases of "<CODE>for</CODE>" expressions may
be obtained by eliminating some (or all) of the optional constructs. If
the iteration variables are absent, the "<CODE>for</CODE>" becomes an infinite loop:
in this case, the "<CODE>while</CODE>" clause must be present in order to stop the evaluation.
If the "<CODE>in</CODE>" declaration is absent, the accumulator is implicit: it is used
internally to store the results of intermediate iterations, but it cannot
be used in <I>E'1</I>, <I>E'2</I>, nor <I>E'4</I>. <P>
The "<CODE>for</CODE>" expressions are useful for describing
iterative computations. For instance, the expression below displays on the
standard output the sequence of Fibonacci numbers smaller than 1000:  <PRE>for
    in    (xn_plus_1, xn: integer, a:action)
    while xn &lt; 1000
    apply (replace, replace, fby)
    from  (1, 1, nop)
    to    (xn_plus_1 + xn, xn_plus_1,
           print (xn) fby printf ("\n"))
end_for
</PRE> </DD><P>
</DL></DD><P></DL>
<P>
   <PRE>"forall" x0 ":" T0 [ "among" E0 ]"," ...","
         xn ":" Tn [ "among" En ]
"in"
    En+1
"end_forall"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the universal quantifier. It is equivalent to the following "<CODE>for</CODE>"
expression:    <PRE>"for" x0 ":" T0 [ "among" E0 ]"," ...","
      xn ":" Tn [ "among" En ]
    "apply" and
    "from"  true
    "to"    En+1
"end_for"
</PRE>  The type of <I>En+1</I> may be either <CODE>boolean</CODE>, <CODE>stateset</CODE>, <CODE>labelset</CODE>, or <CODE>edgeset</CODE>.
In the three latter cases, the <CODE>true</CODE> and <CODE>and</CODE> operators correspond to full
set and set intersection, respectively (see TYPES, FUNCTIONS AND CONSTANTS
above). </DD><P>
</DL></DD><P></DL>
<P>
   <PRE>"exists" x0 ":" T0 [ "among" E0 ]"," ...","
         xn ":" Tn [ "among" En ]
"in"
    En+1
"end_exists"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the existential quantifier. It is equivalent to the following "<CODE>for</CODE>"
expression:    <PRE>"for" x0 ":" T0 [ "among" E0 ]"," ...","
      xn ":" Tn [ "among" En ]
    "apply" or
    "from"  false
    "to"    En+1
"end_for"
</PRE>  The type of <I>En+1</I> may be either <CODE>boolean</CODE>, <CODE>stateset</CODE>, <CODE>labelset</CODE>, or <CODE>edgeset</CODE>.
In the three latter cases, the <CODE>false</CODE> and <CODE>or</CODE> operators correspond to empty
set and set union, respectively (see TYPES, FUNCTIONS AND CONSTANTS above).
</DD><P>
</DL></DD><P></DL>
<P>
   <PRE>"&lt;|" OP "on" x0 ":" T0 [ "among" E0 ]"," ...","
             xn ":" Tn [ "among" En ]
     [ "where" E' ]
"|&gt;" En+1
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is an abbreviated form of the "<CODE>for</CODE>" expression, called <I>iterator</I>. It is
equivalent to the following "<CODE>for</CODE>" expression:    <PRE>"for" x0 ":" T0 [ "among" E0 ]"," ...","
      xn ":" Tn [ "among" En ]
    [ "where" E' ]
    "apply" OP
    "from"  init_OP
    "to"    En+1
"end_for"
</PRE>  </DD><P>

<DT></DT>
<DD>Here <I>init_OP</I> is a "start" value associated by default to the operator
<I>OP</I>. Only the binary predefined operators that have initial values assigned
by default can be used in the iterators.  These operators, together with
their initial values, are given in the table below (where "<I>set</I>" denotes
either <CODE>stateset</CODE>, <CODE>labelset</CODE>, or <CODE>edgeset</CODE>).   <PRE>+-----------------------------------+---------------+
|            Operator OP            |    init_OP    |
+===================================+===============+
| or  : boolean, boolean -&gt; boolean | false         |
| and : boolean, boolean -&gt; boolean | true          |
| + : integer, integer -&gt; integer   | 0             |
| * : integer, integer -&gt; integer   | 1             |
| union, or  : set, set -&gt; set      | empty, false  |
| inter, and : set, set -&gt; set      | full, true    |
| diff       : set, set -&gt; set      | full          |
| insert : set, elem -&gt; set         | empty         |
| remove : set, elem -&gt; set         | full          |
| fby : action, action -&gt; action    | nop           |
+-----------------------------------+---------------+
</PRE>  The iterators allow to express iterative computations in a form close
to the mathematical notation. For example, the sum of the integer numbers
from 1 to 100 may be computed with the following iterator:  <PRE>    &lt;| + on K:integer among { 1 ... 100 } |&gt; K
</PRE> Similarly, the number of transitions labelled with "SEND" labels may be
computed as follows:  <PRE>    &lt;| + on T:edge where T -&gt; [ SEND ... ] |&gt; 1
</PRE>  <BR>
    </DD><P>
</DL></DD><P></DL>
<P>
<PRE>"{" x ":" T [ "among" E0 ] "where" E1 "}"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is a set value defined by specifying a predicate <I>E1</I> characterizing the
elements of the set. This construct is also a particular case of "<CODE>for</CODE>" expression:
  <PRE>    "for" x ":" T [ "among" E0 ]
        "where" E1
        "apply" union
        "from"  empty
        "to"    "{" x "}"
    "end_for"
</PRE>  The implicitly defined sets allow to compute sets of states, labels or
transitions in a form close to the mathematical notation. For example, the
set of deadlock states (i.e., states having no successors) can be computed
by the XTL expression below:  <PRE>    { S:state where succ (S) = empty }
</PRE> </DD><P>
</DL></DD><P></DL>
<P>
 
<H3><A NAME="sect19" HREF="#sect19">Functions</A></H3>
The XTL language allows to define and use functions. The syntax
of function definitions is given by the grammar below:   <PRE>FD      ::=  "def" F "(" x1 ":" T1"," ..."," xn ":" Tn ")" ":" RT "="
                 [ FD1 ... FDm ]
                 E
                 [ "where" FDm+1 ... FDm+p ]
             "end_def"

         |   "def" "_" F "_" "(" x1 ":" T1"," x2 ":" T2 ")" ":" RT "="
                 [ FD1 ... FDm ]
                 E
                 [ "where" FDm+1 ... FDm+p ]
             "end_def"
</PRE>  The first construct above defines a function <I>F</I> having the parameters
<I>x1</I>, ..., <I>xn</I> of types <I>T1</I>, ..., <I>Tn</I>, the body <I>E</I>, and returning a result of type
<I>RT</I>. The calls of <I>F</I> have the form:   <PRE>        F "(" E1"," ..."," En ")"
</PRE>  where the arguments <I>E1</I>, ..., <I>En</I> must be compatible (in number and types)
with the parameters of <I>F</I>. The result of the call is equal to the value of
<I>E</I> computed in a context in which the parameters <I>xi</I> are assigned the values
of <I>Ei</I> for all i between 1 and n.  The body of <I>F</I> may also contain definitions
of local functions, placed either before <I>E</I>, or after <I>E</I> and the keyword
"<CODE>where</CODE>".  These functions are visible only in the expression <I>E</I>. Recursive
functions are allowed. Also, functions can be overloaded: several functions
with the same name, but different profiles, may be defined in the same
scope.  In case of ambiguity of the type of a function call, the "<CODE>of</CODE>" expression
may be used to precise a unique type (see EXPRESSIONS above). <P>
The second
construct above defines a binary infixed function <I>F</I> having the parameters
<I>x1</I>, <I>x2</I> of types <I>T1</I>, <I>T2</I>, and returning a result of type <I>RT</I>. The function
<I>F</I> behaves like an ordinary binary function, except that its calls may be
written either in the form <I>F</I> "(" <I>E1</I>"," <I>E2</I> ")", or in the form <I>E1</I> <I>F</I> <I>E2</I>. This
kind of functions allow to write expressions involving infixed operators
using a syntax close to the mathematical notation. For example, the predefined
function "<CODE>+</CODE>" over integers is in fact an infixed operator: the user may
write either + (1, 2), or 1 + 2. The infixed operators (both predefined
and user-defined) are right-associative: e.g., the expression 1 + 2 + 3 is
parsed as 1 + (2 + 3). <P>
Functions can be, of course, recursive (either directly,
or transitively). For example, the recursive function below computes the
factorial of an integer number:  <PRE>def fact (n:integer) : integer =
    assert n &gt;= 0 in
        if n = 0 then
            1
        else
            n * fact (n - 1)
        end_if
    end_assert
end_def
</PRE> This function also checks whether its argument is greater or equal to
0 using an "<CODE>assert</CODE>" expression; if this is not the case, the program execution
is aborted with an appropriate error message. <P>
 
<H3><A NAME="sect20" HREF="#sect20">Macros</A></H3>
The XTL compiler allows
to define and use macros. The syntax of macro-definitions is given by the
following grammar:   <PRE>MD        ::=  "macro" M "(" P1"," ..."," Pn ")" "="
                 &lt;text&gt;
               "end_macro"
</PRE>  The above construct defines a macro <I>M</I> having the parameters <I>P1</I>, ..., <I>Pn</I>
and the body &lt;text&gt;, which is a portion of text built using the characters
allowed by the XTL language (see LEXICAL ELEMENTS above). The calls of <I>M</I>
have the form:   <PRE>        M "(" &lt;text1&gt;"," ..."," &lt;textn&gt; ")"
</PRE>  where the arguments &lt;text1&gt;, ..., &lt;textn&gt; are portions of XTL text. The result
of the call is &lt;text&gt; in which all the occurrences of the parameters <I>Pi</I> have
been syntactically substituted with the arguments &lt;texti&gt;, for all i between
1 and n. The following syntactic restriction must be satisfied: the keywords
contained in each &lt;texti&gt; argument must be well-bracketed, i.e., if &lt;texti&gt; contains
a keyword opening an expression (e.g., "<CODE>for</CODE>"), then &lt;texti&gt; must also contain
the corresponding keyword closing the expression (e.g., "<CODE>end_for</CODE>"). This also
applies to the non-alphabetic keywords such as "<CODE>(</CODE>", "<CODE>)</CODE>", "<CODE>[</CODE>", "<CODE>]</CODE>", "<CODE>{</CODE>",
"<CODE>}</CODE>". A macro is visible from the point of its definition until the end of
the XTL program. The macros may be overloaded: several macros with the same
name, but different arities, may be defined in the same scope. 
<H3><A NAME="sect21" HREF="#sect21">Libraries</A></H3>
There
is also possible to include in the text of an XTL program external libraries,
typically containing definitions of temporal operators. The inclusion command
has the following syntax:    <PRE>LI        ::=  "library" &lt;file0.xtl&gt;"," ..."," &lt;filen.xtl&gt;
               "end_library"
</PRE>  At the compilation of the program, the above construct is syntactically
replaced with the contents of the files &lt;file0.xtl&gt;, ..., &lt;filen.xtl&gt;, placed one
after the other in this order. The XTL compiler searches the included files
first in the current directory, then in the directory referenced by <B>$CADP/src/xtl</B>.
Multiple inclusions of the same file are silently discarded, unless the
<B>-warning</B> option is passed to the compiler; in this case, appropriate messages
are issued. 
<H3><A NAME="sect22" HREF="#sect22">Directives</A></H3>
The XTL compiler allows to declare and use in an XTL
program data types and functions implemented externally in C. The directive
for an external type declaration has the following syntax: <PRE>ETD  ::=  "type" T
                [ "!" "implementedby" "&lt;C_type&gt;" ]
                [ "!" "comparedby" "&lt;C_compare&gt;" ]
                [ "!" "enumeratedby" "&lt;C_iterate&gt;" ]
                [ "!" "printedby" "&lt;C_print&gt;" ]
          "end_type"
</PRE>where <I>T</I> is the identifier of the declared type and the optional pragmas
preceded by "!" refer to the C implementation of <I>T</I>: &lt;C_type&gt; is the identifier
of the C type implementing <I>T</I>; &lt;C_compare&gt; is an operator for comparing two
values of type <I>T</I>; &lt;C_iterate&gt; is a macro allowing to iterate over all values
of type <I>T</I>; and &lt;C_print&gt; is a printing function for values of type <I>T</I>. The
C names declared by these pragmas cannot be used directly in the XTL program,
but are used in the C code generated by the XTL compiler. The directive
for an external function declaration has the following syntax: <PRE>EFD  ::=  "func" F "(" T1"," ..."," Tn ")" ":" RT
                [ "!" "implementedby" "&lt;C_func&gt;" ]
          "end_func"
</PRE>where <I>F</I> is the identifier of the declared function, <I>T1</I>, ..., <I>Tn</I> are the types
of its parameters, and <I>RT</I> is the type of its result. The optional pragma
"implementedby" declares the name &lt;C_func&gt; of the C function implementing
<I>F</I>. This C identifier cannot be used in the XTL program, but is used in the
C code generated by the XTL compiler. The external types and functions declared
using the directives above may be implemented in (one or more) C files
file1.c, ..., filen.c that must be included in the C code generated by the XTL
compiler. This is done using the following external include directive: 
<BR>
 <BR>
<PRE>EID  ::=  "include" "&lt;file1&gt;", ..., "&lt;filen&gt;" "end_include"
</PRE>where &lt;file1&gt;, ..., &lt;filen&gt; are the names of the C source files (".c" and/or ".h")
that must be included. This directive is translated into corresponding "#include"
pre-processor commands in the C code generated by the XTL compiler. The compilation
and linkediting of the C modules included may require specific parameters.
These can be indicated to the XTL compiler using the following external
compile directive: <PRE>ELD  ::=  "flag" "&lt;C_compiler_directives&gt;" "end_flag"
</PRE>where &lt;C_compiler_directives&gt; is a portion of command-line for invoking the
C compiler (typically containing "-I", "-L", and "-l" options) that specifies
the desired compilation parameters. This portion of command-line is used
by the XTL compiler when creating the binary file of the generated C code.
As an example, the XTL program below uses the CAESAR_ERROR() function for
error handling, which is declared externally in the "caesar_standard.h"
file and defined in the OPEN/CAESAR library libcaesar.a. Upon execution,
the program will output the error message and stop. <PRE>    include
      "caesar_standard.h"
    end_include
 
    flag
      "-I/common/Cadp/incl -L/common/Cadp/bin.sun5 -lcaesar"
    end_flag
 
    func error (string) : action
      ! implementedby "CAESAR_ERROR"
    end_func
 
    error ("Here occurs a fatal error. Farewell.")
</PRE><P>
 
<H3><A NAME="sect23" HREF="#sect23">Program</A></H3>
The syntax of an XTL program is given by the following grammar:
  <PRE>PG  ::=  [ ( FD1 | ETD1 | EFD1 | EID1 | ELD1 )
           ...
           ( FDm | ETDm | EFDm | EIDm | ELDm ) ]
         [ MD1 ... MDp ]
         [ LI1 ... LIr ]
             E
         [ "where"
            [ MDp+1 ... MDp+q ]
            [ LIr+1 ... LIr+s ]
            ( FDm+1 | ETDm+1 | EFDm+1 | EIDm+1 | ELDm+1 )
            ...
            ( FDm+n | ETDm+n | EFDm+n | EIDm+n | ELDm+n ) ]
</PRE>  The expression <I>E</I> is the body of the program. There may also be lists of
function definitions, external directives, macro definitions, and/or library
inclusions, placed in the front of the program or at its end, after the
"<CODE>where</CODE>" keyword. The functions defined by <I>FD1</I>, ..., <I>FDm+n</I> are visible in the
body <I>E</I> of the program, as well as in all their bodies. 
<H2><A NAME="sect24" HREF="#sect24">How to Create a XTL
File</A></H2>
At present, XTL files must be written by hand. 
<H2><A NAME="sect25" HREF="#sect25">How to Read a XTL File</A></H2>
At
present, there is one single CADP tool, <A HREF="xtl.html"><B>xtl</B></A>
, that reads and processes
XTL files. 
<H2><A NAME="sect26" HREF="#sect26">Bibliography</A></H2>
[MG98] R. Mateescu and H. Garavel. XTL: Meta-Language
and Tool for Temporal Logic Model-Checking. Proc. of the International Workshop
on Software Tools for Technology Transfer STTT'98 (Aalborg, Denmark). BRICS
Notes Series NS-98-4, pp. 33-42, 1998. Available from <A HREF="http://cadp.inria.fr/publications/Mateescu-Garavel-98.html">http://cadp.inria.fr/publications/Mateescu-Garavel-98.html</A>

<P>
[GLMS13] H. Garavel, F. Lang, R. Mateescu, and W. Serwe. CADP 2011: A Toolbox
for the Construction and Analysis of Distributed Processes. Springer International
Journal on Software Tools for Technology Transfer (STTT), 15(2):89-107,
2013. <A HREF="http://cadp.inria.fr/publications/Garavel-Lang-Mateescu-Serwe-13.html">http://cadp.inria.fr/publications/Garavel-Lang-Mateescu-Serwe-13.html</A>
 
<H2><A NAME="sect27" HREF="#sect27">See
Also</A></H2>
<A HREF="bcg.html"><B>bcg</B></A>
, <A HREF="bcg_io.html"><B>bcg_io</B></A>
, <A HREF="xtl.html"><B>xtl</B></A>
. <P>
Additional information is available
from the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives for installation
are given in files <B>$CADP/INSTALLATION_*</B>. <P>
Recent changes and improvements
to this software are reported and commented in file <B>$CADP/HISTORY</B>. 
<H2><A NAME="sect28" HREF="#sect28">Bugs</A></H2>
Please
report bugs to <A HREF="mailto:Radu.Mateescu@inria.fr?Subject=CADP-Bug-Report">Radu.Mateescu@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Description</A></LI>
<LI><A NAME="toc2" HREF="#sect2">LTS Model</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Syntax and Semantics of XTL</A></LI>
<UL>
<LI><A NAME="toc4" HREF="#sect4">Lexical Elements</A></LI>
<LI><A NAME="toc5" HREF="#sect5">Internal and External Types</A></LI>
<LI><A NAME="toc6" HREF="#sect6">Internal and External Functions</A></LI>
<LI><A NAME="toc7" HREF="#sect7">Boolean Type and Functions</A></LI>
<LI><A NAME="toc8" HREF="#sect8">Integer Type and Functions</A></LI>
<LI><A NAME="toc9" HREF="#sect9">Natural Type and Functions</A></LI>
<LI><A NAME="toc10" HREF="#sect10">Real Type and Functions</A></LI>
<LI><A NAME="toc11" HREF="#sect11">Character Type and Functions</A></LI>
<LI><A NAME="toc12" HREF="#sect12">String Type and Functions</A></LI>
<LI><A NAME="toc13" HREF="#sect13">Raw Type and Functions</A></LI>
<LI><A NAME="toc14" HREF="#sect14">Meta-types and Functions</A></LI>
<LI><A NAME="toc15" HREF="#sect15">Number Type and Functions</A></LI>
<LI><A NAME="toc16" HREF="#sect16">Action Type and Functions</A></LI>
<LI><A NAME="toc17" HREF="#sect17">Anonymous Tuple Types</A></LI>
<LI><A NAME="toc18" HREF="#sect18">Expressions</A></LI>
<LI><A NAME="toc19" HREF="#sect19">Functions</A></LI>
<LI><A NAME="toc20" HREF="#sect20">Macros</A></LI>
<LI><A NAME="toc21" HREF="#sect21">Libraries</A></LI>
<LI><A NAME="toc22" HREF="#sect22">Directives</A></LI>
<LI><A NAME="toc23" HREF="#sect23">Program</A></LI>
</UL>
<LI><A NAME="toc24" HREF="#sect24">How to Create a XTL File</A></LI>
<LI><A NAME="toc25" HREF="#sect25">How to Read a XTL File</A></LI>
<LI><A NAME="toc26" HREF="#sect26">Bibliography</A></LI>
<LI><A NAME="toc27" HREF="#sect27">See Also</A></LI>
<LI><A NAME="toc28" HREF="#sect28">Bugs</A></LI>
</UL>
</BODY></HTML>
