  <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>SVL manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
   
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
svl, SVL - script language for verification scenarios 
<H2><A NAME="sect1" HREF="#sect1">Description</A></H2>
<P>
SVL
(<I>Script Verification Language</I>) offers a way to describe (compositional
and on-the-fly) verification scenarios, under the form of sequences of statements
of several kinds: 
<UL>
<LI type=disc>assignment statements, which produce a file containing
a representation of a given expression; </LI><P><LI type=disc>comparison statements, which compare
two expressions modulo some equivalence or preorder relation; </LI><P><LI type=disc>statements
for verifying a temporal logic formula in an expression; </LI><P><LI type=disc>statements for
checking livelocks or deadlocks in an expression. </LI><P>
</UL>
<P>
Expressions are built
upon the following components: 
<UL>
<LI type=disc>behaviour systems represented either implicitly
(as LNT, LOTOS, or FSP programs, processes in LNT, LOTOS, or FSP programs,
or networks of communicating automata in the EXP format), or explicitly
(as Labelled Transition Systems in one of the formats provided with CADP,
namely BCG, AUT, sequential FC2, or SEQ); note that the parallel FC2 format
is no longer supported; </LI><P><LI type=disc>LNT and LOTOS like parallel operators, enabling
parallel composition of expressions; </LI><P><LI type=disc>label hiding, label cutting, and label
renaming operators; </LI><P><LI type=disc>operators of abstraction of an expression with respect
to some interface; </LI><P><LI type=disc>operators for generating the explicit LTS of an expression;
</LI><P><LI type=disc>operators of (total or partial) reduction modulo some equivalence relation;
</LI><P><LI type=disc>so-called <I>meta-operators</I> of (total or partial) reduction, that apply to SVL
abstract trees during a preliminary compilation phase called "expansion";
the meta-operators implement several useful compositional reduction strategies.
</LI><P>
</UL>
<P>
Moreover, SVL offers a way to invoke Bourne shell commands and to parameterize
expressions with respect to particular tools and methods of CADP. 
<H2><A NAME="sect2" HREF="#sect2">Syntax
Description</A></H2>
<P>
The syntax of SVL is described using productions in the Extended
Bachus-Naur Form (EBNF).  <P>
Terminal symbols are written between double quotes,
except for the double quote itself, which is written between single quotes.
The newline character is written "\n". Non-terminal symbols are written in
italic. Optional parts of productions are enclosed between square brackets,
and parts that can be iterated zero or more times are written between braces.
<P>
The following table sums up the non-terminal symbols and their meaning. 
<PRE>   +-----------+--------------------------------------+
   | Symbol    |            Description               |
   +-----------+--------------------------------------+
   | P         | program, sequence of statements      |
   | S, S1, S2 | statement                            |
   | F         | file                                 |
   | EXT       | file extension                       |
   | B         | behaviour expression                 |
   | SPEC      | behaviour specification              |
   | E         | equivalence relation                 |
   | M         | verification method                  |
   | T         | verification tool                    |
   | RE        | result and/or expected value         |
   | LL        | list of labels                       |
   | L         | label                                |
   | GPL       | list of gate parameters              |
   | G         | gate                                 |
   | AL        | list of data parameters (process)    |
   | A         | data parameter (process)             |
   | TL        | list of (possibly typed) labels      |
   | LD        | list of synchronization definitions  |
   | RL        | list of renaming rules               |
   | LP        | label pattern                        |
   | PID       | process/property identifier          |
   | C         | LNT channel identifier               |
   | O         | data operator                        |
   +-----------+--------------------------------------+
</PRE>
<H2><A NAME="sect3" HREF="#sect3">Syntax of Programs</A></H2>
<P>
A program is a sequence of statements, separated in two
categories: <I>S1</I> and <I>S2</I>. Statements in <I>S2</I> are composed sequentially with subsequent
statements using the ";" character. Statements in <I>S1</I> have their own terminating
character and do not need a ";" separator.  <PRE>    P  ::= &lt;empty&gt;
        |  S1 [ P ]
        |  S2 [ ";" P ]
</PRE><P>
Statements are either assignments, behaviour comparisons, temporal logic
verifications, deadlock/livelock checks, Bourne shell commands, property
definitions, or property checks. A property definition can embed other statements.
It is given a name, optional parameters, comments, and possibly an expected
result that must be attached to each embedded verification statement, namely
behaviour comparisons, temporal logic verifications, and deadlock/livelock
checks. An expected result may also be attached optionally to Bourne shell
commands. <P>
Comparisons can be parameterized modulo a particular equivalence
relation (<I>E</I>), with a particular CADP tool (<I>T</I>), and using a particular exploration
method provided by the selected tool (<I>M</I>). <P>
Temporal logic formulas can be
either stored in a file or inlined in the SVL script. <P>
Deadlock/livelock
checks can be parameterized with a particular CADP tool. <P>
Comparisons, temporal
logic verifications, and deadlock/livelock checks may produce diagnostic
files. <P>
Assignments produce LTS files. <P>
Using the keyword "result <I>result-id</I>",
one can associate to a comparison, temporal logic verification, deadlock/livelock
verification, or Bourne shell command a shell variable <I>result-id</I> in which
the result (of the verification or Bourne shell command) will be stored.
Such shell-variables can be used to guide the script execution depending
on verification results, using Bourne shell commands. <PRE>    S1 ::= "%" shell-line "\n"
        |  "property" PID ["("param"," ..."," param")"]
               ['"'comment'"' ... '"'comment'"']
           "is"
               P
           "end property"
        |  [F "="] B "|=" ["using" M] ["with" T] formula ";"
    S2 ::= "%" shell-line "\n"
               RE
        | F "=" B 
        |  "check" PID "(" arg "," ... "," arg ")"
        |  [F "="] [E]  ["probabilistic" | "stochastic"]
               "comparison" ["using" M] ["with" T]
               B ("==" | "&gt;=" | "&lt;=") B [ ";" RE ]
        |  [F "="] "verify" F ["using" M] ["with" T] "in"
               B [ ";" RE ]
        |  [F "="] "deadlock" ["with" T] "of"
               B [ ";" RE ]
        |  [F "="] "livelock" ["with" T] "of"
               B [ ";" RE ]
        |  [F "="] B "|=" ["using" M] ["with" T] formula ";"
               RE
    RE ::= "result" L1
        |  "expected" L2
        |  "result" L1 "expected" L2
    E  ::= "strong" | "observational" | "branching"
        |  "divbranching" | "tau*.a" | "safety" | "trace"
        |  "weak trace" | "tau-confluence"
        |  "tau-compression" | "tau-divergence"
 
    M  ::= "std" | "bdd" | "fly" | "bfs" | "dfs"
        |  "acyclic"
    T  ::= "aldebaran" | "bcg_min" | "bcg_cmp"
        |  "bisimulator" | "evaluator" | "evaluator3"
        |  "evaluator4" | "evaluator5" | "exhibitor"
        |  "reductor" 
</PRE><P>
Note that the keyword "expected" is only allowed in the scope of a "property"
statement. <P>
Note that <B>fc2tools</B> are no longer supported. <P>
Files are written
between double quotes, and must specify a valid extension. Not all extensions
are valid in all contexts, as stated more precisely in the sections describing
the particular statements and behaviours.  <PRE>    F   ::= '"'prefix.EXT'"' | '"'filename'"'
    EXT ::= "aut" | "bcg" | "fc2" | "seq" 
         |  "lnt" | "lotos" | "lot" | "lts" | "exp" 
         |  "hide" | "hid" | "cut" | "rename" | "ren" | "sync" 
         |  "mcl" | "xtl"
</PRE>A file <I>prefix</I> is any string satisfying the syntax of file names in the
current operating system. 
<H2><A NAME="sect4" HREF="#sect4">Syntax of Behaviour Expressions</A></H2>
<P>
Behaviour expressions
are built from elementary systems, that are combined together using the
various operators described below. <PRE>    B   ::= SPEC
         |  "stop"
         |  "generation" "of" B
         |  ["leaf" | "root" | "root leaf" | "node" | "smart"]
            ["total" | "partial"]
            [E] ["probabilistic" | "stochastic"]
            "reduction" ["using" M] ["with" T]
            "of" B
         |  ["total" | "partial" | "gate"] "hide" 
            (["all" "but"] [TL] | "using" F) "in" B 
            ["end" "hide"]
         |  ["total" | "partial" | "gate"] "cut" 
            (["all" "but"] [TL] | "using" F) "in" B 
            ["end" "cut"]
         |  ["total" | "partial" | "gate"] "prio"
            (["all" "but"] LL ("&gt;" ["all" "but"] LL)+)+
            "in" B
            ["end" "prio"]
         |  ["total" | "single" | "multiple" | "gate"] 
            "rename" (RL | "using" F) "in" B 
            ["end" "rename"]
         |  ["total" | "partial" | "gate"]  
            ["user"] "abstraction" B
            ["sync" ([LL] | "using" F)] "of" B 
         |  "refined" ["user"] "abstraction" LL
            ["using" B] "of" B
         | "chaos" ( "with" LL 
                   | "with" n "labels" LP 
                   | "using" F )
         | "bag" m ( "with" LL
                   | "with" n "labels" LP "," LP
                   | "using" F )
         | "fifo" m ( "with" LL
                    | "with" n "labels" LP "," LP
                    | "using" F )
         | ["label" | "gate"] "par" [("all" | LD) "in"]
           [LD "-&gt;"] B ("||" [LD "-&gt;"] B)+
           "end par"
         |  B "||" B 
         |  B "|||" B 
         |  B "|[" [LL] "]|" B
         |  B "-||"["?"] B
         |  B "-|||"["?"] B
         |  B "-|[" [LL] "]|"["?"] B
         |  "(" B ")" 
    SPEC ::= F 
          |  [F ":"] L ["[" GPL "]"] ["(" AL ")"]
    LL ::= L [ "," LL ]
        |  "{"string"}"
    GPL ::= L [ "," GPL ]
        |  L "=&gt;" L [ "," GPL ]
        |  "..."
        |  "{"string"}"
    AL ::= A [ "," AL ]
    TL ::= L [ ":" C ] [ "," TL ]
        |  "{"string"}"
    LD ::= L [ "," LD ]
        |  L "#" n [ "," LD ]
        |  "{"string"}"
    RL ::= L "-&gt;" L [ "," RL ]
        |  "{"string"}"
    L ::= G | '"'string'"'
    LP ::= '"'string-with-%d'"'
    G, PID, C ::= lotos-identifier
<tt> </tt>&nbsp;<tt> </tt>&nbsp;| lnt-identifier
    A ::= O ["(" AL ")"]
        | A O A
        | A "of" L
        | ["+" | "-"] n
        | "'"char"'"
    O ::= lotos-identifier
        | lnt-identifier
        | special-identifier
</PRE><P>
where <I>n</I> denotes a natural number greater or equal to 2.  <P>
A <I>lotos-identifier</I>
or an <I>lnt-identifier</I> is a word that starts with a letter and contains letters,
digits, and underscores, and is not a keyword. Underscore can not be the
last character of a <I>lotos-identifier</I> or of an <I>lnt-identifier</I>. <P>
A <I>special-identifier</I>
is a word consisting of the characters '#', '&amp;', '*', '+', '-', '.', '/', '&gt;', '=', '&lt;', '@', '\', '^',
'~', '{', and '}', that is not a key symbol of SVL. Note that if the sequence
starts with character '{', then it must finish with character '}'. 
<H2><A NAME="sect5" HREF="#sect5">Precedence
and Associativity of Operators</A></H2>

<UL>
<LI type=disc>Parallel composition operators ("||", "|||", and
"|[" <I>LL</I> "]|") associate to the right. For instance,   <PRE>"a.bcg" ||| "b.aut" |[A]| "c.fc2" |[B]| "d.seq"
</PRE>reads <PRE>"a.bcg" ||| ("b.aut" |[A]| ("c.fc2" |[B]| "d.seq"))
</PRE></LI><P></CODE><LI type=disc>On the opposite, infix abstraction operators associate to the left. For
instance, <PRE>"a.bcg" -||| "b.aut" -|[A]| "c.fc2" -|[B]| "d.seq"
</PRE>reads <PRE>(("a.bcg" -||| "b.aut") -|[A]| "c.fc2") -|[B]| "d.seq"
</PRE></LI><P><LI type=disc>Infix abstraction has a higher priority than parallel composition. For instance,
<PRE>"a.bcg" -|| "i.bcg" ||| "c.bcg" -|| "i.bcg"
</PRE>reads <PRE>("a.bcg" -|| "i.bcg") ||| ("c.bcg" -|| "i.bcg")
</PRE></LI><P><LI type=disc>The lexical scope of "hide", "cut", "prio", "rename", "generation", "reduction",
and "abstraction" (prefix operators) extends as far as possible to the
right of the expression. For instance, <PRE>hide A in "a.bcg" || "b.bcg"
</PRE>is the same as  <PRE>hide A in ("a.bcg" || "b.bcg")
</PRE></LI><P>
</UL>
<P>
<B>Examples</B>: <PRE>"a.bcg" || "b.bcg" -|| hide G in "c.bcg" ||| "d.bcg"
</PRE>reads <PRE>"a.bcg" || ("b.bcg" -|| hide G in ("c.bcg" ||| "d.bcg"))
</PRE><PRE>par A#2 in "a.bcg" || reduction of "b.bcg" || "c.bcg" end par
</PRE>reads <PRE>par A#2 in "a.bcg" || reduction of ("b.bcg" || "c.bcg") end par
</PRE> 
<H2><A NAME="sect6" HREF="#sect6">Semantics of Behaviour Expressions</A></H2>
The semantics of behaviours is defined
as follows: 
<H3><A NAME="sect7" HREF="#sect7">Behaviour Systems</A></H3>
<I>SPEC</I> may be the name of a file containing
a Labelled Transition System (LTS) in one of the AUT (extension <B>.aut</B>), BCG
(extension <B>.bcg</B>), FC2 (extension <B>.fc2</B>), or SEQ (extension <B>.seq</B>) file formats.
BCG files may define stochastic or probabilistic LTSs as explained in the
<A HREF="bcg_min.html"><B>bcg_min</B></A>
 manual page. <P>
<I>SPEC</I> may also be the name of a file containing
a network of LTSs in the EXP file format (extension <B>.exp</B>). See a description
of the .exp format in the  <A HREF="aldebaran.html"><B>aldebaran</B></A>
 manual page <P>
At last, <I>SPEC</I> may
also be the name of an LNT, LOTOS, or FSP file, or an instanciation of
a process in an LNT, LOTOS, or FSP file. In the latter case, the syntax
is as follows: <PRE>[F ":"] L ["[" GPL "]"] ["(" AL ")"]
</PRE>where <I>F</I> is the name of the LNT (extension <B>.lnt</B>), LOTOS (extension <B>.lotos</B>
or <B>.lot</B>), or FSP (extension <B>.lts</B>) file, <I>L</I> is a label denoting the name of
the invoked process, <I>GPL</I> is an optional list of gate parameters of the
process, and <I>AL</I> is an optional list of arguments representing the data
parameters of the process. For an FSP process instanciation, <I>GPL</I> and <I>AL</I>
must remain empty. For a LOTOS process instanciation, <I>GPL</I> must contain a
list of gates. For an LNT process instanciation, <I>GPL</I> may use the dot notation
"..." and the named notation <CODE>G1 =&gt; G2</CODE>, where <CODE>G1</CODE> is a formal gate parameter
of the process, and <I>G2</I> is the corresponding actual parameter. See the LNT
user manual for details. Note that <I>L</I>, <I>GPL</I>, and <I>AL</I> may contain Bourne Shell
variables (see Section USING SHELL VARIABLES IN EXPRESSIONS for details).
Those Bourne Shell variables can only occur inside double quotes. As a consequence,
the double quotes in <I>AL</I> must not be interpreted as the delimiter of a LOTOS
or LNT character string. For arguments of type string, the double quotes
must be escaped, as in the following example: <BR>
<CODE>P [A, B] ("$X" of Nat, "\"this is a string\"")</CODE> <P>
The filename <I>F</I> is optional.
If it is not mentioned, the process will be searched in the default LNT,
LOTOS, or FSP file assigned to the shell variable <B>DEFAULT_PROCESS_FILE</B>
on a shell line preceding the expression (see Section SHELL LINES). <P>
Note
that SVL relies uniquely on extensions to recognize file formats. All files
describing the behaviour of a system must therefore have a valid extension.

<H3><A NAME="sect8" HREF="#sect8">Stop</A></H3>
"stop" represents a Labelled Transition System which contains a single
state and no transitions.  
<H3><A NAME="sect9" HREF="#sect9">Hiding</A></H3>
<PRE>["total" | "partial" | "gate"] "hide" ["all" "but"] [TL] "in"
   B
["end" "hide"]
</PRE>and <PRE>["total" | "partial" | "gate"] "hide" "using" F "in"
   B
["end" "hide"]
</PRE>will hide the labels found in <I>B</I> using the given hiding rules. These rules
can be specified either as a list <I>TL</I> of (possibly typed) labels (first
form), or using an external file <I>F</I> (second form). <P>
In the first case, the
types (usually channel names defined in an LNT program) are purely ignored.
SVL builds a temporary file with extension <B>.hid</B>, filled with the given labels.
In the second case, the hide file must be provided by the user, with extension
<B>.hide</B> or <B>.hid</B>. <P>
A label can be a gate (possibly followed by experiment offers)
or a regular expression denoting a gate (possibly followed by experiment
offers). For instance, "G", "G.*", "G !1", "G. !.*" are labels. Among them,
only "G" is a gate. A channel name can be any LNT identifier (see &lt;lnt-identifier&gt;
in Section BEHAVIOUR EXPRESSIONS above), or any string between double quotes.
<P>
Double quotes around a label can be omitted if and only if the label is
a gate (therefore, the syntax of the LOTOS hiding operator is accepted
as a particular case of the more general SVL hiding operator). However,
for compatibility with LOTOS syntax, gates that are not enclosed between
quotes are systematically turned to uppercase, unless the <B>-case</B> option of
<A HREF="svl.html"><B>svl</B></A>
 is used. Note that double quotes are mandatory to avoid syntactic
ambiguities when a gate has the same name as a reserved SVL keyword (e.g.
"reduction", "all", etc.). They are also mandatory to enable the use of shell
variables denoting gates or labels as described in Section USING SHELL
VARIABLES IN EXPRESSIONS. <P>
The "all but" keywords modify the semantics of
the hiding rules: all the labels, except the labels specified in list <I>TL</I>,
are hidden in the given behaviour. <P>
The keywords "total", "partial", and
"gate" modify the matching mode, that is the way the hiding rules are interpreted,
see the <A HREF="caesar_hide_1.html"><B>caesar_hide_1</B></A>
 manual page. If no matching mode is specified,
then the default is "gate", which implements the LOTOS hiding operator
(possibly extended by the use of regular expressions on gate names). <P>
For
every hiding with "gate" matching, SVL checks whether the gates to be hidden
have an appropriate syntax and emit a warning if they appear to contain
experiment offers (which is a common mistake for novice users). For instance,
 <PRE>        hide "G !1" 
</PRE>will trigger a warning message because of the occurence of "!1". <P>
<B>Examples</B>:
<BR>
<BR>
<PRE>        total hide "G"
</PRE>hides every label equal to "G", <BR>
<BR>
<PRE>        gate hide "G"
</PRE>hides every label whose gate is G, e.g., "G !1", "G !2", <BR>
<BR>
<PRE>        gate hide ".*G.*"
</PRE>hides every label whose gate contains the character G and <BR>
<BR>
<PRE>        partial hide "G"
</PRE>hides every label whose gate or offers contain the character G. <P>
See the
 <A HREF="bcg_labels.html"><B>bcg_labels</B></A>
 and  <A HREF="caesar_hide_1.html"><B>caesar_hide_1</B></A>
 man pages for more information
on the hide file format, and on the semantics of the different matching
modes. See the  <A HREF="regexp.html"><B>regexp</B></A>
 man page for information about the syntax
of regular expression.  
<H3><A NAME="sect10" HREF="#sect10">Cutting</A></H3>
<PRE>["total" | "partial" | "gate"] "cut" ["all" "but"] [TL] "in"
   B
["end" "cut"]
</PRE>and <PRE>["total" | "partial" | "gate"] "cut" "using" F "in"
   B
["end" "cut"]
</PRE>will cut the labels found in <I>B</I> using the given cutting rules. These rules
can be specified either as a list of (possibly typed) labels (first form),
or using an external file <I>F</I> (second form). <P>
In the first case, the types
(usually channel names defined in an LNT program) are purely ignored. SVL
builds a temporary file with extension <B>.cut</B>, filled with the given labels.
 In the second case, the cut file must be provided by the user, with extension
<B>.cut</B>. <P>
A label can be a gate (possibly followed by experiment offers) or a
regular expression denoting a gate (possibly followed by experiment offers).
For instance, "G", "G.*", "G !1", "G. !.*" are labels. Among them, only "G"
is a gate. A channel name can be any LNT identifier (see &lt;lnt-identifier&gt; in
Section BEHAVIOUR EXPRESSIONS above), or any string between double quotes.
<P>
Double quotes around a label can be omitted if and only if the label is
a gate. However, for compatibility with LOTOS syntax, gates that are not
enclosed between quotes are systematically turned to uppercase, unless
the <B>-case</B> option of <A HREF="svl.html"><B>svl</B></A>
 is used. Note that double quotes are mandatory
to avoid syntactic ambiguities when a gate has the same name as a reserved
SVL keyword (e.g. "reduction", "all", etc.). They are also mandatory to enable
the use of shell variables denoting gates or labels as described in Section
USING SHELL VARIABLES IN EXPRESSIONS. <P>
The "all but" keywords modify the
semantics of the cutting rules: all the labels, except the labels specified
in list <I>TL</I>, are cut in the given behaviour. <P>
The keywords "total", "partial",
and "gate" modify the matching mode, that is the way the cutting rules
are interpreted, see the <A HREF="exp.open.html"><B>exp.open</B></A>
 manual page. If no matching mode
is specified, then the default is "gate". <P>
For every cutting with "gate"
matching, SVL checks whether the gates to be cut have an appropriate syntax
and emit a warning if they appear to contain experiment offers (which is
a common mistake for novice users). For instance,  <PRE>        cut "G !1"
</PRE>will trigger a warning message because of the occurence of "!1". <P>
<B>Examples</B>:
<P>
<PRE>        total cut "G"
</PRE>cuts every label equal to "G", <BR>
<BR>
<PRE>        gate cut "G"
</PRE>cuts every label whose gate is G, e.g., "G !1", "G !2", <BR>
<BR>
<PRE>        gate cut ".*G.*"
</PRE>cuts every label whose gate contains the character G and <BR>
<BR>
<PRE>        partial cut "G"
</PRE>cuts every label whose gate or offers contain the character G. <P>
See the 
<A HREF="exp.open.html"><B>exp.open</B></A>
 man page for more information on the cut file format, and
on the semantics of the different matching modes. See the  <A HREF="regexp.html"><B>regexp</B></A>

man page for information about the syntax of regular expression. <P>
 
<H3><A NAME="sect11" HREF="#sect11">Priority</A></H3>
<PRE>["total" | "partial" | "gate"] "prio"
   (["all" "but"] [LL] ("&gt;" ["all" "but"] [LL])+)+ "in" B
["end" "prio"]
</PRE>sets priorities between the transitions of <I>B</I>. In each state of <I>B</I>, a transition
may be executed only if all transitions of higher priority are not ready
for execution. <P>
Priorities between transitions (or equivalently, between
labels) are defined by a set of priority rules of the form <I>X1</I> &gt; ... &gt; <I>Xn</I>, where
each <I>Xi</I> (for <I>i</I> ranging in 1..n) has the form [all but] <I>LLi</I> and <I>LLi</I> is a list
of regular expressions denoting gates or labels. The "all but" keywords
that may precede some <I>LLi</I> means all gates or labels but those matching
<I>LLi</I>. <P>
Such priority rules define a transitive relation "&gt;&gt;" on labels as follows:

<UL>
<LI type=disc>if <I>X</I> &gt; <I>X'</I>, the visible label <I>L</I> of <I>B</I> matches <I>X</I>, and the visible label <I>L'</I> of
<I>B</I> matches <I>X'</I> then <I>L</I> &gt;&gt; <I>L'</I> </LI><P><LI type=disc>if <I>L</I> &gt;&gt; <I>L'</I> and <I>L'</I> &gt;&gt; <I>L''</I> then <I>L</I> &gt;&gt; <I>L''</I> </LI><P>
</UL>
<P>
<I>L</I> &gt;&gt; <I>L'</I> means that any transition
labeled <I>L</I> has priority over any transition labeled <I>L'</I> or, equivalently,
any transition labeled <I>L'</I> yields priority to any transition labeled <I>L</I>. <P>
The
relation "&gt;&gt;" must be a strict partial order: <I>B</I> must not contain any label
<I>L</I> such that <I>L</I> &gt;&gt; <I>L</I>. If "&gt;&gt;" is not a strict partial order, then the <B>exp.open</B>
tool will issue an error message and then exit. <P>
Beware that the rules <I>X</I>
&gt; <I>X'</I> and <I>X'</I> &gt; <I>X''</I> (which are equivalent to <I>X</I> &gt; <I>X'</I> &gt; <I>X''</I>) imply <I>X</I> &gt; <I>X''</I> only if some label
of <I>B</I> matches <I>X'</I>. Therefore, to avoid tricky errors, <B>exp.open</B> checks that every
individual regular expression <I>L</I> in <I>LL1</I>, ..., <I>LLn</I> matches some label of <I>B</I>. If
not, then <B>exp.open</B> will issue a warning. <P>
The optional "gate", "total", and
"partial" keywords define the matching mode, in the same way as for the
"hide" and "cut" operators. The matching mode by default is "gate". <P>
See the
 <A HREF="exp.open.html"><B>exp.open</B></A>
 manual page for details. <P>
<B>Examples</B>: <PRE>        gate prio
            "A.*" &gt; B &gt; all but "A.*", B
        in
            "f.bcg"
        end prio
</PRE>defines an LTS in which every transition whose gate starts with the letter
"A" has priority over every transition whose gate is "B", which themselves
have priority over all other transitions. <PRE>        partial prio
            "A" &gt; all but "A"
        in
            "f.bcg"
        end prio
</PRE>defines an LTS in which every transition whose label contains the letter
"A" has priority over every transition whose label does not contain the
letter "A" (including hidden transitions). <PRE>        total prio
            "A" &gt; "B" &gt; "C"
            "D" &gt; "E" &gt; "F"
            "A" &gt; "D"
            "B" &gt; "E"
            "C" &gt; "F"
        in
            "f.bcg"
        end prio
</PRE>defines an LTS in which: 
<UL>
<LI type=disc>A has priority over B, C, D, E, and F, </LI><P><LI type=disc>B has priority
over C, E, and F, </LI><P><LI type=disc>C has priority over F, </LI><P><LI type=disc>D has priority over E and F, and
</LI><P><LI type=disc>E has priority over F. </LI><P>
</UL>
<P>
Note: Strong bisimulation is a congruence for all
<B>svl</B> hiding, cutting, renaming, priority, and parallel composition operators
operators. However, branching, divbranching, observational, and safety equivalences
are congruences for all <B>svl</B> hiding, cutting, renaming, and parallel composition
operators, but not for priority. It should also be noted that tau*.a equivalence
is not a congruence for parallel composition.  
<H3><A NAME="sect12" HREF="#sect12">Renaming</A></H3>
<PRE>["total" | "single" | "multiple" | "gate"] "rename" RL "in"
   B
["end" "rename"]
</PRE>and <PRE>["total" | "single" | "multiple" | "gate"] "rename"
   "using" F "in" B
["end" "rename"]
</PRE>will rename the labels of <I>B</I> using the given renaming rules. These rules
can be specified either as a list of rules of the form <I>L1</I> "-&gt;" <I>L2</I>, where
<I>L1, L2</I> denote any labels (first form), or using an external file <I>F</I> (second
form).  <P>
In the first case SVL builds a temporary file with extension <B>.ren</B>,
filled with the given substitution rules. In the second case SVL uses the
given renaming file, whose extension must be <B>.ren</B> or <B>.rename</B>. <P>
A label can
be a gate (possibly followed by experiment offers) or a regular expression
denoting a gate (possibly followed by experiment offers). For instance,
"G", "G.*", "G !1", "G. !.*" are labels. Among them, only "G" is a gate. <P>
Double
quotes around a label can be omitted if and only if the label is a standard
LOTOS gate. However, for compatibility with LOTOS syntax, gates which are
not enclosed between quotes are systematically turned to uppercase, unless
the <B>-case</B> option of  <B>svl</B>(local) is used. Note that double quotes are mandatory
to avoid syntactic ambiguities when a gate has the same name as a reserved
SVL keyword (e.g. "reduction", "all", etc.) and that they enable the use of
shell variables denoting gates or labels as described in Section USING
SHELL VARIABLES IN EXPRESSIONS. <P>
The keywords "total", "single", "multiple",
and "gate" modify the way the left hand sides of the renaming rules are
interpreted, see the <A HREF="caesar_rename_1.html"><B>caesar_rename_1</B></A>
 manual page. If no matching
mode is specified, then the default is "gate". <P>
For every renaming with "gate"
matching, SVL checks whether the gates to be renamed have an appropriate
syntax and emit a warning if they appear to contain experiment offers (which
is a common mistake for novice users). For instance,  <PRE>        rename "G !1" -&gt; "G !2"
</PRE>will trigger a warning message because of the occurence of "!1". Note however
that  <PRE>        rename "G" -&gt; "G !1"
</PRE>is correct. <P>
<B>Examples</B>: <P>
<PRE>        total rename "G" -&gt; "H"
</PRE>renames to "H" every label equal to "G", <BR>
<BR>
<PRE>        gate rename "G" -&gt; "H"
</PRE>renames to "H" the gate of every label whose gate is G, e.g., "G !1", "G
!2", <BR>
<BR>
<PRE>        gate rename ".*G.*" -&gt; "H"
</PRE>renames to "H" the gate of every label whose gate contains a G, <BR>
<BR>
<PRE>        single rename "G" -&gt; "H"
</PRE>replaces the first occurrence of "G" by "H" in every label whose gate or
offers contain a G, <BR>
<BR>
<PRE>        multiple rename "G" -&gt; "H"
</PRE>replaces every occurrence of "G" by "H" in every label whose gate or offers
contain a G, and <BR>
<BR>
<PRE>        total rename "\([A-Z0-9]*\) \(!.*\)" -&gt; "\1 !1 \2"
</PRE>inserts "!1" between every gate and its first offer. <P>
See the  <A HREF="bcg_labels.html"><B>bcg_labels</B></A>

and <A HREF="caesar_rename_1.html"><B>caesar_rename_1</B></A>
 manual pages for more information on these options
and on the format of renaming rules. See also the  <A HREF="regexp.html"><B>regexp</B></A>
 manual
page for more information on regular expressions. 
<H3><A NAME="sect13" HREF="#sect13">Root Reduction</A></H3>
<PRE>"root" ["total" | "partial"]
   [E] ["probabilistic" | "stochastic"] "reduction"
   ["using" M] ["with" T] "of" B
</PRE>or more simply <PRE>["total" | "partial"]
   [E] ["probabilistic" | "stochastic"] "reduction"
   ["using" M] ["with" T] "of" B
</PRE>will generate the behaviour <I>B</I> (totally or partially) reduced modulo the
reduction relation <I>E</I>, and possibly taking into account the probabilistic
or stochastic information present in <I>B</I>. The reduction is done with the tool
<I>T</I> and using the method <I>M</I>. <P>
<I>T</I>, <I>M</I>, <I>E</I>, "total", "partial", "probabilistic",
and "stochastic" are optional: 
<UL>
<LI type=disc>Partial reduction is an incomplete form
of reduction. Compared to total reduction, it generally generates a larger
LTS but in a shorter time. If the "total" or "partial" keyword is not specified,
then the reduction will be total. </LI><P><LI type=disc>The "probabilistic" and "stochastic" reductions
are only available for strong, branching, and divbranching bisimulations
with bcg_min and using the std method. In this case, the behaviour <I>B</I> must
denote an explicit LTS containing probabilistic or stochastic information.
See the  <A HREF="bcg_min.html"><B>bcg_min</B></A>
 manual page for more information. </LI><P><LI type=disc>The default value
for <I>E</I> is "strong" and can be changed via the shell variable <B>DEFAULT_REDUCTION_RELATION</B>.
 </LI><P><LI type=disc>The default value for <I>M</I> depends on the equivalence relation considered.
The shell variable <B>DEFAULT_REDUCTION_METHOD</B> can be set in the SVL file
to enforce a particular default value. </LI><P><LI type=disc>The default value for <I>T</I> depends on
the relation <I>E</I> and whether the reduction is partial or total, as summarized
in the following table: <P>
<PRE>+------------------+------------------+---------------+
| relation         |      total       |    partial    |
+------------------+------------------+---------------+
| strong           |     bcg_min      |   reductor    |
| strong stoch.    |     bcg_min      | not available |
| strong prob.     |     bcg_min      | not available |
| tau-divergence   | reductor+bcg_min |   reductor    |
| tau-compression  | reductor+bcg_min |   reductor    |
| tau-confluence   | reductor+bcg_min |   reductor    |
| branching        |     bcg_min      | not available |
| branching stoch. |     bcg_min      | not available |
| branching prob.  |     bcg_min      | not available |
| divbranching     |     bcg_min      | not available |
| divbr. stoch.    |     bcg_min      | not available |
| divbr. prob.     |     bcg_min      | not available |
| observational    |   aldebaran      | not available |
| tau*.a           | reductor+bcg_min |   reductor    |
| safety           | reductor+bcg_min |   reductor    |
| trace            | reductor+bcg_min |   reductor    |
| weak trace       | reductor+bcg_min |   reductor    |
+------------------+------------------+---------------+
</PRE>where "<B>reductor</B>+<B>bcg_min</B>" means that the total <I>E</I> reduction is done by first
applying partial <I>E</I> reduction with <B>reductor</B>, followed by total strong reduction
with <B>bcg_min</B>. <P>
The shell variable <B>DEFAULT_REDUCTION_TOOL</B> can be set in the
SVL file to enforce a particular default value for <I>T</I>. </LI><P>
</UL>
<P>
 <B>Example:</B> <PRE>% DEFAULT_REDUCTION_TOOL="reductor"
% DEFAULT_REDUCTION_RELATION="tau*.a"
"a_red.aut" = total reduction of "a.aut"
</PRE><P>
will induce the total reduction modulo tau*.a of a.aut with <B>reductor</B>, and
store the result in file a_red.aut. <P>
When a combination of total/partial reduction,
tool, method, and relation is not available, SVL tries to change (at run-time)
some parameters to perform a (total or partial) reduction as close as possible
to what appears to be expected, trying to preserve the parameters in the
following priority order: stochastic or probabilistic reduction, reduction
relation, reduction tool, reduction method, and then total or partial reduction.
<P>
Moreover, if the reduction fails (for instance because of memory exhaustion)
then SVL tries to achieve it another way. For instance, using another tool,
or performing a reduction modulo a stronger equivalence relation to reduce
the size of the LTS to reducee before re-attempting the weaker reduction.
When all attempts fail, then the verification proceeds with the non reduced
behaviour. <P>
Note: In some versions of CADP, the <B>aldebaran.old</B> tool, which
performs "observational reduction", may be not available. If this is the
case, then SVL replaces "observational reduction" by "branching reduction"
(performed by the <B>bcg_min</B> tool) and issues a warning message. 
<H3><A NAME="sect14" HREF="#sect14">Leaf Reduction</A></H3>
<PRE>"leaf" ["total" | "partial"]
   [E] ["probabilistic" | "stochastic"] "reduction"
   ["using" M] ["with" T] "of" B
</PRE>is a meta-operator that will (totally or partially) reduce the LTSs generated
as components of <I>B</I>. As above, <I>T</I>, <I>M</I>, <I>E</I>, the "total" and "partial" keywords
and the "probabilistic" and "stochastic" keywords are optional parameters
(see <B>ROOT REDUCTION</B>). The final result of a "leaf reduction" is not necessarily
as small as that obtained with "root", "root leaf", and "node reduction"
since only components of <I>B</I> are reduced. <P>
The expansion rules of "leaf reduction"
are the following:  <PRE>leaf reduction of B = lRed (B)
lRed (B1 |op| B2) = lRed (B1) |op| lRed (B2)
lRed (Hide (X, B1 |op| B2)) = Hide (X, lRed (B1 |op| B2)) 
lRed (Hide (X, B)) = Red (Hide (X, lRed (B))) 
                     (other cases)
lRed (Cut (X, B1 |op| B2)) = Cut (X, lRed (B1 |op| B2)) 
lRed (Cut (X, B)) = Red (Cut (X, lRed (B))) 
                     (other cases)
lRed (Prio (X, B1 |op| B2)) = Prio (X, lRed (B1 |op| B2))
lRed (Prio (X, B)) = Red (Prio (X, lRed (B))) 
                     (other cases)
lRed (Ren (X, B1 |op| B2)) = Ren (X, lRed (B1) |op| lRed (B2))
lRed (Ren (X, B)) = Red (Ren (X, lRed (B)))
                     (other cases)
lRed (Abs (B1, X, B2)) = Red (Abs (B1, X, lRed(B2)))
lRed (Gen (B)) = Red (Gen (lRed (B)))
lRed (B) = Red (B) otherwise
</PRE>where Red means reduction, Ren means rename, Abs means abstraction or refined
abstraction (its first operand is the interface, and its third operand
is the body), Gen means generation, <I>B</I>, <I>B1</I>, <I>B2</I> denote any behaviour, <I>X</I> denotes
either a file or a list of items (labels or renaming rules), and |<I>op</I>| denotes
any parallel composition operator. <P>
Note that expansion does not propagate
meta-operations across "reduction" operations, nor inside the interface
part of the "abstraction" operation. <P>
Note also that, at the end of the expansion
phase, the obtained abstract tree is cleaned to optimize execution. Therefore
some "reduction" operators inserted by the lRed function are then removed
by the cleaning function. For instance, any "reduction" operation inserted
at the root of the body of an "abstraction" operation will be systematically
deleted to avoid the (useless and expensive) generation of the behaviour
to be abstracted. See Section CLEANING below. 
<H3><A NAME="sect15" HREF="#sect15">Root Leaf Reduction</A></H3>
<PRE>"root leaf" ["total" | "partial"]
   [E] ["probabilistic" | "stochastic"] "reduction"
   ["using" M] ["with" T] "of" B
</PRE>is a meta-operator, which has the same meaning as "root reduction of leaf
reduction of <I>B</I>". 
<H3><A NAME="sect16" HREF="#sect16">Node Reduction</A></H3>
<PRE>"node" ["total" | "partial"]
   [E] ["probabilistic" | "stochastic"] "reduction"
   ["using" M] ["with" T] "of" B
</PRE>is a meta-operator that will generate <I>B</I> in a compositional way. The only
difference between "root leaf" and "node reduction" is that "node reduction"
performs also reduction at each parallel composition node, and that hide
and cut operators are propagated as far as possible inside the behaviour
expression. As above, <I>T</I>, <I>M</I>, <I>E</I>, the "total" and "partial" keywords and the
"probabilistic" and "stochastic" keywords are optional parameters (see
<B>ROOT REDUCTION</B>). <P>
The expansion rules of "node reduction" are the following:
 <PRE>node reduction of B = Red (nRed (B))
nRed (B1 |op| B2) = Red (nRed (B1) |op| nRed (B2))
nRed (Hide (X, B)) = Red (Hide (X, nRed (B)))
nRed (Cut (X, B)) = Red (Cut (X, nRed (B)))
nRed (Prio (X, B)) = Red (Prio (X, nRed (B)))
nRed (Ren (X, B)) = Red (Ren (X, nRed (B)))
nRed (Abs (B1, X, B2)) = Red (Abs (B1, X, lRed (B2)))
nRed (Gen (B)) = Red (Gen (lRed (B)))
nRed (B) = Red (B) otherwise
</PRE>where Red means reduction, Ren means rename, Abs means abstraction or refined
abstraction (its first operand is the interface, and its third operand
is the body), Gen means generation, <I>B</I>, <I>B1</I>, <I>B2</I> denote any behaviour, <I>X</I> denotes
either a file or a list of items (labels or renaming rules), and |<I>op</I>| denotes
any parallel composition operator. <P>
Note that expansion does not propagate
meta-operations across "reduction" operations, nor inside the interface
part of the "abstraction" operation. The "node reduction" becomes a "leaf
reduction" (lRed) once it has passed through an "abstraction", "refined
abstraction", or "generation" operator. <P>
Note also that, at the end of the
expansion phase, the obtained abstract tree is cleaned to optimize execution.
Therefore some "reduction" operators inserted by the nRed function are
then removed by the cleaning function. For instance, any "reduction" operation
inserted at the root of the body of an "abstraction" operation will be
systematically deleted to avoid the (useless and expensive) generation
of the behaviour to be abstracted. See Section CLEANING below. 
<H3><A NAME="sect17" HREF="#sect17">Smart Reduction</A></H3>
<PRE>"smart" ["total" | "partial"]
   [E] ["probabilistic" | "stochastic"] "reduction"
   ["using" M] ["with" T] "of" B
</PRE>is an operator that will generate <I>B</I> in a compositional way using a smart
heuristic, the aim being to try to avoid generating too large intermediate
LTSs. <P>
To do so, <I>B</I> is first turned into a network whose LTSs are minimized.
Then, SVL executes the following loop until this network contains only
a single LTS: 
<DL><DD><DL COMPACT>

<DT>1</DT>
<DD>Automatically select several LTSs in the network; this step
relies on a heuristic metric (computed by exp2c) that depends on an estimate
rate of hidden transitions and an estimate rate of interleaved transitions
belonging to the product of selected LTSs. </DD><P>

<DT>2</DT>
<DD>Compose the selected LTSs in
parallel. </DD><P>

<DT>3</DT>
<DD>Generate the LTS corresponding to the composition obtained in
step 2 and minimize it. </DD><P>

<DT>4</DT>
<DD>Replace in the network the LTSs selected in step
1 by the LTS resulting from step 3; continue in step 1. </DD><P>
</DL></DD><P></DL>
<P>
The LTS corresponding
to the obtained network is finally generated, minimized, and returned as
the LTS corresponding to <I>B</I>. <P>
The maximal number of LTSs that can be selected
in step 1 is bounded. By default, the limit is set to 4. This limit can be
changed by assigning a different value to the variable <I>DEFAULT_SMART_LIMIT</I>.
<P>
Note: Unlike other meta-operations, "smart reduction" is not expanded. Indeed,
the expansion phase is static, whereas the order in which the LTSs in <I>B</I>
are composed by "smart reduction" is determined at run time. 
<H3><A NAME="sect18" HREF="#sect18">Generation</A></H3>
<PRE>"generation" "of" B
</PRE>will force the generation of an explicit LTS representation of <I>B</I>. More precisely,
if <I>B</I> is an LNT, LOTOS, or FSP program, this program will be compiled, and
if <I>B</I> has an implicit representation as a network of communicating automata
in the EXP format, then an explicit representation of <I>B</I> will be generated.
<P>
There are some cases where the "generation" operation is implicit: 
<UL>
<LI type=disc>generation
of the body of a "hide", "cut", or "rename" operation when it is a LNT,
LOTOS, or FSP file; </LI><P><LI type=disc>generation of the interface of an "abstraction" operation;
</LI><P><LI type=disc>generation of the body of a "reduction" operation; </LI><P>
</UL>
<P>
Note that, during the
expansion phase, meta-operators do not propagate across "generation" operations
in the abstract syntax tree. 
<H3><A NAME="sect19" HREF="#sect19">Parallel Composition</A></H3>
<PRE>B "||" B
</PRE>and <PRE>B "|||" B
</PRE>and <PRE>B "|[" [LL] "]|" B
</PRE>have the LOTOS semantics of parallel composition: "|||" denotes parallel composition
with synchronization on termination only, "||" denotes parallel composition
with synchronization on all gates, and at last "|[" [<I>LL</I>] "]|" denotes parallel
composition with synchronization on termination and on gates specified
in the optional list of labels <I>LL</I>. 
<H3><A NAME="sect20" HREF="#sect20">Generalized Parallel</A></H3>
<PRE>["label" | "gate"] "par" [("all" | LD) "in"]
   [LD "-&gt;"] B ("||" [LD "-&gt;"] B)+
"end par"
</PRE>is an extension of the E-LOTOS/LNT generalized parallel composition operator.
It denotes the concurrent execution of parallel behaviours following synchronisation
rules expressed using: 
<UL>
<LI type=disc>the keyword "all" or the list "<I>LD</I>" that follows
the keyword "par", called <I>global synchronisation interface</I>, and </LI><P><LI type=disc>the lists
<I>LD</I> that precede the symbols "-&gt;", called <I>local synchronisation interfaces</I>.
</LI><P>
</UL>
<P>
Synchronisation interfaces <I>LD</I> are lists of synchronisation elements of
the form <I>L</I> or <I>L#N</I>, where <I>L</I> is a gate or a label and <I>N</I> is a natural number
called <I>synchronisation degree</I>. <P>
The semantics of synchronisation rules are
defined in the following paragraphs. 
<UL>
<LI type=disc>The "gate" or "label" keywords indicate
the <I>synchronisation mode</I>, which influences the way synchronisation rules
apply to transition labels. We say that a transition matches a synchronisation
element of the form <I>L</I> or <I>L#N</I> in the following cases: <BR>
In "gate" synchronisation mode, a transition matches <I>L</I> or <I>L#N</I> if the gate
of the transition label is <I>L</I>. Therefore, for every synchronisation element
of the form <I>L</I> or <I>L#N</I> occurring in a synchronisation interface, <I>L</I> must be
a gate without offers. <BR>
In "label" synchronisation mode, a transition matches <I>L</I> or <I>L#N</I> if the transition
label is <I>L</I>. Therefore, for every synchronisation element of the form <I>L</I> or
<I>L#N</I> occurring in a synchronisation interface, <I>L</I> must be a full label (i.e.,
a gate possibly followed by offers). <BR>
Unlike "hide", "cut", and "rename", regular expressions are not allowed
in synchronisation elements. If not specified, the synchronisation mode
by default is "gate". </LI><P><LI type=disc>The keyword "all" is a shorthand notation for the
global synchronisation set consisting of all synchronisation elements <I>L</I>
(without degree) such that <I>L</I> is the gate (in "gate" synchronisation mode)
or the label (in "label" synchronisation mode) of a transition in at least
one of the parallel behaviours, except transitions carrying hidden events.
</LI><P>
</UL>
<P>
Synchronisation elements have the following meaning: 
<UL>
<LI type=disc>A synchronisation
element of the form <I>L</I> (without degree) occurring in the global synchronisation
interface indicates that all parallel behaviours may synchronize all together
on transitions that match <I>L</I>. </LI><P><LI type=disc>A synchronisation element of the form <I>L</I> (without
degree) occurring in a local synchronisation interface indicates that all
parallel behaviours that contain <I>L</I> in their synchronisation interface may
synchronize all together on transitions that match <I>L</I>. </LI><P><LI type=disc>A synchronisation
element of the form <I>L#N</I> occurring in the global synchronisation interface
indicates that <I>N</I> behaviours among the parallel behaviours may synchronize
together on transitions that match <I>L</I>. </LI><P><LI type=disc>A synchronisation element of the form
<I>L#N</I> occurring in a local synchronisation interface indicates that <I>N</I> behaviours
among the parallel behaviours that contain <I>L#N</I> in their synchronisation
interface may synchronize on transitions that match <I>L</I>. </LI><P><LI type=disc>A transition in a
parallel behaviour may execute asynchronously if both the global synchronization
interface and the local synchronization interface of that behaviour do
not contain any element of the form <I>L</I> or <I>L#N</I> such that the transition matches
<I>L<B>. </LI><P>
</UL>
<P>
Note that both the global synchronisation interface and local synchronisation
interfaces may contain several synchronisation elements with same label
<I>L</I></B></I> but different synchronisation degrees. In this case, the corresponding
synchronisation rules apply nondeterministically. <P>
Following the above meaning
of synchronisation elements, it is possible to prevent the execution of
particular transitions matching <I>L</I> by using synchronisation elements of
the form <I>L#0</I>, either in the global synchronisation interface (thus preventing
execution of transitions matching <I>L</I> in all parallel behaviours) or in local
synchronisation interfaces (thus preventing execution of transitions matching
<I>L</I> in those behaviours containing <I>L#0</I> in their interface), provided the
(global or local) interface does not contain another occurrence of <I>L</I> or
<I>L#N</I> with <I>N</I> a strictly positive number. <P>
Transition synchronisation is a generalization
of LOTOS rendezvous: synchronisation requires that all transitions have
exactly the same label (i.e., gate and possible offers), which is also the
label of the resulting transition. <P>
Note that synchronization interfaces
can neither contain the hidden gate nor the termination gate. Behaviours
always synchronize on labels whose gate is the termination gate and never
synchronize on hidden events. <P>
The following syntactic restrictions (checked
by <A HREF="exp.open.html"><B>exp.open</B></A>
)<B>should</B>hold: 
<UL>
<LI type=disc>If the global synchronisation interface contains
a synchronisation element of the form <I>L#N</I> with <I>N</I> &gt; 0, then the parallel
composition must contain at least <I>N</I> parallel behaviours. </LI><P><LI type=disc>If the global synchronisation
interface contains a synchronisation element of the form <I>L#0</I>, then no synchronisation
element of the form <I>L</I> or <I>L#N</I> with same <I>L</I> and <I>N</I> &gt; 0 should occur in the global
synchronization interface or in any local synchronization interface. </LI><P><LI type=disc>If
a local synchronisation interface contains a synchronisation element of
the form <I>L</I> (without degree), then at least two local synchronisation interfaces
(this one included) should contain the same synchronisation element. </LI><P><LI type=disc>If
a local synchronisation interface contains a synchronisation element of
the form <I>L#N</I> with <I>N</I> &gt; 0, then at least <I>N</I> local synchronisation interfaces
(this one included) should contain the same synchronisation element. </LI><P><LI type=disc>If
a local synchronisation interface contains a synchronisation element of
the form <I>L#0</I>, then no synchronisation element of the form <I>L</I> or <I>L#N</I> with
same <I>L</I> and <I>N</I> &gt; 0 should occur in the global synchronization interface or
in the same local synchronization interface. </LI><P>
</UL>
<P>
 
<H3><A NAME="sect21" HREF="#sect21">Abstraction</A></H3>
<PRE>["total" | "partial" | "gate"] ["user"] "abstraction" B
   "sync" [LL] "of" B
</PRE>and <PRE>["total" | "partial" | "gate"] ["user"] "abstraction" B
   "sync" "using" F "of" B
</PRE>and <PRE>["total" | "partial" | "gate"] ["user"] "abstraction" B
   "of" B
</PRE>denote abstraction using an interface, also called semi-composition. It allows
to restrict the rightmost behaviour with respect to its environment i.e.,
an expression called the interface and a synchronization set. <P>
Interfaces
can be either ``exact'' interfaces i.e., parts of the syntactic environment of
the sub-expression to be restricted, or ``user-given'' interfaces i.e., expressions
that are supposed to correctly approximate this environment. The second
case must be expressed with the "user" keyword that involves the generation
of some validation predicates in the produced LTS. These predicates are
checked afterwards, when the components obtained by user abstractions are
recomposed together. SVL issues a warning message if the check fails. <P>
Similarly
to hide, cut, and rename operators, the synchronization set can be given
explicitly as a list of labels in the abstraction expression, or in a <B>.sync</B>
file. See the  <A HREF="projector.html"><B>projector</B></A>
 manual page for more information on the
sync file format. <P>
A label can be a gate (possibly followed by experiment
offers) or a regular expression denoting a gate (possibly followed by experiment
offers). For instance, "G", "G.*", "G !1", "G. !.*" are labels. Among them,
only "G" is a gate. <P>
Double quotes around a label can be omitted if and only
if the label is a gate . However, gates that are not enclosed between quotes
are systematically turned to uppercase, unless the <B>-case</B> option of <A HREF="svl.html"><B>svl</B></A>

is used. Note that double quotes are mandatory to avoid syntactic ambiguities
when a gate has the same name as a reserved SVL keyword (e.g. "reduction",
"all", etc.). They are also mandatory to enable the use of shell variables
denoting gates or labels as described in Section USING SHELL VARIABLES
IN EXPRESSIONS. <P>
The "all but" keywords modify the semantics of the synchronization
rules: all the labels, except the labels specified in list <I>LL</I>, must be
used in the synchronization between the given behaviour and its interface.
<P>
The keywords "total", "partial", and "gate" modify the matching mode, that
is the way the synchronization rules are interpreted, see the <A HREF="projector.html"><B>projector</B></A>

manual page. If no matching mode is specified, then the default is "gate".
<P>
If no synchronization set is given (no "sync" keyword), the synchronization
is done as follows: 
<UL>
<LI type=disc>In "gate" matching mode, synchronization is done on
all gates visible in the interface. </LI><P><LI type=disc>In "total" or "partial" matching mode,
synchronization is done on all labels visible in the interface. </LI><P>
</UL>
<P>
For every
abstraction with "gate" matching, SVL checks whether the gates to be synchronized
have an appropriate syntax and emit a warning if they appear to contain
experiment offers (which is a common mistake for novice users). For instance,
 <PRE>        abstraction ... sync "G !1"
</PRE>will trigger a warning message because of the occurence of "!1". <P>
<B>Examples</B>:
<P>
<PRE>        total abstraction ... sync "G"
</PRE>synchronizes every label equal to "G", <BR>
<BR>
<PRE>        gate abstraction ... sync "G"
</PRE>synchronizes every label whose gate is G, e.g., "G !1", "G !2", <BR>
<BR>
<PRE>        gate abstraction ... sync ".*G.*"
</PRE>synchronizes every label whose gate contains the character G and <BR>
<BR>
<PRE>        partial abstraction ... sync "G"
</PRE>synchronizes every label whose gate or offers contain the character G. <P>
See
the  <A HREF="projector.html"><B>projector</B></A>
 man page for more information on the sync file format,
and on the semantics of the different matching modes. See the  <A HREF="regexp.html"><B>regexp</B></A>

man page for information about the syntax of regular expression. <P>
Before
doing the semi-composition, SVL does the following to optimize verification
efficiency: 
<UL>
<LI type=disc>It hides in the interface all gates or labels (depending on
the matching mode), except those which are in the synchronization list.
</LI><P><LI type=disc>It reduces the interface modulo safety equivalence.  </LI><P>
</UL>

<H3><A NAME="sect22" HREF="#sect22">Infix Abstraction Operators</A></H3>
<PRE>B1 "-||" ["?"] B2
</PRE>and <PRE>B1 "-|||" ["?"] B2
</PRE>and <PRE>B1 "-|[" [LL] "]|" ["?"] B2
</PRE>are shorthand notations for, respectively,  <PRE>["user"] "abstraction" B2 "of" B1
</PRE>and <PRE>["user"] "abstraction" B2 "sync" "of" B1
</PRE>and <PRE>["user"] "abstraction" B2 "sync" [LL] "of" B1
</PRE>where the "?" symbol has the same meaning as the "user" keyword. 
<H3><A NAME="sect23" HREF="#sect23">Refined
Abstraction</A></H3>
<PRE>"refined" ["user"] "abstraction" LL ["using" B] "of" B
</PRE>allows to restrict the rightmost behaviour expression (the <I>body</I>) with respect
to some of its neighbours (specified in the list <I>LL</I>). <P>
The neighbours are
those behaviour systems (LTS files, files containing networks of LTSs,
LNT, LOTOS, or FSP files, or processes in LNT, LOTOS, or FSP files) that
are in the environment of (i.e., composed in parallel with) the body. The
identifier of a neighbour is either its process name (without offer parameters)
in the case of a process, or its filename (with extension and between quotes)
in all other cases. Each label in <I>LL</I> must be the identifier of exactly one
neighbour (see examples below). <P>
The behaviour expression that follows the
"using" keyword, if present, should provide a set of labels, which includes
all labels that can be fired by the body. Its states and transitions are
simply ignored. These labels allow to compute the possible synchronizations
between the body and its environment, without having to generate the LTS
corresponding to the body. This expression is required if the body is an
LNT, LOTOS, or FSP file or a process in an LNT, LOTOS, or FSP file and
can be omitted otherwise. If the body is a parallel composition expression
(encoded in an EXP file) or an EXP file, this set is computed automatically
using the <A HREF="exp.open.html"><B>exp.open</B></A>
 tool. If the body is neither an LNT, LOTOS, or
FSP file, a process in an LNT, LOTOS, or FSP file, a parallel composition
expression, nor an EXP file, then its LTS is generated and serves as label
set. <P>
The "user" keyword should be used when the user cannot guarantee that
the label set provided by this expression includes all labels that can
be fired by the body. In this case, validation predicates will be generated
in the resulting LTS, and warning messages will be issued if the validation
predicates are not satisfied. <P>
Refined abstraction executes in two steps:
in a first step, an interface and a synchronization set will be generated
automatically from the behaviours of neighbours and the environment of
the expression, using the <A HREF="exp.open.html"><B>exp.open</B></A>
 tool; during this step, the LTSs
of neighbours in <I>LL</I> are automatically minimized modulo safety equivalence,
so as to generate as small an interface as possible;  in a second step,
the interface and synchronization set obtained during the first step are
used to restrict the body, using the <A HREF="projector.html"><B>projector</B></A>
 tool. <P>
<B>Examples:</B> <P>
The
following expressions are examples of correct usage of the "refined abstraction"
operator:  <PRE>"a.bcg" = node strong reduction of
  (
    P
  ||
    (
      (refined abstraction P, "r.bcg" using "q.bcg" of Q)
    ||
      hide A in "r.bcg"
    )
  )
</PRE> <PRE>"a.bcg" = generation of
  (
    P
  ||
    (
      refined abstraction P of
        (
          Q
        ||
          (refined abstraction P, Q using "r.bcg" of R)
        )
    )
  )
</PRE><P>
The following expression is an example of incorrect usage of the "refined
abstraction" operator, where Q has two neighbours whose identifier is P,
and no neighbour whose identifier is R:  <PRE>"a.bcg" = generation of
  (
    P
  ||
    (
      (refined abstraction P, R using "q.bcg" of Q)
    ||
      hide A in P
    )
  )
</PRE>
<H3><A NAME="sect24" HREF="#sect24">Chaos Automata</A></H3>
<PRE>"chaos" "using" F
</PRE>and <PRE>"chaos" "with" LL
</PRE>and <PRE>"chaos" "with" n "labels" LP
</PRE>generate an LTS with a single state and looping transitions, using the
bcg_graph tool. <P>
There are several ways to define the transition labels:

<UL>
<LI type=disc>Using a file <I>F</I> (first form): <I>F</I> must be the full name of an existing file,
no particular extension being required. Each label in <I>F</I> must be written
on a separate line, and may be enclosed in double quotes that are removed
in the generated LTS. </LI><P><LI type=disc>Using a label list <I>LL</I> (second form): <I>LL</I> is a list
of any length. In this case, SVL generates a temporary file used by bcg_graph.
</LI><P><LI type=disc>Using a label pattern <I>LP</I> and a number <I>n</I> (third form): <I>LP</I> must be enclosed
between double quotes and contain exactly one occurrence of the substring
"%d". This pattern denotes exactly <I>n</I> different labels, obtained by replacing
the occurrence of "%d" by numbers in the range 1..<I>n</I>. <I>n</I> must be a natural number
(sequence of digits), possibly enclosed between double quotes. It can also
be defined using a shell variable (in which case double quotes are mandatory),
such as e.g., "$N" and "${N}0". </LI><P>
</UL>
<P>
See the  <A HREF="bcg_graph.html"><B>bcg_graph</B></A>
 manual page for
more information. <P>
<B>Example:</B> <P>
If "labels" is a file containing three labels
A1, A2, and A3, then the following three behaviours denote the same explicit
LTS that contains a unique state and three transitions from and to this
state, labelled respectively A1, A2, and A3. <P>
<PRE>    chaos using "labels"
    chaos with 3 labels "A%d"
    chaos with "A1", "A2", "A3"
</PRE>
<H3><A NAME="sect25" HREF="#sect25">Bags and Fifo Buffers</A></H3>
<PRE>"bag" m "using" F
</PRE>and <PRE>"bag" m "with" LL
</PRE>and <PRE>
"bag" m "with" n "labels" LP1 "," LP2
</PRE>and <PRE>"fifo" m "using" F
</PRE>and <PRE>"fifo" m "with" LL
</PRE>and <PRE>"fifo" m "with" n "labels" LP1 "," LP2
</PRE>generate an LTS modeling a communication buffer of size <I>m</I>, which can be
either a bag (i.e., a communication buffer in which the ordering of messages
is not enforced) or a FIFO (First In/First Out) buffer. <P>
<I>m</I> must be a natural
number (sequence of digits), possibly enclosed between double quotes. it
can also be defined using shell variables (in which case double quotes
are mandatory), such as e.g., "$N" and "${N}0". <P>
Buffers distinguish between
two kinds of labels, namely <I>inputs</I> and <I>outputs</I>, modeling respectively the
ingoing and outgoing messages. Each <I>input</I> is paired with the corresponding
<I>output</I>. <P>
There are several ways to define the labels handled by the buffer:

<UL>
<LI type=disc>Using a file <I>F</I> (first and fourth forms): <I>F</I> must be the full name of an
existing file, no particular extension being required. Each label in file
<I>F</I> must be written on a separate line, and may be enclosed in double quotes
that are removed in the generated LTS. Labels occurring in odd (respectively
even) positions in the file denote <I>inputs</I> (respectively <I>outputs</I>). Each <I>input</I>
is paired with the following <I>output</I> label in the file. </LI><P><LI type=disc>Using a label list
<I>LL</I> (second and fifth forms): <I>LL</I> is a list of even length.  Labels occurring
in odd (respectively even) positions in the list denote <I>inputs</I> (respectively
<I>outputs</I>). Each <I>input</I> is paired with the following <I>output</I> in the label list.
In this case, SVL generates a temporary label file used by bcg_graph. </LI><P><LI type=disc>Using
two label patterns <I>LP1</I>, <I>LP2</I> and a number <I>n</I> (third and sixth forms): Each
of <I>LP1</I> and <I>LP2</I> must be enclosed between double quotes and contain exactly
one occurrence of the substring "%d". These patterns denote exactly 2<I>n</I> different
labels, obtained by replacing the occurrences of "%d" by numbers in the
range 1..<I>n</I>. <I>LP1</I> (respectively <I>LP2</I>) defines the form of <I>inputs</I> (respectively
<I>outputs</I>). <I>inputs</I> and <I>outputs</I> are paired when they are obtained by instanciating
<I>LP1</I> and <I>LP2</I> with the same number. <I>n</I> must be a natural number (sequence of
digits), possibly enclosed between double quotes. It can also be defined
using shell variables (in which case double quotes are mandatory), such
as e.g., "$N" and "${N}0". </LI><P>
</UL>
<P>
See the <A HREF="bcg_graph.html"><B>bcg_graph</B></A>
 manual page for more information.
<P>
<B>Example:</B> <P>
If "labels" is a file containing four labels INPUT1, INPUT2, OUTPUT1,
and OUTPUT2, then the following three behaviours denote the same explicit
LTS that models a FIFO buffer with 4 places and exchanging 2 different
messages. <P>
<PRE>    fifo 4 using "labels"
    fifo 4 with 2 labels "INPUT%d", "OUTPUT%d"
    fifo 4 with "INPUT1", "OUTPUT1", "INPUT2", "OUTPUT2"
</PRE><P>
 
<H3><A NAME="sect26" HREF="#sect26">Cleaning</A></H3>
Since the expansion phase may generate some redundant operations,
the tree of the behaviour is always cleaned using the following clean function:
 <PRE>clean (Gen (Gen (B))) = clean (Gen(B))
clean (Gen (SPEC)) =
        Gen (SPEC) if LNT, LOTOS, FSP, or EXP
        SPEC       otherwise
clean (Gen (Stop)) = Stop
clean (Gen (Abs (B1, L, B2))) = clean (Abs(B1, L, B2))
clean (Gen (Red (B))) = clean (Red (B))
clean (Gen (B)) = Gen (clean (B))
clean (Hide (L, Hide (L', B)) = clean (Hide (L u L', B))
                          if matching modes are the same
clean (Hide (X, Stop)) = Stop
clean (Hide (X, B)) = Hide (X, clean (B))
clean (Cut (L, Cut (L', B)) = clean (Cut (L u L', B))
                          if matching modes are the same
Clean (Cut (L, Stop)) = Stop
clean (Cut (X, B)) = Cut (X, clean (B))
clean (Prio (X, B)) = Prio (X, clean (B))
clean (B1 |op| B2) = clean (B1) |op| clean (B2)
clean (Abs (Stop, L, B2)) = Stop
clean (Abs (B1, L, B2)) = Abs (clean (B1), L, clean (B2))
clean (Red (Red' (B))) = clean (Red' (B)) if Red' &lt;= Red
clean (Red (Gen (Red (B)))) = clean (Red (Gen (B)))
clean (Red (Abs (B1, L, Red (B2)))) = 
                              clean (Red (Abs (B1, L, B2)))
clean (Red (Hide (L, Red (B)))) = clean (Red (Hide (L, B)))
clean (Red (Cut (L, Red (B)))) = clean (Red (Cut (L, B)))
clean (Red (Ren (X, Red (B)))) = clean (Red (Ren (X, B)))
clean (Red (Stop)) = Stop
clean (Red (B)) = Red (clean (B))
clean (Ren (X, Stop)) = Stop
clean (Ren (X, B)) = Ren (X, clean (B))
clean (B) = B otherwise
</PRE>where Red &lt;= Red' means Red denotes reduction modulo a weaker (&lt;) or equal
(=) reduction relation than this of Red'. The "weaker" (partial order) relation
is represented by the diagram below, where an arrow goes from R to R' if
R' &lt; R:  <PRE>
                   strong
                      |
                +-----+-----+
                |           |
                |     tau-divergence --------+
                |           |                |
                |     tau-compression        |
                |           |          divbranching
                |     tau-confluence         |
                |           |                |
              trace     branching -----------+
                |           |
                |      +----+----+
                |      |         |
                |   tau*.a  observational
                |      |         |
                |      +----+----+
                |           |
                |        safety
                |           |
                +-----+-----+
                      |
                  weak trace
</PRE>
<H2><A NAME="sect27" HREF="#sect27">Semantics of Statements</A></H2>
The semantics of statements is defined as follows:

<H3><A NAME="sect28" HREF="#sect28">Assignment</A></H3>
<PRE>F "=" B
</PRE>will store in file <I>F</I> the system resulting from the behaviour expression
<I>B</I>, with possibly format conversion. <I>F</I> is created in the current directory.
 <P>
The file format of <I>F</I> can be LOTOS (extension <B>.lotos</B> or <B>.lot</B>), BCG (extension
<B>.bcg</B>), AUT (extension <B>.aut</B>), SEQ (extension <B>.seq</B>), FC2 (extension <B>.fc2</B>), or
EXP (extension <B>.exp</B>). The following rules apply: 
<UL>
<LI type=disc>If the file format of <I>F</I>
is LOTOS, then <I>B</I> must be an LNT file (extension <B>.lnt</B>). In this case, the
LOTOS file <I>F</I> is the result of translating the LNT file <I>B</I> into LOTOS using
<B>lnt.open</B>. Note that <I>F</I> can only be overwritten by a subsequent assignment
statement having explicitly <I>F</I> as left-hand side. Therefore, an error message
will be issued and the script execution will be stopped if an attempt is
made at overwriting <I>F</I> in another way, i.e., if an LNT file with same prefix
as <I>F</I> is used in subsequent behaviour expressions. </LI><P><LI type=disc>If <I>B</I> is an LNT, LOTOS,
or FSP file, or if <I>B</I> is a network of communicating automata (parallel composition
expression) and the format of <I>F</I> is this of an explicit LTS, then SVL issues
a warning message since the behaviour <I>B</I> should be generated before being
assigned. However, the generation is done automatically by SVL. </LI><P>
</UL>
<P>
Assignment
to EXP files must be used cautiously, as shows the following example. <P>
Consider
the following program, where <CODE>&lt;B1&gt;</CODE>, <CODE>&lt;B2&gt;</CODE>, and <CODE>&lt;B3&gt;</CODE> are arbitrary behaviours. <PRE>"a.bcg" = &lt;B1&gt;;
"c.bcg" = &lt;B2&gt;;
"b.exp" = "a.bcg" ||| "c.bcg";
"a.bcg" = &lt;B3&gt;;
"d.bcg" = generation of "b.exp"
</PRE>It must be clear that the automaton described in "d.bcg" represents the
behaviour <CODE>&lt;B3&gt; ||| &lt;B2&gt;</CODE> instead of <CODE>&lt;B1&gt; ||| &lt;B2&gt;</CODE> since at the time "b.exp" is evaluated,
"a.bcg" is bound to <CODE>&lt;B3&gt;</CODE>. <P>
On the contrary, in the following program, <PRE>"a.bcg" = &lt;B1&gt;;
"c.bcg" = &lt;B2&gt;;
"b.exp" = (reduction of "a.bcg") ||| "c.bcg";
"a.bcg" = &lt;B3&gt;;
"d.bcg" = generation of "b.exp"
</PRE>the automaton described in "d.bcg" represents the behaviour <CODE>(reduction of
&lt;B1&gt;) ||| &lt;B2&gt;</CODE>, since the reduction is evaluated at the time "b.exp" is created.

<H3><A NAME="sect29" HREF="#sect29">Comparison</A></H3>
<PRE>[F "="] [E] ["probabilistic" | "stochastic"] "comparison"
   ["using" M] ["with" T]
   B ("==" | "&lt;=" | "&gt;=") B
</PRE>allows to compare two behaviours. Symbol "==" means "equivalence" whereas
"&lt;=" and "=&gt;" denote relation pre-orders. The optional file <I>F</I> must have extension
<B>.aut</B>, <B>.bcg</B>, <B>.fc2</B>, or <B>.seq</B>. It is created in the current directory and may contain
a diagnostic of the comparison if the result is FALSE. <P>
Some combinations
of tool, method, and relation are not available. In this case, SVL tries
to change some parameters to perform a comparison as close as possible
to what seems to be expected. As much as possible, SVL tries to preserve
the parameters in the following priority order: relation, tool, and then
method. <P>
<I>T</I>, <I>M</I>, <I>E</I>, "probabilistic", and "stochastic" are optional: 
<UL>
<LI type=disc>The "probabilistic"
and "stochastic" comparisons are only available for strong, branching,
and divbranching bisimulations with bcg_cmp and using the std method. In
this case, the behaviours <I>B</I> must denote explicit LTSs containing probabilistic
or stochastic information. See the  <A HREF="bcg_cmp.html"><B>bcg_cmp</B></A>
 manual page for more
information. </LI><P><LI type=disc>The default value for <I>E</I> is "strong" and can be changed via
the shell variable <B>DEFAULT_COMPARISON_RELATION</B>.  </LI><P><LI type=disc>The default value for <I>M</I>
depends on the equivalence relation considered. The shell variable <B>DEFAULT_COMPARISON_METHOD</B>
can be set in the SVL file to enforce a particular default value. </LI><P><LI type=disc>The default
value for <I>T</I> depends on the type of comparison (pre-order or equivalence),
on the relation <I>E</I>, and on whether at least one behaviour <I>B</I> is an implicit
LTS or not. For pre-order comparisons, the default value for <I>T</I> is <I>bisimulator</I>.
For equivalence comparisons, the default value for <I>T</I> is determined as in
the following table: <P>
<PRE>+------------------+---------------+---------------+
| relation         | both explicit |   implicit    |
+------------------+---------------+---------------+
| strong           |    bcg_cmp    |  bisimulator  |
| strong stoch.    |    bcg_cmp    | not available |
| strong prob.     |    bcg_cmp    | not available |
| tau-divergence   |         not available         |
| tau-compression  |         not available         |
| tau-confluence   |         not available         |
| branching        |    bcg_cmp    |  bisimulator  |
| branching stoch. |    bcg_cmp    | not available |
| branching prob.  |    bcg_cmp    | not available |
| divbranching     |    bcg_cmp    | not available |
| divbr. stoch.    |    bcg_cmp    | not available |
| divbr. prob.     |    bcg_cmp    | not available |
| observational    |    bcg_cmp    | not available |
| tau*.a           |          bisimulator          |
| safety           |          bisimulator          |
| trace            |          bisimulator          |
| weak trace       |          bisimulator          |
+------------------+---------------+---------------+
</PRE><P>
If a relation is not available for implicit LTSs, then a warning is issued
and the LTSs are automatically converted into explicit LTSs. <P>
The shell variable
<B>DEFAULT_COMPARISON_TOOL</B> can be set in the SVL file to enforce a particular
default value for <I>T</I>. </LI><P>
</UL>

<H3><A NAME="sect30" HREF="#sect30">Verification</A></H3>
<PRE>[F1 "="] "verify" F2 ["using" M] ["with" T] "in" B
</PRE>allows to evaluate a formula on a behaviour, with <A HREF="evaluator3.html"><B>evaluator3</B></A>
, <A HREF="evaluator4.html"><B>evaluator4</B></A>
,
<A HREF="evaluator5.html"><B>evaluator5</B></A>
, or <A HREF="xtl.html"><B>xtl</B></A>
, and using method <I>M</I>. The formula must be
written in file <I>F2</I>, either in MCL (Model Checking Language) version 3 (regular
alternation-free mu-calculus, see the <A HREF="mcl3.html"><B>mcl3</B></A>
 manual page), in MCL version
4 (value-passing modal mu-calculus, see the <A HREF="mcl4.html"><B>mcl4</B></A>
 manual page), in
MCL version 5 (probabilistic value-passing modal mu-calculus, see the <A HREF="mcl5.html"><B>mcl5</B></A>

manual page), or in XTL (eXecutable Temporal Language, see the <A HREF="xtl-lang.html"><B>xtl-lang</B></A>

manual page). If the formula is written in (dataless or full) MCL, then
the file <I>F2</I> must have extension <B>.mcl</B>. If the formula is written in XTL, then
the file <I>F2</I> must have extension <B>.xtl</B>. <P>
The "with <I>T</I>" clause is optional. <I>T</I> may
be one of "evaluator3" (corresponding to the tool <A HREF="evaluator3.html"><B>evaluator3</B></A>
), "evaluator4"
(corresponding to the tool <A HREF="evaluator4.html"><B>evaluator4</B></A>
), "evaluator5" (corresponding
to the tool <A HREF="evaluator5.html"><B>evaluator5</B></A>
), "evaluator" (corresponding to the tool
<A HREF="evaluator.html"><B>evaluator</B></A>
),<B>or</B> "xtl" (corresponding to the tool <A HREF="xtl.html"><B>xtl</B></A>
). See <A HREF="evaluator.html"><B>evaluator</B></A>

for details on the differences between "evaluator", "evaluator3", "evaluator4",
and "evaluator5". <P>
If the "with <I>T</I>" clause is not present, then: 
<UL>
<LI type=disc>If the file
<I>F2</I> has extension <B>.xtl</B>, then the tool is <B>xtl</B>. </LI><P><LI type=disc>If the file <I>F2</I> has extension
<B>.mcl</B>, then the tool is given by the shell variable <B>DEFAULT_VERIFY_TOOL</B>,
which is set to "evaluator" by default. Note that in this case, <B>DEFAULT_VERIFY_TOOL</B>
should not have value "xtl". If the file <I>F2</I> has extension <B>.xtl</B>, then the
value of the shell variable <B>DEFAULT_VERIFY_TOOL</B> is irrelevant. </LI><P>
</UL>
<P>
The "using
<I>M</I>" clause is optional, and irrelevant in the case of an XTL formula. In
the case of an MCL formula, <I>M</I> may be one of "dfs", "bfs", or "acyclic".
See the <A HREF="evaluator.html"><B>evaluator</B></A>
, <A HREF="evaluator3.html"><B>evaluator3</B></A>
, <A HREF="evaluator4.html"><B>evaluator4</B></A>
, or <A HREF="evaluator5.html"><B>evaluator5</B></A>

manual pages for details about these methods. If the "using <I>M</I>" clause is
not present, then the method is given by the shell variable <B>DEFAULT_VERIFY_METHOD</B>,
which is set to "dfs" by default. <P>
File <I>F1</I> is optional and must have extension
<B>.aut</B>, <B>.bcg</B>, <B>.fc2</B>, or <B>.seq</B>. If present, it will contain a diagnostic of the verification
in the case of an MCL formula. It is irrelevant in the case of an XTL formula,
since the tool <B>xtl</B> does not generate counter-examples. 
<H3><A NAME="sect31" HREF="#sect31">Verification of Inline
Formulas</A></H3>
<PRE>[F "="] B "|=" ["using" M] ["with" T] formula ";"
</PRE>is similar to "verify" (see Section VERIFICATION for details), except that
the formula is not stored in a file, but inlined in the SVL script. <P>
The
formula (defined by symbol <I>formula</I> in the syntax above) is defined as the
sequence of characters starting from the first character following "|="
(or following the optional "using <I>M</I>" and "with <I>T</I>", if any, where <I>M</I> ranges
over "std", "dfs", "bfs", and "acyclic", and <I>T</I> ranges over "evaluator",
"evaluator3", "evaluator4", "evaluator5", and "xtl") and ending at the
last character preceding the next ";", including all spaces and comments.
Therefore, ";" must be present at the end of this statement, even if it
is the last statement of the SVL script. <P>
MCL or XTL libraries can be included
by default in the formulas, by using the variables <B>DEFAULT_MCL_LIBRARIES</B>
(libraries included by default in all MCL formulas), <B>DEFAULT_EVALUATOR3_LIBRARIES</B>
(libraries included by default in dataless MCL formulas checked by <A HREF="evaluator3.html"><B>evaluator3</B></A>
),
<B>DEFAULT_EVALUATOR4_LIBRARIES</B> (libraries included by default in full  MCL
formulas checked by <A HREF="evaluator4.html"><B>evaluator4</B></A>
), <B>DEFAULT_EVALUATOR5_LIBRARIES</B> (libraries
included by default in full  MCL formulas checked by <A HREF="evaluator5.html"><B>evaluator5</B></A>
),
and <B>DEFAULT_XTL_LIBRARIES</B> (libraries included by default in all XTL formulas).
These variables may be either empty, or contain a list of MCL or XTL library
names (with extensions) separated by commas. They are initially empty, meaning
that no library is included by default. <P>
The formula (together with its included
libraries) is stored in an intermediate file and parsed by the appropriate
tool only during script execution. Therefore, syntactic errors in the formula
(or in the included libraries) will be detected only at runtime, details
being reported in the log file. <P>
If the "with <I>T</I>" clause is absent, then the
tool is given by the shell variable <B>DEFAULT_VERIFY_TOOL</B>, which is set to
"evaluator" by default. Therefore, by default the formula is supposed to
be a dataless MCL formula. <P>
Note that shell variables are substituted in
formulas. <P>
<B>Examples:</B> <P>
<PRE>% ACTION=A
"diag.bcg" = "model.lnt" |= using dfs &lt; '$ACTION' &gt; true;
% DEFAULT_XTL_LIBRARIES="actl.xtl"
"model.bcg" |= with xtl
     let PUT : labelset = EVAL_A (PUT) in
          PRINT_FORM (AG_A (not (PUT), EF (Dia (PUT, true))))
          nop
     end_let;
(* the following is equivalent to the above *)
% DEFAULT_VERIFY_TOOL=xtl
"model.bcg" |=
     let PUT : labelset = EVAL_A (PUT) in
          PRINT_FORM (AG_A (not (PUT), EF (Dia (PUT, true))))
          nop
     end_let;
</PRE>
<H3><A NAME="sect32" HREF="#sect32">Deadlock and Livelock Checking</A></H3>
<PRE>[F "="] "deadlock" ["with" T] "of" B
</PRE>and <PRE>[F "="] "livelock" ["with" T] "of" B
</PRE>allow to search deadlocks, respectively livelocks, in a behaviour.  They
return TRUE if the behaviour has at least one deadlock, respectively likelock,
and FALSE otherwise. The optional file <I>F</I> must have extension <B>.aut</B>, <B>.bcg</B>, <B>.fc2</B>,
or <B>.seq</B>. It is created in the current directory and may contain a diagnostic
of the search, if such a diagnostic is available. <P>
The tool <I>T</I> is an optional
parameter, similar to those described above for the reductions and comparisons.
 The default value may be modified via the following variables: 
<UL>
<LI type=disc><B>DEFAULT_DEADLOCK_TOOL</B>,
whose initial value is "exhibitor". This variable can alternatively be set
to "aldebaran", "evaluator", "evaluator3", "evaluator4", or "evaluator5".
</LI><P><LI type=disc><B>DEFAULT_LIVELOCK_TOOL</B>, whose initial value is "evaluator". This variable
can alternatively be set to "evaluator3", "evaluator4", "evaluator5", or
"aldebaran". </LI><P>
</UL>
<P>
Those two shell variables replace the shell variable <B>DEFAULT_LOCK_TOOL</B>,
which was present in earlier versions of SVL and is now obsolete. <P>
Note that
<B>fc2tools</B> are no longer supported. 
<H3><A NAME="sect33" HREF="#sect33">Property</A></H3>
<PRE>"property" PID ["("param"," ..."," param")"]
   ['"'comment'"' ... '"'comment'"'] "is" P
"end property"
</PRE>is the "property" statement, which allows a set of statements to be attached
the following attributes: 
<UL>
<LI type=disc>The property has a name, defined by the identifier
<I>PID</I>. It is a string that starts with a letter and contains letters, digits,
and underscores, but does not end with an underscore. </LI><P><LI type=disc>The property may be
parameterized with an arbitrary number of parameters. Each parameter <I>param</I>
is an identifier satisfying the same syntax as property identifiers. Distinct
parameters of the same property must have distinct identifiers. Inside the
property, every parameter <I>param</I> can be expanded using $<I>param</I> or ${<I>param</I>}
as ordinary shell variables. In particular, if the property contains inline
formulas, the parameters are expanded in the formulas. </LI><P><LI type=disc>The property may
have comments consisting of a (possibly empty) sequence of character strings,
each enclosed in double quotes. Note that parameters can be used inside
comments. </LI><P>
</UL>
<P>
The body <I>P</I> of the property consists of a (possibly empty) sequence
of statements. Among those statements, <I>verification statements</I> are the behaviour
comparison statement (see Section COMPARISON), the temporal logic verification
statement (see Sections VERIFICATION and VERIFICATION OF INLINE FORMULAS),
and the deadlock and livelock checking statements (see Section DEADLOCK
AND LIVELOCK CHECKING). <P>
Each verification statement (if any) embedded in
the property can be followed by an expected result, in the form "expected
<I>L</I>", where <I>L</I> is either an identifier (e.g., TRUE, FALSE, ...) or an arbitrary
string, which may be a Unix regular expression (see the <B>regexp</B>(5) manual
page for details about regular expressions). A verification statement can
be followed by an expected result if and only if all verification statements
occurring in the same property are also followed by an expected result.
Note that expected results are not allowed outside a property. <P>
Note that
for a comparison, a deadlock or livelock checking, or the verification
of a formula using <A HREF="evaluator3.html"><B>evaluator3</B></A>
 or <A HREF="evaluator4.html"><B>evaluator4</B></A>
, the result is
either TRUE or FALSE. For the verification of a formula using <A HREF="evaluator5.html"><B>evaluator5</B></A>
,
the TRUE or FALSE result may be preceded by probability values if requested
by the probabilistic operators contained in the formula. The probability
values are not considered part of the result, only the TRUE or FALSE result
being considered. For the verification of a formula using <A HREF="xtl.html"><B>xtl</B></A>
, the
format of the result depends on the XTL program; SVL only considers the
last non-empty line printed by XTL as being the result. In all cases, we
say that the result satisfies the expected result if the expected result
matches the result entirely, using the egrep command (see the <B>egrep</B>(1)
manual page for details). <P>
If a property has no parameter, then it is checked
automatically. Otherwise, it must be instanciated using a "check" statement
of the following form: <PRE>"check" PID "(" arg "," ... "," arg ")"
</PRE>where each <I>arg</I> is an argument, which may be any identifier, string (in
double quotes), or natural number (i.e., sequence of digits), and where the
number of arguments must be equal to the number of parameters. <P>
When checking
a property, SVL will display the following information to the user: 
<UL>
<LI type=disc>the
name of the property, together with the argument values </LI><P><LI type=disc>the comments (one
line per comment) </LI><P><LI type=disc>if expected results are defined, a PASS or FAIL verdict;
PASS indicates that all verification statements met the expected results;
otherwise, the verdict has either the form FAIL if the property contains
a single verification statement, or the form "FAIL (<I>N</I>/<I>M</I>)" such that <I>M</I> (where
<I>M</I> &gt; 1) is the total number of verification statements contained in the property
and <I>N</I> (where 0 &lt;= <I>N</I> &lt; <I>M</I>) is the number of verification statements that met
the expected results </LI><P><LI type=disc>if expected results are not defined, the results of
verifications in sequence, in the order of statements </LI><P>
</UL>
<P>
More details of the
verifications can be displayed if the user sets the shell variable <B>PROPERTY_DISPLAY_MODE</B>
to a non-zero value. <P>
<B>Examples:</B> <PRE>property No_Deadlock
    "There should be no deadlock in the specification"
is
    "diag.seq" = deadlock of "spec.bcg";
        expected FALSE
end property (* checked automatically *)
property Exist (A, SPEC)
    "Action \"$A\" should be reachable in the specification"
is
    "diag_$A_$SPEC.seq" =
        "$SPEC.bcg" |= &lt; true* . '$A' &gt; true;
            expected TRUE
end property
check Exist ("G", "my_spec");
check Exist ("H", "my_spec")
</PRE><P>
The display of comments can be parameterized by the user. SVL provides two
means to do so: 
<UL>
<LI type=disc>Either redefine the three shell variables <B>PROPERTY_COMMENT_OPEN</B>,
<B>PROPERTY_COMMENT_MIDDLE</B>, and <B>PROPERTY_COMMENT_CLOSE</B>, which specify the
open comment symbol (printed on one separate line if different from the
empty string), middle comment symbol (which will start every comment line),
and close comment symbol (printed on one separate line if different from
the empty string). See examples below. </LI><P><LI type=disc>Or use one of the predefined comment
styles by calling the shell function <B>SVL_SET_PROPERTY_COMMENT_STYLE</B> with
a parameter among <B>silent</B> (comments are not displayed), <B>none</B>, <B>standard</B> (style
by default), <B>indent</B>, <B>ada</B>, <B>c</B>, <B>pascal</B>, or <B>sh</B>. Styles are illustrated in the
following table: <BR>
 <BR>
<PRE>+----------+-------------+------------+--------------+
| style    | open symbol | mid symbol | close symbol |
+----------+-------------+------------+--------------+
| none     |             |            |              |
+----------+-------------+------------+--------------+
| standard |             | " | "      |              |
+----------+-------------+------------+--------------+
| indent   |             | "   "      |              |
+----------+-------------+------------+--------------+
| ada      |             | "-- "      |              |
+----------+-------------+------------+--------------+
| c        | "/*"        | " * "      | " */"        |
+----------+-------------+------------+--------------+
| pascal   | "(*"        | " * "      | " *)"        |
+----------+-------------+------------+--------------+
| sh       |             | " # "      |              |
+----------+-------------+------------+--------------+
</PRE></LI><P>
</UL>
<P>
<B>Example:</B> <P>
The following SVL code: <P>
<PRE>% PROPERTY_COMMENT_OPEN="(+"
% PROPERTY_COMMENT_MIDDLE=" + "
% PROPERTY_COMMENT_CLOSE=" +)"
property P
    "this is a comment for property P"
is
    stop |= &lt; A &gt; true;
end property
</PRE><P>
will execute as follows: <P>
<PRE>property P
(+
 + this is a comment for property P
 +)
FALSE
</PRE><P>
<B>Example:</B> <P>
The following SVL code: <P>
<PRE>% SVL_SET_PROPERTY_COMMENT_STYLE ada
property P
    "this is a comment for property P"
is
    stop |= &lt; A &gt; true;
end property
</PRE><P>
will execute as follows: <P>
<PRE>property P
-- this is a comment for property P
FALSE
</PRE> 
<H3><A NAME="sect34" HREF="#sect34">Shell Lines</A></H3>
SVL offers the facility to insert shell lines between statements.
 Such lines must start with the symbol "%", and finish with the end of
the line. <P>
Of course, SVL operates no static control of the validity of inserted
shell lines. Hence, erroneous shell scripts may be generated by SVL due
to syntax errors made by the user, or to shell lines breaking the consistency
of SVL execution. 
<H3><A NAME="sect35" HREF="#sect35">Comments</A></H3>
SVL accepts two kinds of comments: 
<UL>
<LI type=disc>Every sequence
of characters delimited by "(*" and "*)" is a comment. This notation is
inherited from LOTOS and also available in LNT. </LI><P><LI type=disc>Every sequence of characters
from "--" until the next newline character is a comment. This notation is
inherited from LNT. </LI><P>
</UL>
<P>
Comments are ignored (i.e., considered as a blank character)
at any place in an SVL script, except: 
<UL>
<LI type=disc>within character strings (delimited
by double quotes), and </LI><P><LI type=disc>in shell lines (starting with "%"), where shell
comments (starting with "#") should be used instead. </LI><P>
</UL>

<H2><A NAME="sect36" HREF="#sect36">Storing Statement Results
in Shell Variables</A></H2>
SVL allows the result of some statements to be stored
in shell variables using the keyword "result" followed by a label, which
denotes a shell expression that expands to a shell variable identifier.
The statements whose result can be stored are Bourne shell commands, comparison
statements, temporal logic verification statements, and deadlock/livelock
checking statements. If a statement (e.g., a Bourne shell command or an XTL
property) produces several lines of output, then only the contents of the
last non-empty line is stored in the shell variable. <P>
<B>Example 1:</B> <PRE>"a.bcg" = comparison "spec.bcg" == "serv.bcg";
        result R;
% if [ "$R" = FALSE ]
% then
        -- other verifications
        ...
% fi
</PRE><B>Example 2:</B> <PRE>property P1 (R1)
    "a property"
is
    -- equivalence checking
    "a.bcg" = comparison "spec.bcg" == "serv.bcg";
        result "$R1" expected TRUE;
    -- other verifications
    ...
end property
property P2 (R2)
    "another property reusing part of the previous one"
is
    -- use $R2 to avoid checking equivalence again
    % echo "$R2"
        expected TRUE;
    -- other verifications
    ...
end property
check P1 ("Result"); -- assigns variable Result
check P2 ("$Result") -- uses the value assigned to Result
</PRE><P>
Note that "result" can be used in any context, unlike "expected", which
cannot be used outside the context of a "property". Also, if a statement
uses both "result" and "expected", then: 
<UL>
<LI type=disc>the "result" part must occur before
the "expected" part, and </LI><P><LI type=disc>the "result" and "expected" parts must not be
separated by a semicolon. </LI><P>
</UL>
<P>
See the syntax of non-terminal <I>RE</I> in Section SYNTAX
OF PROGRAMS AND EXPRESSIONS above.  
<H2><A NAME="sect37" HREF="#sect37">Using Shell Variables in Expressions</A></H2>
Every
string between double quotes may use defined Bourne shell variables ("$"<I>defined-shell-variable</I>).
This includes the shell variables defined using the "result" keyword (see
Section STORING STATEMENT RESULTS IN SHELL VARIABLES above) and the special
Bourne shell variables "$#", "$*", "$@", "$1", "$2", ... which can be used
to refer to the <I>script-parameters</I> passed to the generated script. <P>
However,
remember that when using filenames, extensions must always be explicitly
mentioned, for the following reasons: 
<UL>
<LI type=disc>They permit to determine at compile-time
the resulting format of a behaviour; </LI><P><LI type=disc>They permit to distinguish between
a file name and a process name, as illustrated in some of the examples
below. </LI><P>
</UL>
<P>
 <B>Examples:</B> <PRE>% for FNAME in a b c
% do
"reduced-$FNAME.aut" = reduction of "$FNAME.aut"
% done
</PRE>is correct, but <PRE>% for FNAME in a.aut b.aut c.aut
% do
"reduced-$FNAME" = reduction of "$FNAME"
% done
</PRE>is not correct (a run-time error is issued) because "$FNAME" is interpreted
at compile-time as a process whereas it denotes a file name. However, the
following example is correct: <PRE>% DEFAULT_PROCESS_FILE="a.lotos"
% for PNAME in "P1[G1, G2]" P2
% do
"reduced-$PNAME" = reduction of generation of "$PNAME
% done
</PRE>This loop reduces in turn the LTSs of processes <CODE>P1[G1, G2]</CODE> and <CODE>P2</CODE> found
in file <CODE>"a.lotos"</CODE>. <P>
Shell variables can also be used to denote gates or labels
as in the following example: <PRE>% for G in PUT GET
% do
  "P_$G.exp" = 
      "spec.lotos":P ["$G"] 
      |["$G"]|
      "spec.lotos":P ["$G"];
% done
</PRE>This loop generates in turn two composition expressions stored in EXP files,
corresponding to <CODE>"spec.lotos":P [PUT] |[PUT]| "spec.lotos":P [PUT]</CODE> and <CODE>"spec.lotos":P
[GET] |[GET]| "spec.lotos":P [GET]</CODE>. <P>
Note also that shell variables and expressions
can be used to denote lists of labels, gates, or renaming rules, using
the braced notation. A shell expression written between braces will be interpreted
as a list of labels instead of a single label, thus differentiating from
the quoted notation. <P>
For instance, one may write <PRE>% L1="A,
"f1.bcg" = total hide D, {$L1} in "f2.bcg";
% L2="A, B, C"
"f3.bcg" = "f4.bcg" |[ {$L2} ]| "f5.lotos":P ["D", {$L2}];
% L3="
% L4="C -&gt; A, B -&gt; C"
"f6.bcg" = total rename "D" -&gt; "E", {$L3, $L4} in "f7.bcg";
</PRE>to express that $A, $B, $C must not be interpreted as single labels or
rules (as it would be in "$A", "$B", "$C") but as lists of labels or rules.
<P>
Note that the label and rule separator is the coma.  However, comas between
parentheses are not interpreted as label or rule separators, as long as
parentheses are well-balanced.  
<H2><A NAME="sect38" HREF="#sect38">Local Shell Variables</A></H2>
SVL provides several
shell variables that allow users to fine-tune their verification scripts.
 Those variables may be modified (carefully) by the user, in a shell line,
as already mentionned. <P>
Use of variables whose name starts with <B>SVL_</B> should
be avoided. This syntax is reserved to functions and variables defined internally
by SVL. 
<H3><A NAME="sect39" HREF="#sect39">Default Verification Parameters</A></H3>
<P>
The following table lists the user-redefinable
shell variables relative to the choice of tools, verification methods,
equivalence relations, etc., together with their default values. <P>
 <PRE>+-----------------------------+-----------+----------------+
|           Variable          |  Default  |  Alternative   |
+-----------------------------+-----------+----------------+
| DEFAULT_REDUCTION_TOOL      | See Sect. | aldebaran      |
|                             | REDUCTION | bcg_min        |
|                             | above     | reductor       |
+-----------------------------+-----------+----------------+
| DEFAULT_COMPARISON_TOOL     | See Sect. | aldebaran      |
|                             | COMPARISON| bcg_cmp        |
|                             | above     | bisimulator    |
+-----------------------------+-----------+----------------+
| DEFAULT_VERIFY_TOOL         | See Sect. | evaluator      |
|                             | VERIFY    | evaluator3     |
|                             | above     | evaluator4     |
|                             |           | evaluator5     |
|                             |           | xtl            |
+-----------------------------+-----------+----------------+
| DEFAULT_DEADLOCK_TOOL       | exhibitor | aldebaran      |
|                             |           | evaluator      |
|                             |           | evaluator3     |
|                             |           | evaluator4     |
|                             |           | evaluator5     |
+-----------------------------+-----------+----------------+
| DEFAULT_LIVELOCK_TOOL       | evaluator | evaluator3     |
|                             |           | evaluator4     |
|                             |           | evaluator5     |
|                             |           | aldebaran      |
+-----------------------------+-----------+----------------+
| DEFAULT_REDUCTION_METHOD    | std       | bdd fly        |
+-----------------------------+-----------+----------------+
| DEFAULT_COMPARISON_METHOD   | dfs       | std bdd fly    |
|                             |           | bfs dfs        |
+-----------------------------+-----------+----------------+
| DEFAULT_VERIFY_METHOD       | dfs       | bfs acyclic    |
+-----------------------------+-----------+----------------+
| DEFAULT_REDUCTION_RELATION  | strong    | observational  |
|                             |           | tau*.a         |
|                             |           | branching      |
|                             |           | divbranching   |
|                             |           | safety         |
|                             |           | tau-compression|
|                             |           | tau-divergence |
|                             |           | tau-confluence |
|                             |           | trace          |
|                             |           | weak trace     |
+-----------------------------+-----------+----------------+
| DEFAULT_COMPARISON_RELATION | strong    | observational  |
|                             |           | tau*.a         |
|                             |           | branching      |
|                             |           | divbranching   |
|                             |           | safety         |
|                             |           | trace          |
|                             |           | weak trace     |
+-----------------------------+-----------+----------------+
| DEFAULT_PROCESS_FILE        | not set   |                |
+-----------------------------+-----------+----------------+
| DEFAULT_SMART_LIMIT         | 4         | any nat &gt; 1    |
+-----------------------------+-----------+----------------+
| DEFAULT_MCL_LIBRARIES       | ""        | comma-separated|
|                             |           | MCL lib list   |
+-----------------------------+-----------+----------------+
| DEFAULT_EVALUATOR3_LIBRARIES| ""        | comma-separated|
|                             |           | MCL3 lib list  |
+-----------------------------+-----------+----------------+
| DEFAULT_EVALUATOR4_LIBRARIES| ""        | comma-separated|
|                             |           | MCL4 lib list  |
+-----------------------------+-----------+----------------+
| DEFAULT_EVALUATOR5_LIBRARIES| ""        | comma-separated|
|                             |           | MCL5 lib list  |
+-----------------------------+-----------+----------------+
| DEFAULT_XTL_LIBRARIES       | ""        | comma-separated|
|                             |           | XTL lib list   |
+-----------------------------+-----------+----------------+
</PRE><P>
Note: Variable <B>DEFAULT_LOTOS_FILE</B> is deprecated. Instead, it is recommended
to use DEFAULT_PROCESS_FILE, which can be any file containing a LOTOS (extensions
<B>.lot</B> and <B>.lotos</B>), LNT (extension <B>.lnt</B>), or FSP (extension <B>.lts</B>) program. However,
scripts using <B>DEFAULT_LOTOS_FILE</B> should continue to work correctly. 
<H3><A NAME="sect40" HREF="#sect40">Tool
Options</A></H3>
<P>
The following table lists user-redefinable shell variables that may
be assigned options that are passed to tools. By default, these variables
are empty. See the respective tool manual pages for information about the
available options. <P>
 <PRE>+------------------------+---------------------------------+
|      Variable          |              Role               |
+------------------------+---------------------------------+
| ALDEBARAN_OPTIONS      | options passed to aldebaran     |
+------------------------+---------------------------------+
| BCG_CMP_OPTIONS        | options passed to bcg_cmp       |
+------------------------+---------------------------------+
| BCG_GRAPH_OPTIONS      | options passed to bcg_graph     |
+------------------------+---------------------------------+
| BCG_IO_OPTIONS_INPUT   | input options passed to bcg_io  |
+------------------------+---------------------------------+
| BCG_IO_OPTIONS_OUTPUT  | output options passed to bcg_io |
+------------------------+---------------------------------+
| BCG_LABELS_OPTIONS     | options passed to bcg_labels    |
+------------------------+---------------------------------+
| BCG_MIN_OPTIONS        | options passed to bcg_min       |
+------------------------+---------------------------------+
| BCG_OPEN_OPTIONS       | options passed to bcg_open      |
+------------------------+---------------------------------+
| BCG_OPEN_CC_OPTIONS    | C compiler options passed by    |
|                        | bcg_open                        |
+------------------------+---------------------------------+
| CAESAR_ADT_OPTIONS     | options passed to caesar.adt    |
+------------------------+---------------------------------+
| CAESAR_OPTIONS         | options passed to caesar        |
+------------------------+---------------------------------+
| EVALUATOR_OPTIONS      | options passed to evaluator     |
+------------------------+---------------------------------+
| EVALUATOR4_OPTIONS     | options passed to evaluator4    |
+------------------------+---------------------------------+
| EVALUATOR5_OPTIONS     | options passed to evaluator5    |
+------------------------+---------------------------------+
| EXHIBITOR_OPTIONS      | options passed to exhibitor     |
+------------------------+---------------------------------+
| EXP_OPEN_OPTIONS       | options passed to exp.open      |
+------------------------+---------------------------------+
| EXP_OPEN_CC_OPTIONS    | C compiler options passed by    |
|                        | exp.open                        |
+------------------------+---------------------------------+
| FSP_OPEN_OPTIONS       | options passed to fsp.open      |
+------------------------+---------------------------------+
| FSP_OPEN_CC_OPTIONS    | C compiler options passed by    |
|                        | fsp.open                        |
+------------------------+---------------------------------+
| GENERATOR_OPTIONS      | options passed to generator     |
+------------------------+---------------------------------+
| LNT_OPEN_OPTIONS       | options passed to lnt.open      |
+------------------------+---------------------------------+
| LNT_OPEN_CC_OPTIONS    | C compiler options passed by    |
|                        | lnt.open                        |
+------------------------+---------------------------------+
| LOTOS_OPEN_OPTIONS     | options passed to lotos.open    |
+------------------------+---------------------------------+
| LOTOS_OPEN_CC_OPTIONS  | C compiler options passed by    |
|                        | lotos.open                      |
+------------------------+---------------------------------+
| PROJECTOR_OPTIONS      | options passed to projector     |
+------------------------+---------------------------------+
| REDUCTOR_OPTIONS       | options passed to reductor      |
+------------------------+---------------------------------+
| SEQ_OPEN_OPTIONS       | options passed to seq.open      |
+------------------------+---------------------------------+
| SEQ_OPEN_CC_OPTIONS    | C compiler options passed by    |
|                        | seq.open                        |
+------------------------+---------------------------------+
| XTL_OPTIONS            | options passed to xtl           |
+------------------------+---------------------------------+
</PRE><P>
As of February 2020, the variables <B>CAESAR_OPEN_OPTIONS</B> and <B>CAESAR_OPEN_CC_OPTIONS</B>
are obsolete and replaced by <B>LOTOS_OPEN_OPTIONS</B> and <B>LOTOS_OPEN_CC_OPTIONS</B>,
respectively. <P>
In general, SVL does not check the contents of these variables
before passing them to the corresponding tools. However, there is a notable
exception concerning variable <B>EXP_OPEN_OPTIONS</B>: 
<UL>
<LI type=disc>Before calling <B>exp.open</B>,
SVL checks that <B>$EXP_OPEN_OPTIONS</B> contains at most one option among the
partial order reduction options available in <B>exp.open</B>, namely <B>-branching</B>,
<B>-deadpreserving</B>, <B>-strong</B>, and <B>-weaktrace</B>. Otherwise it issues an error message.
See <A HREF="exp.open.html"><B>exp.open</B></A>
 manual page for more details about partial order reduction
options. </LI><P><LI type=disc>In normal functioning, SVL tries to infer a partial order reduction
option from the context of the composition expression in the SVL program,
and then calls <B>exp.open</B> with this option. However, this is not done if <B>$EXP_OPEN_OPTIONS</B>
already contains a partial order reduction option, which is thus given
priority over the one that could be inferred. </LI><P>
</UL>

<H3><A NAME="sect41" HREF="#sect41">Location of Executables</A></H3>
<P>
The
following table lists user-redefinable shell variables that may be assigned
a path to a different version of the executable file related to a given
tool. <P>
 <PRE>+------------------------+---------------------------------+
|        Variable        |         Default value           |
+------------------------+---------------------------------+
| ALDEBARAN_EXECUTABLE   | aldebaran                       |
+------------------------+---------------------------------+
| BCG_CMP_EXECUTABLE     | bcg_cmp                         |
+------------------------+---------------------------------+
| BCG_GRAPH_EXECUTABLE   | bcg_graph                       |
+------------------------+---------------------------------+
| BCG_IO_EXECUTABLE      | bcg_io                          |
+------------------------+---------------------------------+
| BCG_LABELS_EXECUTABLE  | bcg_labels                      |
+------------------------+---------------------------------+
| BCG_MIN_EXECUTABLE     | bcg_min                         |
+------------------------+---------------------------------+
| BCG_OPEN_EXECUTABLE    | bcg_open                        |
+------------------------+---------------------------------+
| BISIMULATOR_EXECUTABLE | bisimulator                     |
+------------------------+---------------------------------+
| CAESAR_ADT_EXECUTABLE  | caesar.adt                      |
+------------------------+---------------------------------+
| CAESAR_EXECUTABLE      | caesar                          |
+------------------------+---------------------------------+
| EVALUATOR_EXECUTABLE   | evaluator                       |
+------------------------+---------------------------------+
| EVALUATOR3_EXECUTABLE  | evaluator3                      |
+------------------------+---------------------------------+
| EVALUATOR4_EXECUTABLE  | evaluator4                      |
+------------------------+---------------------------------+
| EVALUATOR5_EXECUTABLE  | evaluator5                      |
+------------------------+---------------------------------+
| EXHIBITOR_EXECUTABLE   | exhibitor                       |
+------------------------+---------------------------------+
| EXP_OPEN_EXECUTABLE    | exp.open                        |
+------------------------+---------------------------------+
| FSP_OPEN_EXECUTABLE    | fsp.open                        |
+------------------------+---------------------------------+
| GENERATOR_EXECUTABLE   | generator                       |
+------------------------+---------------------------------+
| LNT_DEPEND_EXECUTABLE  | lnt_depend                      |
+------------------------+---------------------------------+
| LNT_OPEN_EXECUTABLE    | lnt.open                        |
+------------------------+---------------------------------+
| LOTOS_OPEN_EXECUTABLE  | lotos.open                      |
+------------------------+---------------------------------+
| PROJECTOR_EXECUTABLE   | projector                       |
+------------------------+---------------------------------+
| REDUCTOR_EXECUTABLE    | reductor                        |
+------------------------+---------------------------------+
| SEQ_OPEN_EXECUTABLE    | seq.open                        |
+------------------------+---------------------------------+
| XTL_EXECUTABLE         | xtl                             |
+------------------------+---------------------------------+
</PRE><P>
As of February 2020, the variable <B>CAESAR_OPEN_EXECUTABLE</B> is obsolete and
replaced by <B>LOTOS_OPEN_EXECUTABLE</B>. 
<H3><A NAME="sect42" HREF="#sect42">Property Display Parameters</A></H3>
<P>
The following
table lists the user-redefinable variables that may be used to parameterize
the way messages are printed when evaluating properties. See Section PROPERTY
for details. <P>
 <PRE>+-------------------------+------------------------+-------+
|        Variable         |          Role          | Value |
+-------------------------+------------------------+-------+
| PROPERTY_DISPLAY_MODE   | displayed information  |  0/1  |
+-------------------------+------------------------+-------+
| PROPERTY_COMMENT_OPEN   | comment opening symbol |  any  |
+-------------------------+------------------------+-------+
| PROPERTY_COMMENT_MIDDLE | comment middle symbol  |  any  |
+-------------------------+------------------------+-------+
| PROPERTY_COMMENT_CLOSE  | comment closing symbol |  any  |
+-------------------------+------------------------+-------+
</PRE>
<H2><A NAME="sect43" HREF="#sect43">Environment Variables</A></H2>
The following environment variables are used: 
<DL><DD><DL COMPACT>

<DT><B>$CADP</B>
</DT>
<DD>Needed. This variable contains the path of directory where CADP is installed.
</DD><P>

<DT><B>$CADP/com</B> </DT>
<DD>This directory should be put in the <B>$PATH</B> variable. </DD><P>

<DT><B>$SVL </B> </DT>
<DD>Optional.
The first action of the generated script is to include the file <B>$CADP/src/svl/standard</B>,
containing a list of predefined shell functions and variables. However,
if the environment variable <B>SVL</B> is defined, the included file is <B>$SVL/src/svl/standard</B>.
Moreover, the kernel program <CODE>svl_kernel</CODE> will be searched in <B>$SVL/bin.`arch`</B>
instead of <B>$CADP/bin.`arch`</B>. </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect44" HREF="#sect44">How to Read an SVL File</A></H2>
<P>
The tool <A HREF="svl.html"><B>svl</B></A>
 reads
and processes SVL files. 
<H2><A NAME="sect45" HREF="#sect45">Bibliography</A></H2>
<P>
[GL01] Hubert Garavel and Frederic
Lang. SVL: a Scripting Language for Compositional Verification. In Myungchul
Kim, Byoungmoon Chin, Sungwon Kang, and Danhyung Lee (editors), Proceedings
of the 21st International Conference on Formal Techniques for Networked
and Distributed Systems FORTE'2001 (Cheju Island, Korea), IFIP Conference
Proceedings volume 197, pages 377-394, Kluwer, August 2001. Available from
<A HREF="http://cadp.inria.fr/publications/Garavel-Lang-01.html">http://cadp.inria.fr/publications/Garavel-Lang-01.html</A>
 <P>
[GLM15] Hubert Garavel,
Frederic Lang, and Radu Mateescu. Compositional Verification of Asynchronous
Concurrent Systems using CADP. Acta Informatica, Special Issue on Combining
Compositionality and Concurrency: Part 2, 52(4-5):337-392, 2015. Available
from <A HREF="http://cadp.inria.fr/publications/Garavel-Lang-Mateescu-15.html">http://cadp.inria.fr/publications/Garavel-Lang-Mateescu-15.html</A>
 <P>
[KM97] Jean-Pierre
Krimm and Laurent Mounier. Compositional State Space Generation from LOTOS
Programs. In Ed Brinksma (editor), Proceedings of TACAS'97 Tools and Algorithms
for the Construction and Analysis of Systems (University of Twente, Enschede,
The Netherlands), Lecture Notes in Computer Science volume 1217, Springer,
April 1997. Available from <A HREF="http://cadp.inria.fr/publications/Krimm-Mounier-97.html">http://cadp.inria.fr/publications/Krimm-Mounier-97.html</A>

<P>
[Lan02] Frederic Lang. Compositional Verification using SVL Scripts. In Joost-Pieter
Katoen and Perdita Stevens (editors), Proceedings of the International
Conference on Tools and Algorithms for Construction and Analysis of Systems
TACAS'2002 (Grenoble, France), Lecture Notes in Computer Science volume
2280, pages 465-469, Springer, April 2002. Available from <A HREF="http://cadp.inria.fr/publications/Lang-02.html">http://cadp.inria.fr/publications/Lang-02.html</A>


<H2><A NAME="sect46" HREF="#sect46">See Also</A></H2>
<A HREF="aldebaran.html"><B>aldebaran</B></A>
, <A HREF="aut.html"><B>aut</B></A>
, <A HREF="bcg.html"><B>bcg</B></A>
, <A HREF="bcg_cmp.html"><B>bcg_cmp</B></A>
, <A HREF="bcg_graph.html"><B>bcg_graph</B></A>
,
<A HREF="bcg_io.html"><B>bcg_io</B></A>
, <A HREF="bcg_labels.html"><B>bcg_labels</B></A>
, <A HREF="bcg_min.html"><B>bcg_min</B></A>
, <A HREF="bcg_open.html"><B>bcg_open</B></A>
, <A HREF="caesar.html"><B>caesar</B></A>
,
<A HREF="caesar.adt.html"><B>caesar.adt</B></A>
, <A HREF="caesar_hide_1.html"><B>caesar_hide_1</B></A>
, <A HREF="caesar_rename_1.html"><B>caesar_rename_1</B></A>
, <A HREF="evaluator.html"><B>evaluator</B></A>
,
<A HREF="evaluator3.html"><B>evaluator3</B></A>
, <A HREF="evaluator4.html"><B>evaluator4</B></A>
, <A HREF="evaluator5.html"><B>evaluator5</B></A>
, <A HREF="exhibitor.html"><B>exhibitor</B></A>
,
<A HREF="exp.html"><B>exp</B></A>
, <A HREF="exp.open.html"><B>exp.open</B></A>
, <A HREF="generator.html"><B>generator</B></A>
, <A HREF="lnt.open.html"><B>lnt.open</B></A>
, <A HREF="lotos.open.html"><B>lotos.open</B></A>
,
<A HREF="mcl.html"><B>mcl</B></A>
, <A HREF="mcl3.html"><B>mcl3</B></A>
, <A HREF="mcl4.html"><B>mcl4</B></A>
, <A HREF="mcl5.html"><B>mcl5</B></A>
, <A HREF="projector.html"><B>projector</B></A>
, <A HREF="reductor.html"><B>reductor</B></A>
,
<A HREF="regexp.html"><B>regexp</B></A>
, <A HREF="seq.html"><B>seq</B></A>
, <A HREF="seq.open.html"><B>seq.open</B></A>
, <A HREF="svl.html"><B>svl</B></A>
, <A HREF="xtl.html"><B>xtl</B></A>
, <A HREF="xtl-lang.html"><B>xtl-lang</B></A>

<P>
Directives for installation are given in files <B>$CADP/INSTALLATION_*</B>. <P>
Recent
changes and improvements to this software are reported and commented in
file <B>$CADP/HISTORY</B>. 
<H2><A NAME="sect47" HREF="#sect47">Bugs</A></H2>
Please report any bug to <A HREF="mailto:cadp@inria.fr?Subject=CADP-Bug-Report">cadp@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Description</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Syntax Description</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Syntax of Programs</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Syntax of Behaviour Expressions</A></LI>
<LI><A NAME="toc5" HREF="#sect5">Precedence and Associativity of Operators</A></LI>
<LI><A NAME="toc6" HREF="#sect6">Semantics of Behaviour Expressions</A></LI>
<UL>
<LI><A NAME="toc7" HREF="#sect7">Behaviour Systems</A></LI>
<LI><A NAME="toc8" HREF="#sect8">Stop</A></LI>
<LI><A NAME="toc9" HREF="#sect9">Hiding</A></LI>
<LI><A NAME="toc10" HREF="#sect10">Cutting</A></LI>
<LI><A NAME="toc11" HREF="#sect11">Priority</A></LI>
<LI><A NAME="toc12" HREF="#sect12">Renaming</A></LI>
<LI><A NAME="toc13" HREF="#sect13">Root Reduction</A></LI>
<LI><A NAME="toc14" HREF="#sect14">Leaf Reduction</A></LI>
<LI><A NAME="toc15" HREF="#sect15">Root Leaf Reduction</A></LI>
<LI><A NAME="toc16" HREF="#sect16">Node Reduction</A></LI>
<LI><A NAME="toc17" HREF="#sect17">Smart Reduction</A></LI>
<LI><A NAME="toc18" HREF="#sect18">Generation</A></LI>
<LI><A NAME="toc19" HREF="#sect19">Parallel Composition</A></LI>
<LI><A NAME="toc20" HREF="#sect20">Generalized Parallel</A></LI>
<LI><A NAME="toc21" HREF="#sect21">Abstraction</A></LI>
<LI><A NAME="toc22" HREF="#sect22">Infix Abstraction Operators</A></LI>
<LI><A NAME="toc23" HREF="#sect23">Refined Abstraction</A></LI>
<LI><A NAME="toc24" HREF="#sect24">Chaos Automata</A></LI>
<LI><A NAME="toc25" HREF="#sect25">Bags and Fifo Buffers</A></LI>
<LI><A NAME="toc26" HREF="#sect26">Cleaning</A></LI>
</UL>
<LI><A NAME="toc27" HREF="#sect27">Semantics of Statements</A></LI>
<UL>
<LI><A NAME="toc28" HREF="#sect28">Assignment</A></LI>
<LI><A NAME="toc29" HREF="#sect29">Comparison</A></LI>
<LI><A NAME="toc30" HREF="#sect30">Verification</A></LI>
<LI><A NAME="toc31" HREF="#sect31">Verification of Inline Formulas</A></LI>
<LI><A NAME="toc32" HREF="#sect32">Deadlock and Livelock Checking</A></LI>
<LI><A NAME="toc33" HREF="#sect33">Property</A></LI>
<LI><A NAME="toc34" HREF="#sect34">Shell Lines</A></LI>
<LI><A NAME="toc35" HREF="#sect35">Comments</A></LI>
</UL>
<LI><A NAME="toc36" HREF="#sect36">Storing Statement Results in Shell Variables</A></LI>
<LI><A NAME="toc37" HREF="#sect37">Using Shell Variables in Expressions</A></LI>
<LI><A NAME="toc38" HREF="#sect38">Local Shell Variables</A></LI>
<UL>
<LI><A NAME="toc39" HREF="#sect39">Default Verification Parameters</A></LI>
<LI><A NAME="toc40" HREF="#sect40">Tool Options</A></LI>
<LI><A NAME="toc41" HREF="#sect41">Location of Executables</A></LI>
<LI><A NAME="toc42" HREF="#sect42">Property Display Parameters</A></LI>
</UL>
<LI><A NAME="toc43" HREF="#sect43">Environment Variables</A></LI>
<LI><A NAME="toc44" HREF="#sect44">How to Read an SVL File</A></LI>
<LI><A NAME="toc45" HREF="#sect45">Bibliography</A></LI>
<LI><A NAME="toc46" HREF="#sect46">See Also</A></LI>
<LI><A NAME="toc47" HREF="#sect47">Bugs</A></LI>
</UL>
</BODY></HTML>
