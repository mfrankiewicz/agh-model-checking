 <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>CAESAR.BDD manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
caesar.bdd - structural and behavioural analysis of Nested-Unit Petri
Nets 
<H2><A NAME="sect1" HREF="#sect1">Synopsis</A></H2>
<B>caesar.bdd</B> <I>option</I> [ <I>filename</I><B>.nupn</B> ] 
<H2><A NAME="sect2" HREF="#sect2">Description</A></H2>
Taking as input
<I>filename</I><B>.nupn</B> (or by default the standard input),  which contains a Nested-Unit
Petri Net (NUPN) encoded in the <A HREF="nupn.html"><B>nupn</B></A>
 format, <B>caesar.bdd</B> performs
various structural or behavioural analyses, depending on the  <I>option</I> specified
on the command-line, and writes the corresponding results to the standard
output. Error and warning messages, if any, are displayed on the standard
error. <P>
See the  <A HREF="nupn.html"><B>nupn</B></A>
 manual page for a detailed definition of the
NUPN file format. <P>
For performance reasons, most options of <B>caesar.bdd</B> assume
that the contents of <I>filename</I><B>.nupn</B> are correct. When dealing with an unknown
Nested-Unit Petri Net, it is thus advisable to first analyze its contents
with <B>-check</B> before using any other option. Indeed, these other options often
perform less stringent verifications than <B>-check</B>, or even no verification
at all. In particular, options <B>-dead-places</B>, <B>-dead-transitions</B>, <B>-concurrent-places</B>,
and <B>-concurrent-units</B> rely on an optimized encoding of markings, which is
only correct if markings are safe or unit-safe, and may may produce invalid
results if this is not the case.  <P>
Also, most options of <B>caesar.bdd</B> do not
take into account the various pragmas that may be present in <I>filename</I><B>.nupn</B>.
As a general rule, the pragmas  "<CODE>!multiple_arcs</CODE>", "<CODE>!multiple_initial_tokens</CODE>",
and "<CODE>!unit_safe</CODE>" (see the section on pragmas in the  <A HREF="nupn.html"><B>nupn</B></A>
 format
definition) are ignored, unless explicitly stated otherwise below. 
<H2><A NAME="sect3" HREF="#sect3">Options</A></H2>

<DL><DD><DL COMPACT>

<DT><B>-check</B>
</DT>
<DD>Perform syntactic, structural and behavioural analysis of the Nested-Unit
Petri Net to verify whether the stated constraints of the NUPN format are
satisfied. The <B>-check</B> option performs additional checks and warns about redundant
or void units. In addition to these static checks, the <B>-check</B> option also
explores the marking graph using BDDs (Binary Decision Diagrams), prints
the number of states reached at each iteration, and checks whether all
reachable markings are one safe and unit safe; such checks are inconclusive
if the marking graph is too large for being generated. The warning and error
messages emitted by this option may differ depending on whether the "<CODE>!unit_safe</CODE>"
pragma is present or absent. </DD><P>

<DT><B>-arcs</B> </DT>
<DD>Display the number of arcs in the Nested-Unit
Petri Net. </DD><P>

<DT><B>-bits</B> </DT>
<DD>Display the number of bits needed to encode (using the best
encoding) the markings of the Nested-Unit Petri Net. </DD><P>

<DT><B>-concurrent-places</B> </DT>
<DD>Explore
the set of reachable markings to determine the pairs of "concurrent" places,
i.e., pairs of places Pi and Pj such that Pi = Pj or there exists a  reachable
marking containing both Pi and Pj. The exploration of the set of reachable
markings may be incomplete if a timeout (see below) is specified. The output
is defined as follows: Let P be the number of places in the Nested-Unit
Petri Net; <B>caesar.bdd</B> writes to the standard output a list of P*(P+1)/2
character values corresponding to the lower half of a matrix indexed according
to increasing place numbers; this list of characters is displayed as a
sequence of lines of increasing length; the upper half of the matrix is
not displayed because it enjoys a symmetry property (see below). <BR>
In a first approximation, the character written at the intersection of
row i and column j is either "<CODE>1</CODE>" if places Pi and pj are concurrent, "<CODE>0</CODE>"
if these places are not concurrent, or "<CODE>.</CODE>" if the answer is unknown. <BR>
Actually, beyond these three values, there are six more possible values:
 "<CODE>=</CODE>", "<CODE>&lt;</CODE>", and "<CODE>&gt;</CODE>", which are equivalent to "0" (i.e., non-concurrent), and
"<CODE>~</CODE>", "<CODE>[</CODE>", and "<CODE>]</CODE>", which are equivalent to "." (i.e., unknown). <BR>
The meaning of these nine values is defined as follows. The NUPN is said
to be "presumably unit safe" if either the exploration was complete and
the NUPN was found to be unit safe, or the exploration was incomplete and
the "<CODE>!unit_safe</CODE>" pragma is present. Line i corresponds to place Pi (belonging
to unit Ui) and row j corresponds to place Pj (belonging to unit Uj). The
character written at the intersection of row i and column j (with i !=
j, i.e., for each non-diagonal element) is equal to: <BR>
- "<CODE>=</CODE>": if the NUPN is presumably unit safe and both places belong to the
same unit, i.e., Ui = Uj; <BR>
- "<CODE>&lt;</CODE>": if the NUPN is presumably unit safe and the unit of Pi is contained
in the unit of Pj, i.e., Sub* (Ui, Uj), where the Sub* predicate is specified
in the <A HREF="nupn.html"><B>nupn</B></A>
 format definition; <BR>
- "<CODE>&gt;</CODE>": if the NUPN is presumably unit safe and the unit of Pi contains the
unit of Pj, i.e., Sub* (Uj, Ui); <BR>
- "<CODE>1</CODE>": if none of the above applies, and a marking containing both Pi and
Pj was reached; <BR>
- "<CODE>~</CODE>": if the NUPN is not presumably unit safe and both places are different
and belong to the same unit, i.e., (Pi != Pj) and (Ui = Uj); <BR>
- "<CODE>[</CODE>": if the NUPN is not presumably unit safe and the unit of Pi is contained
in the unit of Pj, i.e., Sub* (Ui, Uj); <BR>
- "<CODE>]</CODE>": if the NUPN is not presumably unit safe and the unit of Pi contains
the unit of Pj, i.e., Sub* (Uj, Ui); <BR>
- "<CODE>0</CODE>": if none of the above applies, and the exploration was complete and
no marking containing both Pi and Pj was reached; <BR>
- "<CODE>.</CODE>": if none of the above applies, and the exploration was incomplete and
no marking containing both Pi and Pj was reached. <BR>
Concerning diagonal elements, the character written at the intersection
of row i and column i is equal to: <BR>
- "<CODE>1</CODE>": if a marking containing Pi was reached (i.e., Pi is not a dead place);
<BR>
- "<CODE>0</CODE>": if the exploration was complete and no marking containing Pi was
reached (i.e., Pi is a dead place); <BR>
- "<CODE>.</CODE>": if the exploration was incomplete and no marking containing Pi was
reached. <BR>
The lower half and upper half of the matrix are symmetric modulo permutations
of "<CODE>&lt;</CODE>" and "<CODE>&gt;</CODE>", and of "<CODE>[</CODE>" and "<CODE>]</CODE>". Each line of the lower half of the matrix
is compressed using the algorithm described below in the section entitled
"COMPRESSION ALGORITHM". </DD><P>

<DT><B>-concurrent-units</B> </DT>
<DD>Explore the set of reachable markings
and determine the pairs of "concurrent" units, i.e., pairs of units Ui and
Uj that satisfy the predicate  Disjoint (Ui, Uj) specified in the <A HREF="nupn.html"><B>nupn</B></A>

format definition, and such that there exists at least one  reachable marking
containing one place of Ui and one place of Uj. The output is defined as
follows: Let U be the number of units in the Nested-Unit Petri Net; <B>caesar.bdd</B>
writes to the standard output a list of U*(U+1)/2 character values corresponding
to the lower half of a matrix indexed according to increasing unit numbers;
this list of characters is displayed as a sequence of lines of increasing
length; the upper half of the matrix is not displayed because it is symmetric;
the character written at the intersection of row i and column j is either
"<CODE>1</CODE>" if units Ui and Uj are concurrent, "<CODE>0</CODE>" if these units are not concurrent,
or "<CODE>.</CODE>" if the answer is unknown because the exploration of reachable markings
has been interrupted. Each line of the lower half of the matrix is compressed
using the algorithm described below in the section entitled "COMPRESSION
ALGORITHM". </DD><P>

<DT><B>-creator</B> </DT>
<DD>Display the name of the creator tool specified by the
<CODE>!creator</CODE> pragma if it is present in the Nested-Unit Petri Net, or the empty
string if this pragma is absent. This pragma is specified in the "PRAGMA
CREATOR" section of the <A HREF="nupn.html"><B>nupn</B></A>
 format definition. </DD><P>

<DT><B>-dead-places</B> </DT>
<DD>Explore
(parts of) the set of reachable markings to determine the set of "dead"
places, i.e., places that do not belong to any reachable marking. The output
is defined as follows: Let P be the number of places in the Nested-Unit
Petri Net; <B>caesar.bdd</B> writes to the standard output a line of P character
values corresponding to each place and ordered according to increasing
place numbers; the character written for each place is either "<CODE>1</CODE>" if the
place is dead, "<CODE>0</CODE>" if the place is not dead, or "<CODE>.</CODE>" if the answer is unknown
because the exploration of reachable markings has been interrupted. The
<CODE>!unit_safe</CODE> pragma, if present, is used to speed up calculations. The output
line is compressed using the algorithm described below in the section entitled
"COMPRESSION ALGORITHM". </DD><P>

<DT><B>-dead-transitions</B> </DT>
<DD>Explore (parts of) the set of reachable
markings to determine the set of "dead" transitions, i.e., transitions that
are not enabled in any reachable marking. The output is defined as follows:
Let T be the number of transitions in the Nested-Unit Petri Net;  <B>caesar.bdd</B>
writes to the standard output a line of T character values corresponding
to each transition and ordered according to increasing transition numbers;
the character written for each transition is either "<CODE>1</CODE>" if the transition
is dead, "<CODE>0</CODE>" if the transition is not dead (i.e., quasi-live), or "<CODE>.</CODE>" if the
answer is unknown because the exploration of reachable markings has been
interrupted. The <CODE>!unit_safe</CODE> pragma, if present, is used to  speed up calculations.
The output line is compressed using the algorithm described below in the
section entitled "COMPRESSION ALGORITHM". </DD><P>

<DT><B>-density</B> </DT>
<DD>Display the density of
the incidence matrice of the the Nested-Unit Petri Net, i.e., the number of
arcs divided by twice the product of the number of places by the number
of transitions. The density is equal to zero if there are no transitions
(hence, no arcs).  </DD><P>

<DT><B>-encodings</B> </DT>
<DD>Display statistics about the number of bits
required to represent the  markings of the Nested-Unit Petri Net using various
possible encodings, namely those encodings described in Section 6 of [Gar19].
</DD><P>

<DT><B>-height</B> </DT>
<DD>Display the height of the unit tree of the Nested-Unit Petri Net.
 All leaf units have height one, and the root unit only increases the height
if this unit is not void (i.e., has at least one local place). </DD><P>

<DT><B>-hwb</B> </DT>
<DD>Display
the HWB code of the Nested-Unit Petri Net. This code has the form <I>height</I>-<I>width</I>-<I>bits</I>,
where the three fields are those numbers computed by options <B>-height</B>, <B>-width</B>,
and <B>-bits</B>, respectively. Fields <I>height</I> and <I>width</I> are omitted if <I>width</I> is
equal to the number of places, i.e., if the NUPN is trivial. </DD><P>

<DT><B>-idle-units</B> </DT>
<DD>Display
the list of idle units (i.e., non-void units that have no local place in the
initial marking, and such that all transitions having an output place in
such a unit also have an input place in this unit) or the empty string
if there are no such units in the Nested-Unit Petri Net. Idle units are thus
a subset of dead units (i.e., non-void units having no local place in any
reachable marking). </DD><P>

<DT><B>-initial-places</B> </DT>
<DD>Display the list of places present in
the initial marking. </DD><P>

<DT><B>-initial-tokens</B> </DT>
<DD>Display the number of tokens present
in the initial marking. If present, the <CODE>!multiple_initial_tokens</CODE> pragma
is taken into account.  </DD><P>

<DT><B>-initial-units</B> </DT>
<DD>Display the list of initial units (i.e.,
units that contain at least one place present in the initial marking). This
list is never empty. The same unit can be displayed multiple times if it
contains several places in the initial marking, meaning that the Nested-Unit
Petri Net is not unit-safe. </DD><P>

<DT><B>-leaf-units</B> </DT>
<DD>Display list of leaf units (i.e., units
that have no sub-unit) in the Nested-Unit Petri Net. </DD><P>

<DT><B>-max-concurrency</B> </DT>
<DD>Display
(an over-approximation of) the upper bound for the maximal number of tokens
in any reachable marking. This option is expected to quickly compute a result,
even if the Nested-Unit Petri Net is large; consequently, no exhaustive
exploration of reachable markings is done. This option assumes that the
Nested-Unit Petri Net is safe, otherwise the result displayed is undefined.
The <CODE>!unit_safe</CODE> pragma, if present, is used to speed up calculations. </DD><P>

<DT><B>-max-place</B>
</DT>
<DD>Display the highest place number in the Nested-Unit Petri Net. </DD><P>

<DT><B>-max-transition</B>
</DT>
<DD>Display the highest transition number in the Nested-Unit Petri Net; if there
is no transition, this number is equal to zero. </DD><P>

<DT><B>-max-unit</B> </DT>
<DD>Display the highest
unit number in the Nested-Unit Petri Net. </DD><P>

<DT><B>-mcc</B> </DT>
<DD>Undocumented option used to
prepare or complete the model forms of the Model Checking Contest. This
option computes various structural and behavioural properties of the Nested-Unit
Petri Net. The <CODE>!unit_safe</CODE> pragma, if present, is taken into account. If the
<CODE>!multiple_arcs</CODE> pragma or the <CODE>!multiple_initial_tokens</CODE> pragma is present,
the <B>-mcc</B> option computes structural and behavioural properties for the original
(non safe) Petri Net rather than for the NUPN itself. </DD><P>

<DT><B>-min-concurrency</B> </DT>
<DD>Display
(an under-approximation of) the lower bound for the maximal number of tokens
in any reachable marking. This option is expected to quickly compute a result,
even if the Nested-Unit Petri Net is large; consequently, no exhaustive
exploration of reachable markings is done. This option assumes that the
Nested-Unit Petri Net is safe, otherwise the result displayed is undefined.
The <CODE>!unit_safe</CODE> pragma, if present, is used to speed up calculations. </DD><P>

<DT><B>-min-place</B>
</DT>
<DD>Display the lowest place number in the Nested-Unit Petri Net. </DD><P>

<DT><B>-min-transition</B>
</DT>
<DD>Display the lowest transition number in the Nested-Unit Petri Net; if there
is no transition, this number is equal to one. </DD><P>

<DT><B>-min-unit</B> </DT>
<DD>Display the lowest
unit number in the Nested-Unit Petri Net. </DD><P>

<DT><B>-multiple-arcs</B> </DT>
<DD>Display the arguments
of the <CODE>!multiple_arcs</CODE> pragma if it is present, or the empty string if this
pragma is absent. </DD><P>

<DT><B>-multiple-initial-tokens</B> </DT>
<DD>Display the arguments of the <CODE>!multiple_initial_tokens</CODE>
pragma if it is present, or the empty string if this pragma is absent. </DD><P>

<DT><B>-permanent-units</B>
</DT>
<DD>Display the list of permanent units (i.e., units that have a local place
in the initial marking, and such that all transitions having an input place
in such a unit also have an output place in this unit) or the empty string
 if there are no such units in the Nested-Unit Petri Net. Permanent units
are thus a subset of initial units. </DD><P>

<DT><B>-places</B> </DT>
<DD>Display the number of places
in the Nested-Unit Petri Net. </DD><P>

<DT><B>-pnml</B> </DT>
<DD>Write to the standard output the translation
in PNML (Petri Net Markup Language) the network given as input in the NUPN
format. The PNML output will contain a  "NUPN-toolspecific" section as defined
on the <A HREF="http://mcc.lip6.fr/nupn.php">http://mcc.lip6.fr/nupn.php</A>
 page. If the "<CODE>!unit_safe</CODE>" pragma is present,
it is propagated to this section. If the input network contains errors,
the translation may stop prematurely,  leaving an incomplete PNML file.
It is therefore recommended to invoke the tool  as follows: <BR>
<B>caesar.bdd -pnml</B> [ <I>filename</I><B>.nupn</B> ] &gt; <I>filename</I><B>.pnml</B> || rm -f  <I>filename</I><B>.pnml</B> </DD><P>

<DT><B>-redundant-units</B>
</DT>
<DD>Display the list of redundant units (i.e., units that have a single  sub-unit)
or the empty string if there are no such units in the Nested-Unit Petri
Net. </DD><P>

<DT><B>-root-unit</B> </DT>
<DD>Display the number of the root unit of the Nested-Unit Petri
Net. </DD><P>

<DT><B>-transitions</B> </DT>
<DD>Display the number of transitions in the Nested-Unit Petri
Net. </DD><P>

<DT><B>-trivial</B> </DT>
<DD>Display "1" if the Nested-Unit Petri Net is trivial, or "0"
otherwise. </DD><P>

<DT><B>-units</B> </DT>
<DD>Display the number of units in the Nested-Unit Petri Net.
</DD><P>

<DT><B>-version</B> </DT>
<DD>Display the current version number of the software. </DD><P>

<DT><B>-void-nonroot-units</B>
</DT>
<DD>Display the list of void units (i.e., units having no local place) that are
different from the root unit or the empty string if there are no such units
in the Nested-Unit Petri Net. If the net is correct, the empty string should
be displayed. </DD><P>

<DT><B>-void-root-unit</B> </DT>
<DD>Display the number of the root unit if this unit
is void (i.e., has no local place) or the empty string otherwise. </DD><P>

<DT><B>-void-units</B>
</DT>
<DD>Display the list of void units (i.e., units having no local place, possibly
including the root unit) or the empty string if there are no such units
in the Nested-Unit Petri Net. </DD><P>

<DT><B>-width</B> </DT>
<DD>Display the width of the unit tree of
the Nested-Unit Petri Net.  This width is equal to the number of leaf units.
</DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect4" HREF="#sect4">Interrupts</A></H2>
<B>caesar.bdd</B> handles certain POSIX interrupt signals (namely, SIGINT,
SIGQUIT, SIGALRM,  and SIGTERM) and adapt its behaviour in consequence.
Upon reception of such a signal: 
<UL>
<LI type=disc>The execution of options <B>-check</B>, <B>-concurrent-places</B>,
<B>-concurrent-units</B>, <B>-dead-places</B>, <B>-dead-transitions</B>, and <B>-mcc</B> stops the BDD-based
exploration of reachable markings, and completes using pessimistic assumptions
(i.e., the fact that parts of the marking graph have not been explored) delivering
less precise, yet correct results. </LI><P><LI type=disc>The execution of other options terminates
immediately, returning the exit code 5 (see below). </LI><P>
</UL>

<H2><A NAME="sect5" HREF="#sect5">User-specified Timeouts</A></H2>
The
environment variable <CODE>$CAESAR_BDD_TIMEOUT</CODE> can be used to specify a  maximal
duration for marking graph exploration. If this variable is set to a strictly
positive integer <I>N</I>, the exploration of the marking graph will stop after
<I>N</I> seconds. If this variable is set to zero, the exploration of the marking
graph is disabled, meaning only the initial marking is visited. If this
variable is not set (or set to an invalid value, such as "" or -1), the
exploration of the marking graph is performed without timeout. Upon expiration
of a timeout: 
<UL>
<LI type=disc>The execution of option <B>-check</B> terminates immediately, returning
the exit code 5 (see below). </LI><P><LI type=disc>The execution of options <B>-concurrent-places</B>,
<B>-concurrent-units</B>, <B>-dead-places</B>, and <B>-dead-transitions</B> stops the BDD-based exploration
of reachable markings, and completes using pessimistic assumptions. </LI><P><LI type=disc>The
execution of option <B>-mcc</B> completes by computing behavioural properties using
faster algorithms that rely on pessimistic assumptions. </LI><P>
</UL>
<P>
The functionality
provided by this environment variable is not available on Windows. 
<H2><A NAME="sect6" HREF="#sect6">Compression
Algorithm</A></H2>
The output of the four options <B>-concurrent-places</B>, <B>-concurrent-units</B>,
<B>-dead-places</B>, and <B>-dead-transitions</B> is compressed using a simple algorithm
based on run-length encoding: when a character is followed by an integer
<I>n</I> greater than 3 enclosed between parentheses, it means that this character
must be repeated <I>n</I> times, including its initial occurrence.  For instance,
the following sequence of characters: <PRE>    01110000101100000011.0000000110011111011111110.10........001111
</PRE>is compressed as:  <PRE>    01110(4)10110(6)11.0(7)11001(5)01(7)0.10.(8)001(4)
</PRE><P>
The compression algorithm is implemented as follows in the C language:
 <PRE>#include &lt;stdio.h&gt;
int main ()
{
    char C, PREVIOUS = '\0';
    int  N, REPEAT = 0;
    while (1) {
        C = getchar ();
        if (C == PREVIOUS) {
            /* assert (C != '\0') &amp;&amp; (C != EOF) &amp;&amp; (C != '\n') */
            ++ REPEAT;
        } else {
            /* flush the repetition buffer, if any */
            if (REPEAT &gt; 3) {
                printf ("(%d)", REPEAT);
            } else if (REPEAT &gt; 0) {
                for (N = 1; N &lt; REPEAT; ++ N)
                    putchar (PREVIOUS);
            }
            if (C == EOF)
                return 0;
            putchar (C);
            if (C == '0) {
                PREVIOUS = '\0';
                REPEAT = 0;
            } else {
                PREVIOUS = C;
                REPEAT = 1;
            }
        }
    }
}
</PRE><P>
This algorithm enjoys three nice properties: (1) it can operate on the
fly (e.g., using coroutines, pipes, or data streams), meaning that it is
not mandatory to generate the input entirely before starting to compress
it;  (2) the size (in characters) of the compressed output is always less
or equal to the size of the input; (3) compressing an already compressed
input has no effect. 
<H2><A NAME="sect7" HREF="#sect7">Decompression Algorithm</A></H2>
The compressed output of the
four options <B>-concurrent-places</B>, <B>-concurrent-units</B>, <B>-dead-places</B>, and <B>-dead-transitions</B>
is decompressed using a simple algorithm, implemented as follows in the
C language:  <PRE>#include &lt;stdio.h&gt;
int main ()
{
    char C, PREVIOUS = '\0';
    int  REPEAT = 0;
    while (1) {
        if (REPEAT &gt; 0) {
            /* assert (PREVIOUS != '\0') &amp;&amp; (PREVIOUS != '\n') */
            putchar (PREVIOUS);
            -- REPEAT;
        } else {
            C = getchar ();
            if (C == EOF)
                return 0;
            if (C != '(') {
                putchar (C);
                PREVIOUS = C;
            } else {
                scanf ("%d)", &amp;REPEAT);
                /* assert REPEAT &gt; 3 */
                -- REPEAT;
            }
        }
    }
}
</PRE><P>
This algorithm can operate on the fly; for instance, one can compare two
 (or more) compressed files without having to decompress them entirely
in advance. 
<H2><A NAME="sect8" HREF="#sect8">Exit Status</A></H2>
The exit status of  <B>caesar.bdd</B> may take the following
values:  <BR>

<DL><DD><DL COMPACT>

<DT>  0:  </DT>
<DD>normal termination (everything is alright) <BR>
</DD><P>

<DT>  1: </DT>
<DD>memory shortage (Petri Net and/or BDDs are too large) <BR>
</DD><P>

<DT>  2: </DT>
<DD>incorrect command-line arguments for <B>caesar.bdd</B> <BR>
</DD><P>

<DT>  3: </DT>
<DD><I>filename</I><B>.nupn</B> does not exist or is unreadable <BR>
</DD><P>

<DT>  4: </DT>
<DD>syntax or semantic error in <I>filename</I><B>.nupn</B> <BR>
</DD><P>

<DT>  5: </DT>
<DD><B>caesar.bdd</B> terminated by the user (SIGINT or SIGQUIT) or upon timeout
(SIGALRM or SIGTERM) <BR>
</DD><P>

<DT>  6: </DT>
<DD>the net given in <I>filename</I><B>.nupn</B> is not safe or not unit safe </DD><P>
</DL></DD><P></DL>
<P>
Any other
value corresponds to an unexpected error. 
<H2><A NAME="sect9" HREF="#sect9">Authors</A></H2>
Damien Bergamini and Hubert
Garavel (INRIA Rhone-Alpes)  
<H2><A NAME="sect10" HREF="#sect10">Files</A></H2>
 
<DL><DD><DL COMPACT>

<DT><I>filename</I><B>.nupn</B> </DT>
<DD>Nested-Unit Petri Net (input)
</DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect11" HREF="#sect11">Credits</A></H2>
To perform its behavioural analyses, <B>caesar.bdd</B> uses the Binary Decision
Diagram package CUDD (Release 3.0) developed by  Fabio Somenzi at the University
of Colorado (Boulder, CO, USA). 
<H2><A NAME="sect12" HREF="#sect12">Bibliography</A></H2>
[Gar19] Hubert Garavel. "Nested-Unit
Petri Nets". Journal of Logical and Algebraic Methods in Programming, vol.
104, pages 60-85, April 2019. Available from <A HREF="http://cadp.inria.fr/publications/Garavel-19.html">http://cadp.inria.fr/publications/Garavel-19.html</A>

<P>
[Gar15] Hubert Garavel. "Nested-Unit Petri Nets: A Structural Means to Increase
Efficiency and Scalability of Verification on Elementary Nets". In R. Devillers
and A. Valmari, editors, Proceedings of the 36th International Conference
on Application and Theory of Petri Nets and Concurrency (PETRI NETS'15),
Brussels, Belgium. Lecture Notes in Computer Science, vol. 9115, Springer,
2015. Superseded by [Gar19]. Available from <A HREF="http://cadp.inria.fr/publications/Garavel-15-a.html">http://cadp.inria.fr/publications/Garavel-15-a.html</A>


<H2><A NAME="sect13" HREF="#sect13">See Also</A></H2>
<A HREF="caesar.html"><B>caesar</B></A>
, <A HREF="nupn.html"><B>nupn</B></A>
, <A HREF="nupn_info.html"><B>nupn_info</B></A>
 <P>
Additional information
is available from the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives
for installation are given in files <B>$CADP/INSTALLATION_*.</B> <P>
Recent changes
and improvements to this software are reported and commented in file <B>$CADP/HISTORY.</B>

<H2><A NAME="sect14" HREF="#sect14">Bugs</A></H2>
Please report new bugs to <A HREF="mailto:Hubert.Garavel@inria.fr?Subject=CADP-Bug-Report">Hubert.Garavel@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Synopsis</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Description</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Options</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Interrupts</A></LI>
<LI><A NAME="toc5" HREF="#sect5">User-specified Timeouts</A></LI>
<LI><A NAME="toc6" HREF="#sect6">Compression Algorithm</A></LI>
<LI><A NAME="toc7" HREF="#sect7">Decompression Algorithm</A></LI>
<LI><A NAME="toc8" HREF="#sect8">Exit Status</A></LI>
<LI><A NAME="toc9" HREF="#sect9">Authors</A></LI>
<LI><A NAME="toc10" HREF="#sect10">Files</A></LI>
<LI><A NAME="toc11" HREF="#sect11">Credits</A></LI>
<LI><A NAME="toc12" HREF="#sect12">Bibliography</A></LI>
<LI><A NAME="toc13" HREF="#sect13">See Also</A></LI>
<LI><A NAME="toc14" HREF="#sect14">Bugs</A></LI>
</UL>
</BODY></HTML>
