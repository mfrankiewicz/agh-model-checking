  <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>caesar_edge manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
caesar_edge - the ``edge'' library of OPEN/CAESAR 
<H2><A NAME="sect1" HREF="#sect1">Purpose</A></H2>
The ``edge'' library
provides primitives for computing the edges going out of a given state.
<P>
Although the <I>OPEN/CAESAR</I> graph module already provides an iterator macro
for this purpose (the <CODE>CAESAR_ITERATE_STATE()</CODE> function), higher-level primitives
may be useful and easier to use. This is especially the case when a depth-first
traversal of the state graph is necessary (e.g., on-the-fly verification, interactive
simulation, ...). <P>
From our experience, the <CODE>CAESAR_ITERATE_STATE()</CODE> function
is often used as follows: for a given state S_1, one wants to compute all
outgoing edges of the form ``(S_1, L, S_2)''; the labels L and states S_2 are
stored in a data structure (usually a linked list). <P>

<H2><A NAME="sect2" HREF="#sect2">Usage</A></H2>
The ``edge'' library
consists of: 
<UL>
<LI type=disc>a predefined header file <CODE>caesar_edge.h</CODE>; </LI><P><LI type=disc>the precompiled library
file <CODE>libcaesar.a</CODE>, which implements the features described in <CODE>caesar_edge.h</CODE>.
</LI><P>
</UL>
<P>
Note: The ``edge'' library is a software layer built above the primitives offered
by the ``standard'' library and by the <I>OPEN/CAESAR</I> graph module. <P>

<H2><A NAME="sect3" HREF="#sect3">Description</A></H2>
An
``edge'' is basically a tuple with 5 fields: 
<UL>
<LI type=disc>(1) a field containing a ``previous''
state; </LI><P><LI type=disc>(2) a field containing a label; </LI><P><LI type=disc>(3) a field containing a ``next'' state;
</LI><P><LI type=disc>(4) a ``mark'' field, that is a byte string whose size and contents are freely
determined by the user. It can be used to mark states while depth-first exploring
the state graph. The size of the mark field is the same for all edges; it
must be greater or equal than zero. Pointers to mark fields will be considered
as values of type <CODE>CAESAR_TYPE_POINTER</CODE>; ``mark'' fields are always aligned on
appropriate boundaries so that the user can put any information in these
fields without alignment problem; </LI><P><LI type=disc>(5) a pointer to a ``successor'' edge, which
is used to build linked lists of edges. </LI><P>
</UL>
<P>
Fields (1), (2), (3), and (4) are
optional, depending on the initialization parameters (see function <CODE>CAESAR_INIT_EDGE()</CODE>
below). <P>
Edges are represented as byte strings of fixed size (see function
<CODE>CAESAR_SIZE_EDGE()</CODE> below) with definite alignment constraints (see function
<CODE>CAESAR_ALIGNMENT_EDGE()</CODE> below). All edges have the same size. <P>

<H2><A NAME="sect4" HREF="#sect4">Features</A></H2>
<P>
 <HR><BR>
 
<H3><A NAME="sect5" HREF="#sect5"><CODE>CAESAR_TYPE_EDGE</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_ABSTRACT (...) CAESAR_TYPE_EDGE;

</PRE>This type denotes a pointer to the concrete representation of an edge. The
edge representation is supposed to be ``opaque''.  <P>
 <HR><BR>
 
<H3><A NAME="sect6" HREF="#sect6"><CODE>CAESAR_INIT_EDGE</CODE></A></H3>
<PRE>void CAESAR_INIT_EDGE (CAESAR_PREVIOUS_STATE, CAESAR_LABEL, CAESAR_NEXT_STATE,
                       CAESAR_SIZE_MARK, CAESAR_ALIGNMENT_MARK)
CAESAR_TYPE_BOOLEAN CAESAR_PREVIOUS_STATE;
CAESAR_TYPE_BOOLEAN CAESAR_LABEL;
CAESAR_TYPE_BOOLEAN CAESAR_NEXT_STATE;
CAESAR_TYPE_NATURAL CAESAR_SIZE_MARK;
CAESAR_TYPE_NATURAL CAESAR_ALIGNMENT_MARK;
{ ... }

</PRE>This initialization procedure must be called before using any other primitive
of the ``edge'' library. It should be called only once. <P>
Each edge will contain
a ``previous'' state iff <CODE>CAESAR_PREVIOUS_STATE</CODE> is equal to true. <P>
Each edge will
contain a label iff <CODE>CAESAR_LABEL</CODE> is equal to true. <P>
Each edge will contain
a ``next'' state iff <CODE>CAESAR_NEXT_STATE</CODE> is equal to true. <P>
Each edge will contain
a mark field iff <CODE>CAESAR_SIZE_MARK</CODE> is different from zero. If so, the value
of <CODE>CAESAR_SIZE_MARK</CODE> determines the (constant) size (in bytes) of the mark
field, and the value of <CODE>CAESAR_ALIGNMENT_MARK</CODE> determines the alignment
factor (in bytes) of the mark field. The alignment factor must be a power
of two. Any mark field will be aligned on a boundary that is an even multiple
of the alignment factor. <CODE>CAESAR_ALIGNMENT_MARK</CODE> is equal to zero iff <CODE>CAESAR_SIZE_MARK</CODE>
is equal to zero; otherwise, the effect of <CODE>CAESAR_INIT_EDGE()</CODE> is undefined.
<P>
If <CODE>CAESAR_PREVIOUS_STATE</CODE>, <CODE>CAESAR_LABEL</CODE>, and <CODE>CAESAR_NEXT_STATE</CODE> are equal
to false, and if <CODE>CAESAR_SIZE_MARK</CODE> is equal to zero, the effect of <CODE>CAESAR_INIT_EDGE()</CODE>
is undefined. <P>
 <HR><BR>
 
<H3><A NAME="sect7" HREF="#sect7"><CODE>CAESAR_SIZE_EDGE</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_SIZE_EDGE ()
{ ... }

</PRE>This function returns the edge size (in bytes). <P>
 <HR><BR>
 
<H3><A NAME="sect8" HREF="#sect8"><CODE>CAESAR_ALIGNMENT_EDGE</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_ALIGNMENT_EDGE ()
   { ... }

</PRE>This function returns the alignment factor (in bytes) for edges. The alignment
factor is always a power of two, usually 1, 2, 4, or 8. Any byte string
representing a edge must be aligned on a boundary that is an even multiple
of the alignment factor. <P>
 <HR><BR>
 
<H3><A NAME="sect9" HREF="#sect9"><CODE>CAESAR_PREVIOUS_STATE_EDGE</CODE></A></H3>
<PRE>CAESAR_TYPE_STATE CAESAR_PREVIOUS_STATE_EDGE (CAESAR_E)
CAESAR_TYPE_EDGE CAESAR_E;
{ ... }

</PRE>This function returns a pointer to the ``previous'' state field of the edge
pointed to by <CODE>CAESAR_E</CODE>. If there is no such field (due to the initialization
parameters supplied to <CODE>CAESAR_INIT_EDGE()</CODE>) the result is undefined. <P>
 <HR><BR>
 
<H3><A NAME="sect10" HREF="#sect10"><CODE>CAESAR_LABEL_EDGE</CODE></A></H3>
<PRE>CAESAR_TYPE_LABEL CAESAR_LABEL_EDGE (CAESAR_E)
CAESAR_TYPE_EDGE CAESAR_E;
{ ... }

</PRE>This function returns a pointer to the label field of the edge pointed
to by <CODE>CAESAR_E</CODE>. If there is no such field (due to the initialization parameters
supplied to <CODE>CAESAR_INIT_EDGE()</CODE>) the result is undefined. <P>
 <HR><BR>
 
<H3><A NAME="sect11" HREF="#sect11"><CODE>CAESAR_NEXT_STATE_EDGE</CODE></A></H3>
<PRE>CAESAR_TYPE_STATE CAESAR_NEXT_STATE_EDGE (CAESAR_E)
CAESAR_TYPE_EDGE CAESAR_E;
{ ... }

</PRE>This function returns a pointer to the ``next'' state field of the edge pointed
to by <CODE>CAESAR_E</CODE>. If there is no such field (due to the initialization parameters
supplied to <CODE>CAESAR_INIT_EDGE()</CODE>) the result is undefined. <P>
 <HR><BR>
 
<H3><A NAME="sect12" HREF="#sect12"><CODE>CAESAR_MARK_EDGE</CODE></A></H3>
<PRE>CAESAR_TYPE_POINTER CAESAR_MARK_EDGE (CAESAR_E)
CAESAR_TYPE_EDGE CAESAR_E;
{ ... }

</PRE>This function returns a pointer to the mark field of the edge pointed to
by <CODE>CAESAR_E</CODE>. If there is no such field (due to the initialization parameters
supplied to <CODE>CAESAR_INIT_EDGE()</CODE>) the result is undefined. <P>
 <HR><BR>
 
<H3><A NAME="sect13" HREF="#sect13"><CODE>CAESAR_SUCCESSOR_EDGE</CODE></A></H3>
<PRE>CAESAR_TYPE_EDGE *CAESAR_SUCCESSOR_EDGE (CAESAR_E)
CAESAR_TYPE_EDGE CAESAR_E;
{ ... }

</PRE>This function returns a pointer to the ``successor'' edge (pointer) field of
the edge pointed to by <CODE>CAESAR_E</CODE>. <P>
 <HR><BR>
 
<H3><A NAME="sect14" HREF="#sect14"><CODE>CAESAR_CREATE_EDGE</CODE></A></H3>
<PRE>void CAESAR_CREATE_EDGE (CAESAR_E)
   CAESAR_TYPE_EDGE *CAESAR_E;
   { ... }

</PRE>This procedure allocates a byte string of length <CODE>CAESAR_SIZE_EDGE()</CODE> using
<CODE>CAESAR_CREATE()</CODE> and assigns its address to <CODE>*CAESAR_E</CODE>. If the allocation
fails, the <CODE>NULL</CODE> value is assigned to <CODE>*CAESAR_E</CODE>. <P>
When the allocation succeeds,
the mark field (if any) of <CODE>CAESAR_E</CODE> is initialized to a bit string of 0's
and the ``successor'' edge field is initialized to the <CODE>NULL</CODE> pointer. The state
field and the label field are left undefined. <P>
Note: because <CODE>CAESAR_TYPE_EDGE</CODE>
is a pointer type, any variable <CODE>CAESAR_E</CODE> of type <CODE>CAESAR_TYPE_EDGE</CODE> must
be allocated before used, for instance using: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_CREATE_EDGE (&amp;CAESAR_E);</CODE>
</TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>However, it is not necessary to use <CODE>CAESAR_CREATE_EDGE()</CODE> to perform the
allocation. Instead, users can allocate edges into their own data structures
(tables, lists, ...) <P>
 <HR><BR>
 
<H3><A NAME="sect15" HREF="#sect15"><CODE>CAESAR_DELETE_EDGE</CODE></A></H3>
<PRE>void CAESAR_DELETE_EDGE (CAESAR_E)
   CAESAR_TYPE_EDGE *CAESAR_E;
   { ... }

</PRE>This procedure frees the byte string of length <CODE>CAESAR_SIZE_EDGE()</CODE> pointed
to by <CODE>*CAESAR_E</CODE> using <CODE>CAESAR_DELETE()</CODE>. Afterwards, the <CODE>NULL</CODE> value is assigned
to <CODE>*CAESAR_E</CODE>. <P>
 <HR><BR>
 
<H3><A NAME="sect16" HREF="#sect16"><CODE>CAESAR_COPY_EDGE</CODE></A></H3>
<PRE>void CAESAR_COPY_EDGE (CAESAR_E1, CAESAR_E2)
   CAESAR_TYPE_EDGE CAESAR_E1;
   CAESAR_TYPE_EDGE CAESAR_E2;
   { ... }

</PRE>This procedure copies the edge pointed to by <CODE>CAESAR_E2</CODE> onto the edge pointed
to by <CODE>CAESAR_E1</CODE>. <P>
 <HR><BR>
 
<H3><A NAME="sect17" HREF="#sect17"><CODE>CAESAR_FORMAT_EDGE</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_FORMAT_EDGE (CAESAR_FORMAT)
   CAESAR_TYPE_FORMAT CAESAR_FORMAT;
   { ... }

</PRE>This function allows to control the format under which edges are printed
by procedures <CODE>CAESAR_PRINT_EDGE()</CODE> and <CODE>CAESAR_PRINT_EDGE_LIST()</CODE> (see below).
Currently, the following formats are available: <P>

<UL>
<LI type=disc>With format 0, the edge
is printed as a portion of text. This is mainly intended for debugging purpose.
</LI><P><LI type=disc>(no other format available yet) </LI><P>
</UL>
<P>
By default, the current edge format is
initialized to 0. <P>
When called with <CODE>CAESAR_FORMAT</CODE> between 0 and 0, this fonction
sets the current edge format to <CODE>CAESAR_FORMAT</CODE> and returns an undefined
result. <P>
When called with another value of <CODE>CAESAR_FORMAT</CODE>, this function does
not modify the current edge format but returns a result defined as follows.
If <CODE>CAESAR_FORMAT</CODE> is equal to the constant <CODE>CAESAR_CURRENT_FORMAT</CODE>, the result
is the value of the current edge format. If <CODE>CAESAR_FORMAT</CODE> is equal to the
constant <CODE>CAESAR_MAXIMAL_FORMAT</CODE>, the result is the maximal format value
(i.e., 0). In all other cases, the effect of this function is undefined. <P>
 <HR><BR>
 
<H3><A NAME="sect18" HREF="#sect18"><CODE>CAESAR_MAX_FORMAT_EDGE</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_MAX_FORMAT_EDGE ()
   { ... }

</PRE>Caution! This function is deprecated. It should no longer be used, as it
might be removed from future versions of the <I>OPEN/CAESAR</I>. Use function <CODE>CAESAR_FORMAT_EDGE()</CODE>
instead, called with argument <CODE>CAESAR_MAXIMAL_FORMAT</CODE>. <P>
This function returns
the maximal format value available for printing edges. <P>
 <HR><BR>
 
<H3><A NAME="sect19" HREF="#sect19"><CODE>CAESAR_PRINT_EDGE</CODE></A></H3>
<PRE>void CAESAR_PRINT_EDGE (CAESAR_FILE, CAESAR_E)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_EDGE CAESAR_E;
   { ... }

</PRE>This procedure prints to file <CODE>CAESAR_FILE</CODE> information about the contents
of the edge pointed to by <CODE>CAESAR_E</CODE>. The nature of the information is determined
by the current edge format (see procedure <CODE>CAESAR_FORMAT_EDGE()</CODE> above). <P>
Before
this procedure is called, <CODE>CAESAR_FILE</CODE> must have been properly opened, for
instance using <CODE>fopen(3)</CODE>. <P>
 <HR><BR>
 
<H3><A NAME="sect20" HREF="#sect20"><CODE>CAESAR_CREATE_EDGE_LIST</CODE></A></H3>
<PRE>void CAESAR_CREATE_EDGE_LIST (CAESAR_S1, CAESAR_E1_En, CAESAR_ORDER)
CAESAR_TYPE_STATE CAESAR_S1;
CAESAR_TYPE_EDGE *CAESAR_E1_En;
CAESAR_TYPE_NATURAL CAESAR_ORDER;

</PRE>This procedure computes all couples (<CODE>CAESAR_L</CODE>, <CODE>CAESAR_S2</CODE>) such that ``(<CODE>CAESAR_S1</CODE>,
<CODE>CAESAR_L</CODE>, <CODE>CAESAR_S2</CODE>)'' is an edge of the labelled transition system (this
is done using the <CODE>CAESAR_ITERATE_STATE()</CODE> procedure of the graph module).
<P>
This procedure also builds a linked list whose items are values of type
<CODE>CAESAR_TYPE_EDGE</CODE>, linked together using the ``successor'' edge field. The ``successor''
edge field of the last item is set to <CODE>NULL</CODE>. The list can be empty if <CODE>CAESAR_S1</CODE>
is a sink state. The address of the first item of the list (or <CODE>NULL</CODE> if the
list is empty) is assigned to <CODE>*CAESAR_E1_En</CODE>. Obviously, the previous value
of <CODE>*CAESAR_E1_En</CODE> is lost. <P>
The fields of each item are assigned as follows:
<P>

<UL>
<LI type=disc>the ``previous'' state field (if any) will contain the value of <CODE>CAESAR_S1</CODE>. </LI><P><LI type=disc>the
label field (if any) will contain various values for <CODE>CAESAR_L</CODE>. </LI><P><LI type=disc>the ``next''
state field (if any) of each item will contain values for <CODE>CAESAR_S2</CODE>. </LI><P><LI type=disc>the
mark field (if any) is initialized to a bit string of 0's. The value of the
formal parameter <CODE>CAESAR_ORDER</CODE> determines the order of the items of the
linked list. Several cases are currently implemented: </LI><P><LI type=disc>if <CODE>CAESAR_ORDER</CODE> is
equal to 0, the list order is undefined. </LI><P><LI type=disc>if <CODE>CAESAR_ORDER</CODE> is equal to 1,
the edge list is sorted in the same order as transitions are enumerated
by the <CODE>CAESAR_ITERATE_STATE()</CODE> procedure. </LI><P><LI type=disc>if <CODE>CAESAR_ORDER</CODE> is equal to 2,
the edge list is sorted in the reverse order of the order in which transitions
are enumerated by the <CODE>CAESAR_ITERATE_STATE()</CODE> procedure. </LI><P><LI type=disc>if <CODE>CAESAR_ORDER</CODE>
is equal to 3 or 5, the list is sorted in such a way that the character
string values returned by <CODE>CAESAR_STRING_LABEL()</CODE> are increasing, according
to the lexicographical order used in the function <CODE>strcmp(3)</CODE>. </LI><P><LI type=disc>if <CODE>CAESAR_ORDER</CODE>
is equal to 4 or 6, the list is sorted in such a way that the character
string values returned by <CODE>CAESAR_STRING_LABEL()</CODE> are decreasing, according
to the lexicographical order used in the function <CODE>strcmp(3)</CODE>. </LI><P>
</UL>
<P>
Additionally,
this procedure sets two global variables <CODE>caesar_creation</CODE> and <CODE>caesar_truncation</CODE>
of type <CODE>CAESAR_TYPE_NATURAL</CODE>. After any call to <CODE>CAESAR_CREATE_EDGE_LIST()</CODE>,
these variables can be inspected using the two functions <CODE>CAESAR_CREATION_EDGE_LIST()</CODE>
and <CODE>CAESAR_TRUNCATION_EDGE_LIST()</CODE> defined below. The values of these variables
are set as follows: <P>

<UL>
<LI type=disc>if the computation normally succeeds, then <CODE>caesar_creation</CODE>
is set to the number of items in the linked list and <CODE>caesar_truncation</CODE>
is set to zero. </LI><P><LI type=disc>if allocation fails when building the list (due to a lack
of memory), a truncated list is built (the ``successor'' edge field of the
last item is still set to <CODE>NULL</CODE>). Then <CODE>caesar_creation</CODE> is set to the number
of items in the truncated list and <CODE>caesar_truncation</CODE> is set to the number
of items that have not been inserted in the list (this number is greater
than zero). </LI><P>
</UL>
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect21" HREF="#sect21"><CODE>CAESAR_MAX_ORDER_EDGE_LIST</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_MAX_ORDER_EDGE_LIST ()
   { ... }

</PRE>This function returns the highest order available for edge list creation,
i.e., the highest acceptable value for the parameter <CODE>CAESAR_ORDER</CODE> of function
<CODE>CAESAR_CREATE_EDGE_LIST()</CODE>. <P>
 <HR><BR>
 
<H3><A NAME="sect22" HREF="#sect22"><CODE>CAESAR_DELETE_EDGE_LIST</CODE></A></H3>
<PRE>void CAESAR_DELETE_EDGE_LIST (CAESAR_E1_En)
CAESAR_TYPE_EDGE *CAESAR_E1_En;
{ ... }

</PRE>This procedure frees each item of the linked list pointed to by <CODE>*CAESAR_E1_En</CODE>.
Afterwards, the <CODE>NULL</CODE> value is assigned to <CODE>*CAESAR_E1_En</CODE>. <P>
 <HR><BR>
 
<H3><A NAME="sect23" HREF="#sect23"><CODE>CAESAR_COPY_EDGE_LIST</CODE></A></H3>
<PRE>void CAESAR_COPY_EDGE_LIST (CAESAR_E1_Em, CAESAR_E1_En)
CAESAR_TYPE_EDGE *CAESAR_E1_Em;
CAESAR_TYPE_EDGE CAESAR_E1_En;
{ ... }

</PRE>This procedure builds a duplicate list, which is a copy of the linked list
pointed to by <CODE>CAESAR_E1_En</CODE>. A pointer to this duplicate list (or NULL if
the list is empty) is assigned to <CODE>*CAESAR_E1_Em</CODE>. For each item of the linked
list pointed to by <CODE>CAESAR_E1_En</CODE>, a duplicated item is allocated. Said differently,
both lists do not have shared items in common. <P>
Additionally, this procedure
sets two global variables <CODE>caesar_creation</CODE> and <CODE>caesar_truncation</CODE> of type
<CODE>CAESAR_TYPE_NATURAL</CODE>. After any call to <CODE>CAESAR_COPY_EDGE_LIST()</CODE>, these variables
can be inspected using the two functions <CODE>CAESAR_CREATION_EDGE_LIST()</CODE> and
<CODE>CAESAR_TRUNCATION_EDGE_LIST()</CODE> defined below. The values of these variables
are set as in the <CODE>CAESAR_CREATE_EDGE_LIST()</CODE> function. <P>
The previous value
of <CODE>*CAESAR_E1_Em</CODE> is lost: if it points to a non-empty list, this list should
be freed using <CODE>CAESAR_DELETE_EDGE_LIST()</CODE> before <CODE>CAESAR_COPY_EDGE_LIST()</CODE>
is called. <P>
 <HR><BR>
 
<H3><A NAME="sect24" HREF="#sect24"><CODE>CAESAR_CREATION_EDGE_LIST</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_CREATION_EDGE_LIST ()
   { ... }

</PRE>This function returns the value of the global variable <CODE>caesar_creation</CODE>
computed during the last call to <CODE>CAESAR_CREATE_EDGE_LIST()</CODE> or <CODE>CAESAR_COPY_EDGE_LIST()</CODE>.
This variable can only be accessed using this function. <P>
 <HR><BR>
 
<H3><A NAME="sect25" HREF="#sect25"><CODE>CAESAR_TRUNCATION_EDGE_LIST</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_TRUNCATION_EDGE_LIST ()
   { ... }

</PRE>This function returns the value of the global variable <CODE>caesar_truncation</CODE>
computed during the last call to <CODE>CAESAR_CREATE_EDGE_LIST()</CODE> or <CODE>CAESAR_COPY_EDGE_LIST</CODE>.
This variable can only be accessed using this function. <P>
 <HR><BR>
 
<H3><A NAME="sect26" HREF="#sect26"><CODE>CAESAR_FORMAT_EDGE_LIST</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_FORMAT_EDGE_LIST (CAESAR_FORMAT)
   CAESAR_TYPE_FORMAT CAESAR_FORMAT;
   { ... }

</PRE>This function allows to control the format under which edge lists are printed
by the procedure <CODE>CAESAR_PRINT_EDGE_LIST()</CODE> (see below). Currently, the following
formats are available: <P>

<UL>
<LI type=disc>With format 0, the edge list is printed as a portion
of text. This is mainly intended for debugging purpose. </LI><P><LI type=disc>(no other format
available yet) </LI><P>
</UL>
<P>
A call to this function sets the current edge list format
to <CODE>CAESAR_FORMAT</CODE>. <P>
When called with <CODE>CAESAR_FORMAT</CODE> between 0 and 0, this fonction
sets the current edge list format to <CODE>CAESAR_FORMAT</CODE> and returns an undefined
result. <P>
When called with another value of <CODE>CAESAR_FORMAT</CODE>, this function does
not modify the current edge list format but returns a result defined as
follows. If <CODE>CAESAR_FORMAT</CODE> is equal to the constant <CODE>CAESAR_CURRENT_FORMAT</CODE>,
the result is the value of the current edge list format. If <CODE>CAESAR_FORMAT</CODE>
is equal to the constant <CODE>CAESAR_MAXIMAL_FORMAT</CODE>, the result is the maximal
format value (i.e., 0). In all other cases, the effect of this function is
undefined. <P>
 <HR><BR>
 
<H3><A NAME="sect27" HREF="#sect27"><CODE>CAESAR_MAX_FORMAT_EDGE_LIST</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_MAX_FORMAT_EDGE_LIST ()
   { ... }

</PRE>Caution! This function is deprecated. It should no longer be used, as it
might be removed from future versions of the <I>OPEN/CAESAR</I>. Use function <CODE>CAESAR_FORMAT_EDGE_LIST()</CODE>
instead, called with argument <CODE>CAESAR_MAXIMAL_FORMAT</CODE>. <P>
This function returns
the maximal format value available for printing edge lists. <P>
 <HR><BR>
 
<H3><A NAME="sect28" HREF="#sect28"><CODE>CAESAR_PRINT_EDGE_LIST</CODE></A></H3>
<PRE>void CAESAR_PRINT_EDGE_LIST (CAESAR_FILE, CAESAR_E1_En)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_EDGE CAESAR_E1_En;
   { ... }

</PRE>This procedure prints to file <CODE>CAESAR_FILE</CODE> information about the contents
of the linked list of edges pointed to by <CODE>CAESAR_E1_En</CODE>. The nature of the
information is determined by the current edge format and the current edge
list format (see procedures <CODE>CAESAR_FORMAT_EDGE()</CODE> and <CODE>CAESAR_FORMAT_EDGE_LIST()</CODE>
above). <P>
Before this procedure is called, <CODE>CAESAR_FILE</CODE> must have been properly
opened, for instance using <CODE>fopen(3)</CODE>. <P>
 <HR><BR>
 
<H3><A NAME="sect29" HREF="#sect29"><CODE>CAESAR_ITERATE_PLNM_EDGE_LIST</CODE></A></H3>
<PRE>#define CAESAR_ITERATE_PLNM_EDGE_LIST(CAESAR_E1_En,CAESAR_E,\
                    CAESAR_S1,CAESAR_L,CAESAR_S2,CAESAR_M) ...

</PRE>with parameters typed as follows: <PRE>CAESAR_TYPE_EDGE CAESAR_E1_En;
CAESAR_TYPE_EDGE CAESAR_E;
CAESAR_TYPE_STATE CAESAR_S1;
CAESAR_TYPE_LABEL CAESAR_L;
CAESAR_TYPE_STATE CAESAR_S2;
CAESAR_TYPE_POINTER CAESAR_M;

</PRE>This macro-definition is an iterator which can be used in the same way as
a <CODE>while (...)</CODE> or <CODE>for (...; ...; ...)</CODE> instruction. It is therefore possible to write
an instruction such as: <PRE>        CAESAR_ITERATE_PLNM_EDGE_LIST(caesar_e1_en,caesar_e,
                    caesar_s1,caesar_l,caesar_s2,caesar_m) {
        ...
        body of the loop, containing occurrences of variables
        caesar_e, caesar_s1, caesar_l, caesar_s2, and caesar_m
        ...
        }

</PRE><CODE>CAESAR_E1_En</CODE> is an expression (r-value) containing a pointer to the first
item of a linked list of edges. <P>
<CODE>CAESAR_E</CODE> is a variable (l-value) which will
be used as the induction variable in the body of the loop. At the n-th iteration
step, it points to the n-th item of the linked list. <P>
<CODE>CAESAR_S1</CODE> is a variable
(l-value) which can also be used as an induction variable. At the n-th iteration
step, it points to the ``previous'' state field of the n-th item of the linked
list. If this field does not exist, the result is undefined. At each step,
one has: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_S1</CODE> == <CODE>CAESAR_PREVIOUS_STATE_EDGE (CAESAR_E)</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
<CODE>CAESAR_L</CODE>
is a variable (l-value) which can also be used as an induction variable.
At the n-th iteration step, it points to the label field of the n-th item
of the linked list. If this field does not exist, the result is undefined.
At each step, one has: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_L</CODE> == <CODE>CAESAR_LABEL_EDGE (CAESAR_E)</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
<CODE>CAESAR_S2</CODE>
is a variable (l-value) which can also be used as an induction variable.
At the n-th iteration step, it points to the ``next'' state field of the n-th
item of the linked list. If this field does not exist, the result is undefined.
At each step, one has: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_S2</CODE> == <CODE>CAESAR_NEXT_STATE_EDGE (CAESAR_E)</CODE>
</TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
<CODE>CAESAR_M</CODE> is a variable (l-value) which can also be used as an induction
variable. At the n-th iteration step, it points to the mark field of the
n-th item of the linked list. If this field does not exist, the result is
undefined. At each step, one has: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_M</CODE> == <CODE>CAESAR_MARK_EDGE (CAESAR_E)</CODE>
</TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
The body of the loop can be any statement of the C language. In particular,
it may contain <CODE>break</CODE> and <CODE>continue</CODE> statements with their usual semantics.
<P>
This is the most general iterator on linked lists of edges. There are also
15 other iterators derived from the general one. These iterators are simpler
than the general one, since they deal with the cases where one or several
of the following parameters: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_S1</CODE>,  <CODE>CAESAR_L</CODE>,  <CODE>CAESAR_S2</CODE>,  <CODE>CAESAR_M</CODE>
</TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>are omitted. These operators are used according to the needs (for example,
the four aforementioned parameters can be omitted if one only wants to
compute the length of an edge list) and also depending on the initialization
values given to <CODE>CAESAR_INIT_EDGE()</CODE> (since one or several fields may not
actually exist). <P>
The 15 derived iterators are listed below. <P>
<PRE>#define CAESAR_ITERATE_EDGE_LIST(CAESAR_E1_En,CAESAR_E) ...
 
#define CAESAR_ITERATE_P_EDGE_LIST(CAESAR_E1_En,CAESAR_E,CAESAR_S1) ...
 
#define CAESAR_ITERATE_L_EDGE_LIST(CAESAR_E1_En,CAESAR_E,CAESAR_L) ...
 
#define CAESAR_ITERATE_N_EDGE_LIST(CAESAR_E1_En,CAESAR_E,CAESAR_S2) ...
 
#define CAESAR_ITERATE_M_EDGE_LIST(CAESAR_E1_En,CAESAR_E,CAESAR_M) ...
 
#define CAESAR_ITERATE_PL_EDGE_LIST(CAESAR_E1_En,CAESAR_E,CAESAR_S1,CAESAR_L)
...
 
#define CAESAR_ITERATE_PN_EDGE_LIST(CAESAR_E1_En,CAESAR_E,CAESAR_S1,CAESAR_S2)
...
 
#define CAESAR_ITERATE_PM_EDGE_LIST(CAESAR_E1_En,CAESAR_E,CAESAR_S1,CAESAR_M)
...
 
#define CAESAR_ITERATE_LN_EDGE_LIST(CAESAR_E1_En,CAESAR_E,CAESAR_L,CAESAR_S2)
...
 
#define CAESAR_ITERATE_LM_EDGE_LIST(CAESAR_E1_En,CAESAR_E,CAESAR_L,CAESAR_M)
...
 
#define CAESAR_ITERATE_NM_EDGE_LIST(CAESAR_E1_En,CAESAR_E,CAESAR_S2,CAESAR_M)
...
 
#define CAESAR_ITERATE_PLN_EDGE_LIST(CAESAR_E1_En,CAESAR_E,CAESAR_S1,CAESAR_L,CAESAR_S2)
...
 
#define CAESAR_ITERATE_PLM_EDGE_LIST(CAESAR_E1_En,CAESAR_E,CAESAR_S1,CAESAR_L,CAESAR_M)
...
 
#define CAESAR_ITERATE_PNM_EDGE_LIST(CAESAR_E1_En,CAESAR_E,CAESAR_S1,CAESAR_S2,CAESAR_M)
...
 
#define CAESAR_ITERATE_LNM_EDGE_LIST(CAESAR_E1_En,CAESAR_E,CAESAR_L,CAESAR_S2,CAESAR_M)
...

</PRE><P>
 <HR><BR>
 
<H3><A NAME="sect30" HREF="#sect30"><CODE>CAESAR_LENGTH_EDGE_LIST</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_LENGTH_EDGE_LIST (CAESAR_E1_En)
   CAESAR_TYPE_EDGE CAESAR_E1_En;
   { ... }

</PRE>This function returns the number of items in the linked list pointed to
by <CODE>CAESAR_E1_En</CODE>. <P>
 <HR><BR>
 
<H3><A NAME="sect31" HREF="#sect31"><CODE>CAESAR_ITEM_EDGE_LIST</CODE></A></H3>
<PRE>CAESAR_TYPE_EDGE CAESAR_ITEM_EDGE_LIST (CAESAR_E1_En, CAESAR_N)
   CAESAR_TYPE_EDGE CAESAR_E1_En;
   CAESAR_TYPE_NATURAL CAESAR_N;
   { ... }

</PRE>This function returns the <CODE>CAESAR_N</CODE>-th item in the linked list pointed to
by <CODE>CAESAR_E1_En</CODE> (the first item is numbered 1). If <CODE>CAESAR_N</CODE> is equal to
0, or is greater than the actual length of the linked list, the result
is undefined. <P>
 <HR><BR>
 
<H3><A NAME="sect32" HREF="#sect32"><CODE>CAESAR_REVERSE_EDGE_LIST</CODE></A></H3>
<PRE>void CAESAR_REVERSE_EDGE_LIST (CAESAR_E1_En)
   CAESAR_TYPE_EDGE *CAESAR_E1_En;
   { ... }

</PRE>This procedure reverses the linked list of edges pointed to by <CODE>*CAESAR_E1_En</CODE>.
<P>
 <HR><BR>
 
<H2><A NAME="sect33" HREF="#sect33">Author(s)</A></H2>
Hubert Garavel 
<H2><A NAME="sect34" HREF="#sect34">Files</A></H2>
 
<DL><DD><DL COMPACT>

<DT><B>$CADP/incl/caesar_graph.h</B> </DT>
<DD>interface of the
graph module </DD><P>

<DT><B>$CADP/incl/caesar_*.h</B> </DT>
<DD>interfaces of the storage module </DD><P>

<DT><B>$CADP/bin.`arch`/libcaesar.a</B>
</DT>
<DD>object code of the storage module </DD><P>

<DT><B>$CADP/src/open_caesar/*.c</B> </DT>
<DD>source code
of various exploration modules </DD><P>

<DT><B>$CADP/com/lotos.open</B> </DT>
<DD>shell script to run
OPEN/CAESAR  </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect35" HREF="#sect35">See Also</A></H2>
Reference Manuals of OPEN/CAESAR, CAESAR, and CAESAR.ADT,
<A HREF="lotos.open.html"><B>lotos.open</B></A>
, <A HREF="caesar.html"><B>caesar</B></A>
, <A HREF="caesar.adt.html"><B>caesar.adt</B></A>
 <P>
Additional information
is available from the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives
for installation are given in files <B>$CADP/INSTALLATION_*.</B> <P>
Recent changes
and improvements to this software are reported and commented in file <B>$CADP/HISTORY.</B>

<H2><A NAME="sect36" HREF="#sect36">Bugs</A></H2>
Known bugs are described in the Reference Manual of OPEN/CAESAR. Please
report new bugs to <A HREF="mailto:cadp@inria.fr?Subject=CADP-Bug-Report">cadp@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Purpose</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Usage</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Description</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Features</A></LI>
<UL>
<LI><A NAME="toc5" HREF="#sect5">CAESAR_TYPE_EDGE</A></LI>
<LI><A NAME="toc6" HREF="#sect6">CAESAR_INIT_EDGE</A></LI>
<LI><A NAME="toc7" HREF="#sect7">CAESAR_SIZE_EDGE</A></LI>
<LI><A NAME="toc8" HREF="#sect8">CAESAR_ALIGNMENT_EDGE</A></LI>
<LI><A NAME="toc9" HREF="#sect9">CAESAR_PREVIOUS_STATE_EDGE</A></LI>
<LI><A NAME="toc10" HREF="#sect10">CAESAR_LABEL_EDGE</A></LI>
<LI><A NAME="toc11" HREF="#sect11">CAESAR_NEXT_STATE_EDGE</A></LI>
<LI><A NAME="toc12" HREF="#sect12">CAESAR_MARK_EDGE</A></LI>
<LI><A NAME="toc13" HREF="#sect13">CAESAR_SUCCESSOR_EDGE</A></LI>
<LI><A NAME="toc14" HREF="#sect14">CAESAR_CREATE_EDGE</A></LI>
<LI><A NAME="toc15" HREF="#sect15">CAESAR_DELETE_EDGE</A></LI>
<LI><A NAME="toc16" HREF="#sect16">CAESAR_COPY_EDGE</A></LI>
<LI><A NAME="toc17" HREF="#sect17">CAESAR_FORMAT_EDGE</A></LI>
<LI><A NAME="toc18" HREF="#sect18">CAESAR_MAX_FORMAT_EDGE</A></LI>
<LI><A NAME="toc19" HREF="#sect19">CAESAR_PRINT_EDGE</A></LI>
<LI><A NAME="toc20" HREF="#sect20">CAESAR_CREATE_EDGE_LIST</A></LI>
<LI><A NAME="toc21" HREF="#sect21">CAESAR_MAX_ORDER_EDGE_LIST</A></LI>
<LI><A NAME="toc22" HREF="#sect22">CAESAR_DELETE_EDGE_LIST</A></LI>
<LI><A NAME="toc23" HREF="#sect23">CAESAR_COPY_EDGE_LIST</A></LI>
<LI><A NAME="toc24" HREF="#sect24">CAESAR_CREATION_EDGE_LIST</A></LI>
<LI><A NAME="toc25" HREF="#sect25">CAESAR_TRUNCATION_EDGE_LIST</A></LI>
<LI><A NAME="toc26" HREF="#sect26">CAESAR_FORMAT_EDGE_LIST</A></LI>
<LI><A NAME="toc27" HREF="#sect27">CAESAR_MAX_FORMAT_EDGE_LIST</A></LI>
<LI><A NAME="toc28" HREF="#sect28">CAESAR_PRINT_EDGE_LIST</A></LI>
<LI><A NAME="toc29" HREF="#sect29">CAESAR_ITERATE_PLNM_EDGE_LIST</A></LI>
<LI><A NAME="toc30" HREF="#sect30">CAESAR_LENGTH_EDGE_LIST</A></LI>
<LI><A NAME="toc31" HREF="#sect31">CAESAR_ITEM_EDGE_LIST</A></LI>
<LI><A NAME="toc32" HREF="#sect32">CAESAR_REVERSE_EDGE_LIST</A></LI>
</UL>
<LI><A NAME="toc33" HREF="#sect33">Author(s)</A></LI>
<LI><A NAME="toc34" HREF="#sect34">Files</A></LI>
<LI><A NAME="toc35" HREF="#sect35">See Also</A></LI>
<LI><A NAME="toc36" HREF="#sect36">Bugs</A></LI>
</UL>
</BODY></HTML>
