  <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>caesar_solve_1 manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
caesar_solve_1 - the ``solve_1'' library of OPEN/CAESAR 
<H2><A NAME="sect1" HREF="#sect1">Purpose</A></H2>
The ``solve_1''
library provides primitives for solving alternation-free boolean equation
systems, which are either provided ``on the fly'' or given as a text file encoded
in the <CODE>BES</CODE> format. This library can be used as a back-end for various on
the fly verification tools that formulate their corresponding problems
(e.g., equivalence checking, model checking, tau-confluence reduction, etc.)
in terms of boolean equation systems. <P>
<P>

<H2><A NAME="sect2" HREF="#sect2">Usage</A></H2>
The ``solve_1'' library consists
of: 
<UL>
<LI type=disc>a predefined header file <CODE>caesar_solve_1.h</CODE>; </LI><P><LI type=disc>the precompiled library file
<CODE>libcaesar.a</CODE>, which implements the features described in <CODE>caesar_solve_1.h</CODE>.
</LI><P>
</UL>
<P>
Note: The ``solve_1'' library is a software layer built above the primitives
offered by the ``standard'', ``area_1'', ``table_1'', and ``hash'' libraries, and by the
<I>OPEN/CAESAR</I> graph module. <P>
<P>

<H2><A NAME="sect3" HREF="#sect3">Boolean Equation Systems</A></H2>
See the <CODE>bes</CODE> manual page
of CADP for: <P>

<UL>
<LI type=disc>a definition of boolean equation systems and their terminology:
equation blocks, boolean variables, conjunctive and disjunctive formulas,
conjunctive and disjunctive variables, dependencies between variables,
dependencies between blocks, alternation-free systems, block indexes, variable
indexes, sign of a block, etc. </LI><P><LI type=disc>a specification of the <CODE>BES</CODE> format that is
used to store boolean equation systems in text files having the extension
``.bes''. </LI><P>
</UL>
<P>
<P>

<H2><A NAME="sect4" HREF="#sect4">on the Fly Resolution</A></H2>
Given a boolean equation system, the on the fly
(or local) resolution problem consists in computing the value of a particular
variable defined in some block of the system. Contrary to global resolution,
which consists in computing the values of all variables defined in the
system (and therefore must examine all equations of the system), on the
fly resolution computes the value of a variable without necessarily examining
all equations of the system. This resolution technique allows to construct
the boolean equation system in a demand-driven manner, and hence it is useful
for building tools for on the fly verification, which explore one or more
labelled transition systems incrementally. <P>
The on the fly resolution method
for alternation-free boolean equation systems implemented in the ``solve_1''
library proceeds as follows. To each equation block of the system is associated
a resolution routine responsible for computing the values of the variables
defined in the block. When the routine associated to a block is called to
compute the value of a variable defined in that block, it may in turn call
the routines associated to other blocks to compute the values of other
variables defined in those blocks. Assuming that all resolution routines
associated to the blocks will eventually terminate, the overall resolution
process will also terminate, because the size of the call stack of resolution
routines is bounded by the number N of blocks in the boolean equation system
(since the system is alternation-free, there are no cyclic dependencies
between blocks). <P>
<P>

<H2><A NAME="sect5" HREF="#sect5">Boolean Graphs</A></H2>
The resolution routines associated to the
equation blocks are easier to develop using a representation of blocks
as boolean graphs, which provide a more intuitive view of the dependencies
between boolean variables. Given an equation block, its corresponding boolean
graph is defined as follows: 
<UL>
<LI type=disc>For each boolean variable occurring in the
block, there is a vertex in the boolean graph. </LI><P><LI type=disc>For each dependency from
a boolean variable <CODE>Xi</CODE> to a boolean variable <CODE>Xj</CODE>, there is an edge ``(<CODE>Xi</CODE>, <CODE>Xj</CODE>)''
in the boolean graph. </LI><P><LI type=disc>Each vertex of the boolean graph is labeled as disjunctive
or conjunctive according to the kind of the boolean variable it denotes.
</LI><P>
</UL>
<P>
Boolean variables whose defining equations have right-hand side formulas
identical to <CODE>false</CODE> (resp. <CODE>true</CODE>) are represented in the boolean graph as
disjunctive (resp. conjunctive) vertices without successors. Dependencies
between different equation blocks are represented as edges between the
boolean graphs associated to the blocks. <P>
The boolean graph associated to
the boolean equation system above is shown below (edges are represented
as couples of boolean variables, the kind of which is indicated between
brackets). <PRE>    (* graph for B0 *)
       (X0_0 [and], X1_0 [or])
       (X0_0 [and], X2_0 [and])
       (X1_0 [or],  X0_0 [and])
       (X1_0 [or],  X1_0 [or])
       (X1_0 [or],  X2_0 [and])
       (X2_0 [and], X0_1 [or])
       (X2_0 [and], X3_0 [or])
       (X3_0 [or],  X1_0 [or])
       (X3_0 [or],  X4_0 [and])
 
    (* graph for B1 *)
       (X0_1 [or],  X1_1 [or])
       (X0_1 [or],  X2_1 [and])
       (X2_1 [and], X2_1 [and])
       (X2_1 [and], X3_1 [or])
       (X3_1 [or],  X0_1 [or])
       (X3_1 [or],  X1_1 [or])
       (X3_1 [or],  X3_1 [or])

</PRE>For each equation block, its corresponding resolution routine will explore
forward the boolean graph associated to the block and will propagate backward
the values of boolean variables already stabilized (i.e., the value of which
has been determined). When solving a boolean variable, only the part of
the boolean graph relevant for deciding the value of the variable is explored.
For instance, the part of the boolean graph explored for solving variable
<CODE>X0_0</CODE> of the boolean equation system above is shown below (all boolean variables
contained in this part of the boolean graph are false). <PRE>    (* resolution graph for B0 *)
       (X0_0 [and], X1_0 [or])
       (X0_0 [and], X2_0 [and])
       (X1_0 [or],  X0_0 [and])
       (X1_0 [or],  X1_0 [or])
       (X1_0 [or],  X2_0 [and])
       (X2_0 [and], X0_1 [or])
 
    (* resolution graph for B1 *)
       (X0_1 [or],  X1_1 [or])
       (X0_1 [or],  X2_1 [and])
       (X2_1 [and], X2_1 [and])

</PRE>The resolution was carried out as follows. After exploring variables <CODE>X0_0</CODE>
and <CODE>X1_0</CODE>, the current unexplored successor of <CODE>X0_0</CODE> is <CODE>X2_0</CODE>. The exploration
of <CODE>X2_0</CODE> is started by visiting variable <CODE>X0_1</CODE>, which is defined in block
<CODE>B1</CODE>. This variable depends on <CODE>X1_1</CODE>, whose value is false (disjunctive vertex
without successors) and <CODE>X2_1</CODE>, whose value is also false (conjunctive vertex
with a self-loop in a minimal fixed point block). Thus, variable <CODE>X0_1</CODE> is
false, and by propagating its value backward, variables <CODE>X2_0</CODE> and <CODE>X0_0</CODE> become
false (conjunctive vertices with a successor equal to false). <P>
<P>

<H2><A NAME="sect6" HREF="#sect6">Resolution
Modes</A></H2>
The ``solve_1'' library implements various algorithms (named ``resolution
modes'') to solve boolean equation systems by exploring their associated
boolean graphs. For efficiency reasons, each equation block of the same
boolean equation system may be solved using the most appropriate algorithm.
Currently, the following resolution modes are available: <P>

<UL>
<LI type=disc>Mode 0 corresponds
to a resolution algorithm based upon a depth-first search of the boolean
graph associated to the equation block. This algorithm can be applied to
any kind of equation block. </LI><P><LI type=disc>Mode 1 corresponds to a resolution algorithm
based upon a breadth-first search of the boolean graph associated to the
equation block. This algorithm can be applied to any kind of equation block.
In practice, it performs slightly slower than mode 0, but produces diagnostics
of smaller depth. </LI><P><LI type=disc>Mode 2 corresponds to a resolution algorithm based upon
a depth-first search of the boolean graph associated to the equation block.
This algorithm can be applied only to acyclic equation blocks, i.e., without
cyclic dependencies between variables. In practice, it consumes less memory
than modes 0 and 1. </LI><P><LI type=disc>Mode 3 corresponds to a resolution algorithm based upon
a depth-first search of the boolean graph associated to the equation block.
This algorithm can be applied only to disjunctive equation blocks, i.e.,
whose right-hand sides of equations are either (a) disjunctive formulas,
or (b) conjunctive formulas whose operands are constants or variables defined
in other blocks, with the possible exception of the last operand, which
may be a variable defined in the current block (e.g., <CODE>true and X1_j and false
and X2</CODE>, where <CODE>X1_j</CODE> is defined in another block of index <CODE>j</CODE> and <CODE>X2</CODE> is defined
in the current block). In practice, it consumes less memory than modes 0
and 1. </LI><P><LI type=disc>Mode 4 corresponds to a resolution algorithm based upon a depth-first
search of the boolean graph associated to the equation block. This algorithm
can be applied only to conjunctive equation blocks, i.e., whose right-hand
sides of equations are either (a) conjunctive formulas, or (b) disjunctive
formulas whose operands are constants or variables defined in other blocks,
with the possible exception of the last operand, which may be a variable
defined in the current block (e.g., <CODE>false or X1_j or true or X2</CODE>, where <CODE>X1_j</CODE>
is defined in another block of index <CODE>j</CODE> and <CODE>X2</CODE> is defined in the current
block). In practice, it consumes less memory than modes 0 and 1. </LI><P><LI type=disc>Mode 5 corresponds
to a resolution algorithm based upon a depth-first search of the boolean
graph associated to the equation block. This algorithm can be applied to
any kind of equation block. In practice, it exhibits a better performance
than mode 0 when applied to equation blocks containing alternating dependencies
between disjunctive and conjunctive variables (e.g., the equation blocks
encoding equivalence checking problems). </LI><P><LI type=disc>Mode 6 corresponds to a resolution
algorithm based upon a breadth-first search of the boolean graph associated
to the equation block. This algorithm can be applied only to disjunctive
minimal fixed point equation blocks for which a single resolution was specified.
In practice, it consumes less memory than mode 1 and produces diagnostics
of smaller depth than mode 3. </LI><P><LI type=disc>Mode 7 corresponds to a resolution algorithm
based upon a breadth-first search of the boolean graph associated to the
equation block. This algorithm can be applied only to conjunctive maximal
fixed point equation blocks for which a single resolution was specified.
In practice, it consumes less memory than mode 1 and produces diagnostics
of smaller depth than mode 4. </LI><P><LI type=disc>Mode 8 corresponds to a resolution algorithm
based upon a depth-first search of the boolean graph associated to the equation
block. This algorithm can be applied to any kind of equation block. In practice,
it consumes less memory than modes 0 and 5, being especially useful for
solving minimal (resp. maximal) fixed point equation blocks containing many
conjunctive (resp. disjunctive) variables. </LI><P><LI type=disc>Mode 9 corresponds to a resolution
algorithm based upon a breadth-first search of the boolean graph associated
to the equation block. This algorithm can be applied only to acyclic equation
blocks, i.e., without cyclic dependencies between variables. When applied
to an acyclic block consisting of singular equations (i.e., having only one
boolean variable in their right-hand sides), whose boolean graph is a sequence,
this algorithm consumes a bounded amount of memory, independent of the
number of equations in the block (length of the sequence). </LI><P><LI type=disc>(no other resolution
mode available yet) </LI><P>
</UL>
<P>
<P>

<H2><A NAME="sect7" HREF="#sect7">Internal Representation</A></H2>
To enable on the fly exploration,
the boolean graphs associated to the equation blocks of a boolean equation
system are represented in a generic, implicit manner using a scheme similar
to the one defined by the <I>OPEN/CAESAR</I> graph module for representing labelled
transition systems. This representation roughly consists of the following
ingredients (see procedure <CODE>CAESAR_CREATE_SOLVE_1()</CODE> below for additional
details): 
<UL>
<LI type=disc>Boolean variables (vertices of the boolean graph) are represented
as pointers to memory areas of fixed size (for each equation block, all
variables defined in that block must have the same size). The precise meaning
of the variable contents is defined by the application program and is not
relevant for the resolution algorithms. </LI><P><LI type=disc>Each equation block is equipped
with several functions computing various information about the variables
defined in the block: a function returning the kind of a variable (disjunctive
or conjunctive), a comparison function, a hashing function, a printing
function, and an iterator procedure which enumerates the successors of
a variable in the boolean graph. </LI><P><LI type=disc>Application programs may also associate,
to each edge of the boolean graph, a specific information (label) represented
as a pointer to a memory area. The contents of these memory areas are not
meaningful for the resolution algorithms, which manipulate the pointers
to these areas only by copying them and (possibly) by comparing them to
<CODE>NULL</CODE>. </LI><P>
</UL>
<P>
To speed up the overall resolution process, each equation block of
the boolean equation system has associated an internal table which stores
the boolean variables already explored during the previous calls of the
resolution routine associated to the block. This avoids recomputations of
boolean variables by subsequent calls of the same resolution routine, leading
to an overall resolution process of time complexity linear in the size
of the boolean equation system (number of variables and operators). <P>
<P>

<H2><A NAME="sect8" HREF="#sect8">Diagnostic
Generation</A></H2>
A diagnostic for a boolean variable is a boolean subgraph rooted
at the vertex corresponding to the variable, which illustrates the truth
value computed for the variable. If the boolean variable is <CODE>true</CODE> (resp. <CODE>false</CODE>),
then the diagnostic is called example (resp. counterexample). Disjunctive
(resp. conjunctive) vertices belonging to an example have only one successor
(resp. all their successors) contained in the example. Disjunctive (resp.
conjunctive) vertices belonging to a counterexample have all their successors
(resp. only one successor) contained in the counterexample. <P>
The diagnostic
of a boolean variable defined in an equation block is always contained
in the part of the boolean graph explored by the resolution routine associated
to that block when it solved the variable. A counterexample for variable
<CODE>X0_0</CODE> of the boolean equation system above is shown below. <PRE>    (* diagnostic graph for X0_0 in B0 *)
       (X0_0 [and], X2_0 [and])
       (X2_0 [and], X0_1 [or])
 
    (* diagnostic graph for X0_1 in B1 *)
       (X0_1 [or],  X1_1 [or])
       (X0_1 [or],  X2_1 [and])
       (X2_1 [and], X2_1 [and])

</PRE>To speed up the generation of diagnostics, resolution routines also compute
diagnostic-related information which is kept in the internal tables associated
to the blocks. Diagnostics are represented in a generic, implicit manner
using a scheme similar to the one defined by the <I>OPEN/CAESAR</I> graph module
for representing labelled transition systems. This representation is based
upon an iterator procedure that enumerates the successors of a variable
contained in its diagnostic (see procedure <CODE>CAESAR_ITERATE_DIAGNOSTIC_SOLVE_1()</CODE>
below). <P>
Application programs can generate diagnostics by exploring them
using this iterator procedure. To spare memory, the successors of a boolean
variable contained in its diagnostic are provided by the iterator procedure
as pointers to variables that were stored in the internal tables when the
variable was solved (see procedure <CODE>CAESAR_START_DIAGNOSTIC_SOLVE_1()</CODE> below).
Consequently, these variables should neither be modified, nor freed by
the application program. <P>
Note: Edges contained in diagnostics preserve the
information (label) that was attached to the edges of the boolean graph
by the application program (see procedure <CODE>CAESAR_CREATE_SOLVE_1()</CODE> below).
<P>
<P>

<H2><A NAME="sect9" HREF="#sect9">Description</A></H2>
The ``solve_1'' library allows to create and handle boolean equation
systems on the fly, providing procedures for resolution, inspection, diagnostic
generation, reading from, and writing to text files. <P>
<P>

<H2><A NAME="sect10" HREF="#sect10">Features</A></H2>
<P>
 <HR><BR>
 
<H3><A NAME="sect11" HREF="#sect11"><CODE>CAESAR_TYPE_SOLVE_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_ABSTRACT (...) CAESAR_TYPE_SOLVE_1;

</PRE>This type denotes a pointer to the concrete representation of a boolean
equation system. This representation is supposed to be ``opaque''. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect12" HREF="#sect12"><CODE>CAESAR_TYPE_BLOCK_SIGN_SOLVE_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_BOOLEAN CAESAR_TYPE_BLOCK_SIGN_SOLVE_1;

</PRE>This type indicates the sign (minimal or maximal fixed point) associated
to an equation block of a boolean equation system. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect13" HREF="#sect13"><CODE>CAESAR_MINIMAL_FIXED_POINT_SOLVE_1</CODE></A></H3>
<PRE>#define CAESAR_MINIMAL_FIXED_POINT_SOLVE_1 \
   ((CAESAR_TYPE_BLOCK_SIGN_SOLVE_1) CAESAR_TRUE)

</PRE>This constant denotes the minimal fixed point sign. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect14" HREF="#sect14"><CODE>CAESAR_MAXIMAL_FIXED_POINT_SOLVE_1</CODE></A></H3>
<PRE>#define CAESAR_MAXIMAL_FIXED_POINT_SOLVE_1 \
   ((CAESAR_TYPE_BLOCK_SIGN_SOLVE_1) CAESAR_FALSE)

</PRE>This constant denotes the maximal fixed point sign. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect15" HREF="#sect15"><CODE>CAESAR_TYPE_VARIABLE_KIND_SOLVE_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_BOOLEAN CAESAR_TYPE_VARIABLE_KIND_SOLVE_1;

</PRE>This type indicates the kind (disjunctive or conjunctive) associated to
a boolean variable. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect16" HREF="#sect16"><CODE>CAESAR_DISJUNCTIVE_VARIABLE_SOLVE_1</CODE></A></H3>
<PRE>#define CAESAR_DISJUNCTIVE_VARIABLE_SOLVE_1 \
   ((CAESAR_TYPE_VARIABLE_KIND_SOLVE_1) CAESAR_TRUE)

</PRE>This constant denotes the disjunctive variable kind. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect17" HREF="#sect17"><CODE>CAESAR_CONJUNCTIVE_VARIABLE_SOLVE_1</CODE></A></H3>
<PRE>#define CAESAR_CONJUNCTIVE_VARIABLE_SOLVE_1 \
   ((CAESAR_TYPE_VARIABLE_KIND_SOLVE_1) CAESAR_FALSE)

</PRE>This constant denotes the conjunctive variable kind. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect18" HREF="#sect18"><CODE>CAESAR_TYPE_BLOCK_SIGN_FUNCTION_SOLVE_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_BLOCK_SIGN_SOLVE_1
   (*CAESAR_TYPE_BLOCK_SIGN_FUNCTION_SOLVE_1) (CAESAR_TYPE_NATURAL);

</PRE>This type denotes a pointer to a function which takes as parameter a natural
number (index of an equation block) and returns the sign (minimal or maximal
fixed point) of the block. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect19" HREF="#sect19"><CODE>CAESAR_TYPE_VARIABLE_KIND_FUNCTION_SOLVE_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_VARIABLE_KIND_SOLVE_1
   (*CAESAR_TYPE_VARIABLE_KIND_FUNCTION_SOLVE_1) (CAESAR_TYPE_POINTER);

</PRE>This type denotes a pointer to a function which takes as parameter a pointer
to a boolean variable and returns the kind (disjunctive or conjunctive)
of the variable. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect20" HREF="#sect20"><CODE>CAESAR_TYPE_AREA_FUNCTION_SOLVE_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_AREA_1
   (*CAESAR_TYPE_AREA_FUNCTION_SOLVE_1) (CAESAR_TYPE_NATURAL);

</PRE>This type denotes a pointer to a function which takes as parameter a natural
number (index of an equation block) and returns the area (size and alignment)
of the boolean variables defined in that block. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect21" HREF="#sect21"><CODE>CAESAR_TYPE_BOOLEAN_FUNCTION_SOLVE_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_BOOLEAN
   (*CAESAR_TYPE_BOOLEAN_FUNCTION_SOLVE_1) (CAESAR_TYPE_NATURAL);

</PRE>This type denotes a pointer to a function which takes as parameter a natural
number and returns a boolean value. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect22" HREF="#sect22"><CODE>CAESAR_TYPE_NATURAL_FUNCTION_SOLVE_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_NATURAL
   (*CAESAR_TYPE_NATURAL_FUNCTION_SOLVE_1) (CAESAR_TYPE_NATURAL);

</PRE>This type denotes a pointer to a function which takes as parameter a natural
number and returns a natural number. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect23" HREF="#sect23"><CODE>CAESAR_TYPE_ERROR_SOLVE_1</CODE></A></H3>
<PRE>typedef enum {
     CAESAR_NONE_SOLVE_1,
     CAESAR_MULTIPLE_RESOLUTION_SOLVE_1,
     CAESAR_MEMORY_SHORTAGE_SOLVE_1,
     CAESAR_RECURSIVE_BLOCK_SOLVE_1,
     CAESAR_CYCLIC_BLOCK_SOLVE_1,
     CAESAR_NOT_DISJUNCTIVE_BLOCK_SOLVE_1,
     CAESAR_NOT_CONJUNCTIVE_BLOCK_SOLVE_1,
     CAESAR_MINIMAL_FIXED_POINT_BLOCK_SOLVE_1,
     CAESAR_MAXIMAL_FIXED_POINT_BLOCK_SOLVE_1
}    CAESAR_TYPE_ERROR_SOLVE_1;

</PRE>This enumerated type defines the error codes produced as a side effect
by calls to the function <CODE>CAESAR_COMPUTE_SOLVE_1()</CODE> (see below), which performs
the resolution of a boolean variable defined in a block of a boolean equation
system. The error codes have the following meaning: 
<UL>
<LI type=disc><CODE>CAESAR_NONE_SOLVE_1</CODE>
indicates that the resolution was performed successfully. </LI><P><LI type=disc><CODE>CAESAR_MULTIPLE_RESOLUTION_SOLVE_1</CODE>
indicates that another resolution of a variable of the block was already
performed, whereas at the creation of the boolean equation system (see
procedure <CODE>CAESAR_CREATE_SOLVE_1()</CODE> below) a single resolution was specified
for the block. If one of the resolution algorithms 6 or 7, dedicated to
blocks with single resolution, was specified for the block, this error
code is produced regardless of the fact that a single resolution was specified
or not for the block. </LI><P><LI type=disc><CODE>CAESAR_MEMORY_SHORTAGE_SOLVE_1</CODE> indicates that a memory
allocation failed during the resolution. </LI><P><LI type=disc><CODE>CAESAR_RECURSIVE_BLOCK_SOLVE_1</CODE>
indicates the presence of a cyclic dependency between the blocks of the
boolean equation system, which violates the alternation-free condition. </LI><P><LI type=disc><CODE>CAESAR_CYCLIC_BLOCK_SOLVE_1</CODE>
indicates the presence of a cyclic dependency between the variables defined
in the block, whereas at the creation of the boolean equation system (see
procedure <CODE>CAESAR_CREATE_SOLVE_1()</CODE> below) the resolution algorithm 2, dedicated
to acyclic blocks, was specified for the block. </LI><P><LI type=disc><CODE>CAESAR_NOT_DISJUNCTIVE_BLOCK_SOLVE_1</CODE>
indicates that the current block is not disjunctive, whereas at the creation
of the boolean equation system (see procedure <CODE>CAESAR_CREATE_SOLVE_1()</CODE> below)
one of the resolution algorithms 3 or 6, dedicated to disjunctive blocks,
was specified for the block. </LI><P><LI type=disc><CODE>CAESAR_NOT_CONJUNCTIVE_BLOCK_SOLVE_1</CODE> indicates
that the current block is not conjunctive, whereas at the creation of the
boolean equation system (see procedure <CODE>CAESAR_CREATE_SOLVE_1()</CODE> below) one
of the resolution algorithms 4 or 7, dedicated to conjunctive blocks, was
specified for the block. </LI><P><LI type=disc><CODE>CAESAR_MINIMAL_FIXED_POINT_BLOCK_SOLVE_1</CODE> indicates
that the current block denotes a minimal fixed point, whereas at the creation
of the boolean equation system (see procedure <CODE>CAESAR_CREATE_SOLVE_1()</CODE> below)
the resolution algorithm 7, dedicated to maximal fixed point blocks, was
specified for the block. </LI><P><LI type=disc><CODE>CAESAR_MAXIMAL_FIXED_POINT_BLOCK_SOLVE_1</CODE> indicates
that the current block denotes a maximal fixed point, whereas at the creation
of the boolean equation system (see procedure <CODE>CAESAR_CREATE_SOLVE_1()</CODE> below)
the resolution algorithm 6, dedicated to minimal fixed point blocks, was
specified for the block. </LI><P>
</UL>
<P>
Note: The error code produced by a call to <CODE>CAESAR_COMPUTE_SOLVE_1()</CODE>
can be obtained by using the function <CODE>CAESAR_STATUS_COMPUTE_SOLVE_1()</CODE> (see
below). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect24" HREF="#sect24"><CODE>CAESAR_CREATE_SOLVE_1</CODE></A></H3>
<PRE>void CAESAR_CREATE_SOLVE_1 (CAESAR_B,
                            CAESAR_NUMBER_OF_BLOCKS,
                            CAESAR_BLOCK_SIGN,
                            CAESAR_BLOCK_UNIQUE_RESOLUTION,
                            CAESAR_BLOCK_SOLVE_MODE,
                            CAESAR_BLOCK_VARIABLE_AREA,
                            CAESAR_BLOCK_LIMIT_SIZE,
                            CAESAR_BLOCK_HASH_SIZE,
                            CAESAR_BLOCK_PRIME,
                            CAESAR_VARIABLE_KIND,
                            CAESAR_VARIABLE_COMPARE,
                            CAESAR_VARIABLE_HASH,
                            CAESAR_VARIABLE_PRINT,
                            CAESAR_VARIABLE_ITERATE,
                            CAESAR_INFO)
   CAESAR_TYPE_SOLVE_1 *CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_NUMBER_OF_BLOCKS;
   CAESAR_TYPE_BLOCK_SIGN_FUNCTION_SOLVE_1 CAESAR_BLOCK_SIGN;
   CAESAR_TYPE_BOOLEAN_FUNCTION_SOLVE_1 CAESAR_BLOCK_UNIQUE_RESOLUTION;
   CAESAR_TYPE_NATURAL_FUNCTION_SOLVE_1 CAESAR_BLOCK_SOLVE_MODE;
   CAESAR_TYPE_AREA_FUNCTION_SOLVE_1 CAESAR_BLOCK_VARIABLE_AREA;
   CAESAR_TYPE_NATURAL_FUNCTION_SOLVE_1 CAESAR_BLOCK_LIMIT_SIZE;
   CAESAR_TYPE_NATURAL_FUNCTION_SOLVE_1 CAESAR_BLOCK_HASH_SIZE;
   CAESAR_TYPE_BOOLEAN_FUNCTION_SOLVE_1 CAESAR_BLOCK_PRIME;
   CAESAR_TYPE_VARIABLE_KIND_FUNCTION_SOLVE_1 CAESAR_VARIABLE_KIND;
   CAESAR_TYPE_COMPARE_FUNCTION CAESAR_VARIABLE_COMPARE;
   CAESAR_TYPE_HASH_FUNCTION CAESAR_VARIABLE_HASH;
   CAESAR_TYPE_PRINT_FUNCTION CAESAR_VARIABLE_PRINT;
   void (*CAESAR_VARIABLE_ITERATE) (CAESAR_TYPE_POINTER, CAESAR_TYPE_POINTER,
      void (*) (CAESAR_TYPE_POINTER, CAESAR_TYPE_NATURAL, CAESAR_TYPE_POINTER));
   CAESAR_TYPE_POINTER CAESAR_INFO;
   { ... }

</PRE>This procedure allocates a boolean equation system using <CODE>CAESAR_CREATE()</CODE>
and assigns its address to <CODE>*CAESAR_B</CODE>. If the allocation fails, the <CODE>NULL</CODE>
value is assigned to <CODE>*CAESAR_B</CODE>. <P>
Note: Because <CODE>CAESAR_TYPE_SOLVE_1</CODE> is a pointer
type, any variable <CODE>CAESAR_B</CODE> of type <CODE>CAESAR_TYPE_SOLVE_1</CODE> must be allocated
before used, for instance using: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_CREATE_SOLVE_1 (&amp;CAESAR_B, ...);</CODE>
</TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
The value of <CODE>CAESAR_NUMBER_OF_BLOCKS</CODE> determines the number of equation
blocks contained in the boolean equation system. Each equation block will
be assigned an unique index in the range 0..<CODE>CAESAR_NUMBER_OF_BLOCKS</CODE> - 1. If
the value of <CODE>CAESAR_NUMBER_OF_BLOCKS</CODE> is zero, the effect is undefined. <P>
The
actual value of the formal parameter <CODE>CAESAR_BLOCK_SIGN</CODE> will be stored and
associated to the boolean equation system pointed to by <CODE>*CAESAR_B</CODE>. It will
be used to assign to each equation block its corresponding sign, indicating
whether the block denotes a minimal or a maximal fixed point. <P>
Precisely,
the actual value of <CODE>CAESAR_BLOCK_SIGN</CODE> should be a pointer to a function
with a parameter <CODE>caesar_block</CODE> that returns <CODE>CAESAR_MINIMAL_FIXED_POINT_SOLVE_1</CODE>
(resp. <CODE>CAESAR_MAXIMAL_FIXED_POINT_SOLVE_1</CODE>) if the equation block of index
<CODE>caesar_block</CODE> denotes a minimal fixed point (resp. a maximal fixed point),
where <CODE>caesar_block</CODE> is in the range 0..<CODE>CAESAR_NUMBER_OF_BLOCKS</CODE> - 1. <P>
The actual
value of the formal parameter <CODE>CAESAR_BLOCK_UNIQUE_RESOLUTION</CODE> will be stored
and associated to the boolean equation system pointed to by <CODE>*CAESAR_B</CODE>. It
will be used to assign to each equation block a boolean indicating whether
only one variable (or several variables) of the block will be solved. <P>
Precisely,
the actual value of <CODE>CAESAR_BLOCK_UNIQUE_RESOLUTION</CODE> should be a pointer
to a function <CODE>caesar_f</CODE> with a parameter <CODE>caesar_block</CODE> that returns <CODE>CAESAR_TRUE</CODE>
(resp. <CODE>CAESAR_FALSE</CODE>) if only one variable (resp. several variables) of the
equation block of index <CODE>caesar_block</CODE> will be solved, where <CODE>caesar_block</CODE>
is in the range 0..<CODE>CAESAR_NUMBER_OF_BLOCKS</CODE> - 1. <P>
Note: If only one variable
of a block will be solved, the function <CODE>caesar_f</CODE> may return for that block
either <CODE>CAESAR_TRUE</CODE>, or <CODE>CAESAR_FALSE</CODE>, without influencing the resolution
result; however, returning <CODE>CAESAR_TRUE</CODE> may increase the performance of
some resolution algorithms. <P>
Note: The equation blocks encoding equivalence
checking problems are typical examples of blocks for which only one variable
must be solved, namely the variable representing the equivalence between
the initial states of two labelled transition systems. <P>
The actual value
of the formal parameter <CODE>CAESAR_BLOCK_SOLVE_MODE</CODE> will be stored and associated
to the boolean equation system pointed to by <CODE>*CAESAR_B</CODE>. It will be used
to assign to each equation block its corresponding resolution mode, determining
which algorithm will be used by the resolution routine associated to the
block. <P>
Precisely, the actual value of <CODE>CAESAR_BLOCK_SOLVE_MODE</CODE> should be
a pointer to a function <CODE>caesar_f</CODE> with a parameter <CODE>caesar_block</CODE> that returns
the resolution mode associated to the equation block of index <CODE>caesar_block</CODE>,
where <CODE>caesar_block</CODE> is in the range 0..<CODE>CAESAR_NUMBER_OF_BLOCKS</CODE> - 1. <P>
If the resolution
mode returned by <CODE>caesar_f</CODE> for some value of <CODE>caesar_block</CODE> is not among the
aforementioned list of available resolution modes, the effect is undefined.
<P>
Note: The resolution algorithms denoted by modes 0, 1, 2, 3, and 4 are
described in the publications [Mat03,Mat06a], where they are named A1,
A2, A3, and A4. The correspondence between modes and the names of the algorithms
is the following: mode 0 corresponds to A1; mode 1 corresponds to A2; mode
2 corresponds to A3; modes 3 and 4, which are symmetric, correspond to
A4. <P>
Note: If the boolean equation system pointed to by <CODE>*CAESAR_B</CODE> contains
several equation blocks, each block may have associated a different resolution
mode. In practice, this is useful for independently optimizing the resolution
of blocks having a particular structure (e.g., acyclic, disjunctive, conjunctive).
<P>
The actual value of the formal parameter <CODE>CAESAR_BLOCK_VARIABLE_AREA</CODE> will
be stored and associated to the boolean equation system pointed to by <CODE>*CAESAR_B</CODE>.
It will be used to assign to each equation block the (constant) size and
(constant) alignment factor of the boolean variables defined in the block.
<P>
Precisely, the actual value of <CODE>CAESAR_BLOCK_VARIABLE_AREA</CODE> should be a pointer
to a function with a parameter <CODE>caesar_block</CODE> that returns the area (which
indicates the length and alignment factor) of the boolean variables defined
in the equation block of index <CODE>caesar_block</CODE>, where <CODE>caesar_block</CODE> is in the
range 0..<CODE>CAESAR_NUMBER_OF_BLOCKS</CODE> - 1. <P>
The actual value of the formal parameter
<CODE>CAESAR_BLOCK_LIMIT_SIZE</CODE> will be stored and associated to the boolean equation
system pointed to by <CODE>*CAESAR_B</CODE>. It will be used to assign to each equation
block the maximal size (number of items) of the internal table associated
to the block. <P>
Precisely, the actual value of <CODE>CAESAR_BLOCK_LIMIT_SIZE</CODE> should
be a pointer to a function <CODE>caesar_f</CODE> with a parameter <CODE>caesar_block</CODE> that
returns the maximal size (number of items) of the internal table associated
to the equation block of index <CODE>caesar_block</CODE>, where <CODE>caesar_block</CODE> is in the
range 0..<CODE>CAESAR_NUMBER_OF_BLOCKS</CODE> - 1. The value returned by <CODE>caesar_f</CODE> must be
less or equal to a predefined value M (see the ``table_1'' library). If it is
equal to zero, it is replaced by the default value M. <P>
The actual value of
the formal parameter <CODE>CAESAR_BLOCK_HASH_SIZE</CODE> will be stored and associated
to the boolean equation system pointed to by <CODE>*CAESAR_B</CODE>. It will be used
to assign to each equation block the size (number of entries) of the hash-table
accompanying the internal table associated to the block. <P>
Precisely, the
actual value of <CODE>CAESAR_BLOCK_HASH_SIZE</CODE> should be a pointer to a function
<CODE>caesar_f</CODE> with a parameter <CODE>caesar_block</CODE> that returns the size (number of
entries) of the hash-table accompanying the internal table associated to
the equation block of index <CODE>caesar_block</CODE>, where <CODE>caesar_block</CODE> is in the
range 0..<CODE>CAESAR_NUMBER_OF_BLOCKS</CODE> - 1. If the value returned by <CODE>caesar_f</CODE> for
some value of <CODE>caesar_block</CODE> is zero, it is replaced with a default value
greater than zero (see the ``table_1'' library). <P>
The actual value of the formal
parameter <CODE>CAESAR_BLOCK_PRIME</CODE> will be stored and associated to the boolean
equation system pointed to by <CODE>*CAESAR_B</CODE>. It will be used to assign to each
equation block a boolean value allowing to adjust the size of the hash-table
accompanying the internal table associated to the block. <P>
Precisely, the
actual value of <CODE>CAESAR_BLOCK_PRIME</CODE> should be a pointer to a function <CODE>caesar_f</CODE>
with a parameter <CODE>caesar_block</CODE> that returns a boolean value which will be
stored and associated to the equation block of index <CODE>caesar_block</CODE>, where
<CODE>caesar_block</CODE> is in the range 0..<CODE>CAESAR_NUMBER_OF_BLOCKS</CODE> - 1. If the value returned
by <CODE>caesar_f</CODE> for some value of <CODE>caesar_block</CODE> is equal to <CODE>CAESAR_TRUE</CODE> and
if the value returned by <CODE>CAESAR_BLOCK_HASH_SIZE</CODE> for that block is not a
prime number, this value will be replaced by the nearest smaller prime
number (since some hash functions require prime modulus). Otherwise, the
value returned by <CODE>CAESAR_BLOCK_HASH_SIZE</CODE> for that block will be kept unchanged
(see the ``table_1'' library). <P>
The actual value of the formal parameter <CODE>CAESAR_VARIABLE_KIND</CODE>
will be stored and associated to the boolean equation system pointed to
by <CODE>*CAESAR_B</CODE>. It will be used as a function returning the kind (disjunctive
or conjunctive) of the boolean variables defined in an equation block of
the system. <P>
Precisely, the actual value of <CODE>CAESAR_VARIABLE_KIND</CODE> should be
a pointer to a function <CODE>caesar_f</CODE> with a parameter <CODE>caesar_variable</CODE> that
returns <CODE>CAESAR_DISJUNCTIVE_VARIABLE_SOLVE_1</CODE> (resp. <CODE>CAESAR_CONJUNCTIVE_VARIABLE_SOLVE_1</CODE>)
if the boolean variable pointed to by <CODE>caesar_variable</CODE> is disjunctive (resp.
conjunctive). The index of the equation block in which the boolean variable
pointed to by <CODE>caesar_variable</CODE> is defined can be obtained within <CODE>caesar_f</CODE>
by calling the function <CODE>CAESAR_CURRENT_BLOCK_SOLVE_1()</CODE> (see below). A pointer
to the boolean equation system containing this block (i.e., the value assigned
to <CODE>*CAESAR_B</CODE>) can be obtained within <CODE>caesar_f</CODE> by calling the function <CODE>CAESAR_CURRENT_SYSTEM_SOLVE_1()</CODE>
(see below). <P>
The actual value of the formal parameter <CODE>CAESAR_VARIABLE_COMPARE</CODE>
will be stored and associated to the boolean equation system pointed to
by <CODE>*CAESAR_B</CODE>. It will be used as a comparison function for the boolean variables
defined in an equation block of the system. <P>
Precisely, the actual value
of <CODE>CAESAR_VARIABLE_COMPARE</CODE> should be a pointer to a comparison function
<CODE>caesar_f</CODE> with two parameters <CODE>caesar_variable_1</CODE> and <CODE>caesar_variable_2</CODE> that
returns <CODE>CAESAR_TRUE</CODE> (resp. <CODE>CAESAR_FALSE</CODE>) if the boolean variables pointed
to by <CODE>caesar_variable_1</CODE> and <CODE>caesar_variable_2</CODE> are equal (resp. different).
The index of the equation block in which the boolean variables pointed
to by <CODE>caesar_variable_1</CODE> and <CODE>caesar_variable_2</CODE> are defined can be obtained
within <CODE>caesar_f</CODE> by calling the function <CODE>CAESAR_CURRENT_BLOCK_SOLVE_1()</CODE>
(see below). A pointer to the boolean equation system containing this block
(i.e., the value assigned to <CODE>*CAESAR_B</CODE>) can be obtained within <CODE>caesar_f</CODE> by
calling the function <CODE>CAESAR_CURRENT_SYSTEM_SOLVE_1()</CODE> (see below). <P>
The actual
value of the formal parameter <CODE>CAESAR_VARIABLE_HASH</CODE> will be stored and associated
to the boolean equation system pointed to by <CODE>*CAESAR_B</CODE>. It will be used
as a hash-function for the boolean variables defined in an equation block
of the system. <P>
Precisely, the actual value of <CODE>CAESAR_VARIABLE_HASH</CODE> should
be a pointer to a hash function <CODE>caesar_f</CODE> with two parameters <CODE>caesar_variable</CODE>
and <CODE>caesar_modulus</CODE> that returns a hash-value computed on the byte string
<CODE>caesar_variable [0]</CODE> up to <CODE>caesar_variable [caesar_size - 1]</CODE>, where the actual
value of <CODE>caesar_size</CODE> will always be equal to the size of the boolean variable
pointed to by <CODE>caesar_variable</CODE>. This hash-value must belong to the range 0..<CODE>caesar_modulus</CODE>-1.
The index of the equation block in which the boolean variable pointed to
by <CODE>caesar_variable</CODE> is defined can be obtained within <CODE>caesar_f</CODE> by calling
the function <CODE>CAESAR_CURRENT_BLOCK_SOLVE_1()</CODE> (see below). A pointer to the
boolean equation system containing this block (i.e., the value assigned to
<CODE>*CAESAR_B</CODE>) can be obtained within <CODE>caesar_f</CODE> by calling the function <CODE>CAESAR_CURRENT_SYSTEM_SOLVE_1()</CODE>
(see below). <P>
The actual value of the formal parameter <CODE>CAESAR_VARIABLE_PRINT</CODE>
will be stored and associated to the boolean equation system pointed to
by <CODE>*CAESAR_B</CODE>. It will be used as a printing procedure for the boolean variables
defined in an equation block of the system. <P>
Precisely, the actual value
of <CODE>CAESAR_VARIABLE_PRINT</CODE> should be a pointer to a printing procedure <CODE>caesar_p</CODE>
with two parameters <CODE>caesar_file</CODE> and <CODE>caesar_variable</CODE> that prints to file
<CODE>caesar_file</CODE> information about the contents of the boolean variable pointed
to by <CODE>caesar_variable</CODE>. The index of the equation block in which the boolean
variable pointed to by <CODE>caesar_variable</CODE> is defined can be obtained within
<CODE>caesar_p</CODE> by calling the function <CODE>CAESAR_CURRENT_BLOCK_SOLVE_1()</CODE> (see below).
A pointer to the boolean equation system containing this block (i.e., the
value assigned to <CODE>*CAESAR_B</CODE>) can be obtained within <CODE>caesar_p</CODE> by calling
the function <CODE>CAESAR_CURRENT_SYSTEM_SOLVE_1()</CODE> (see below). <P>
The actual value
of the formal parameter <CODE>CAESAR_VARIABLE_ITERATE</CODE> will be stored and associated
to the boolean equation system pointed to by <CODE>*CAESAR_B</CODE>. It will be used
as an iterator procedure enumerating all successors of the boolean variables
defined in an equation block of the system. <P>
Any user-defined procedure <CODE>caesar_p</CODE>
can be used as an actual value for formal parameter <CODE>CAESAR_VARIABLE_ITERATE</CODE>,
provided that its declaration has the form: <PRE>        void caesar_p (caesar_variable_1, caesar_variable_2, caesar_loop)
           CAESAR_TYPE_POINTER caesar_variable_1;
           CAESAR_TYPE_POINTER caesar_variable_2;
           void (*caesar_loop) (CAESAR_TYPE_POINTER, CAESAR_TYPE_NATURAL,
              CAESAR_TYPE_POINTER);
           { ... }

</PRE>This procedure <CODE>caesar_p</CODE> enumerates all successors of the boolean variable
pointed to by <CODE>caesar_variable_1</CODE>. The index of the equation block in which
the boolean variable pointed to by <CODE>caesar_variable_1</CODE> is defined can be
obtained within <CODE>caesar_p</CODE> by calling the function <CODE>CAESAR_CURRENT_BLOCK_SOLVE_1()</CODE>
(see below). A pointer to the boolean equation system containing this block
(i.e., the value assigned to <CODE>*CAESAR_B</CODE>) can be obtained within <CODE>caesar_p</CODE> by
calling the function <CODE>CAESAR_CURRENT_SYSTEM_SOLVE_1()</CODE> (see below). At each
iteration performed by <CODE>caesar_p</CODE>, two actions must be carried out: 
<UL>
<LI type=disc>First,
the boolean variable pointed to by <CODE>caesar_variable_2</CODE> must be assigned a
new value, such that ``(<CODE>caesar_variable_1</CODE>, <CODE>caesar_variable_2</CODE>)'' is an edge
of the boolean graph. </LI><P><LI type=disc>Second, the procedure pointed to by <CODE>caesar_loop</CODE> must
be called. The actual value of the formal parameter <CODE>caesar_loop</CODE> is a procedure
<CODE>caesar_q</CODE> whose declaration has the form: <PRE>        void caesar_q (caesar_label, caesar_block_2, caesar_variable_2)
           CAESAR_TYPE_POINTER caesar_label;
           CAESAR_TYPE_NATURAL caesar_block_2;
           CAESAR_TYPE_POINTER caesar_variable_2;
           { ... }

</PRE>Therefore, each call to the procedure pointed to by <CODE>caesar_loop</CODE> must have
the following parameters: <PRE>     (*caesar_loop) (caesar_label, caesar_block_2, caesar_variable_2)

</PRE>Parameter <CODE>caesar_label</CODE> is either a pointer to a memory area containing
additional information associated to the edge ``(<CODE>caesar_variable_1</CODE>, <CODE>caesar_variable_2</CODE>)''
of the boolean graph, or is equal to <CODE>NULL</CODE> if no such information is desired.
Parameter <CODE>caesar_block_2</CODE> is the index of the equation block where the boolean
variable <CODE>caesar_variable_2</CODE> is defined. </LI><P>
</UL>
<P>
Note: The memory area pointed to
by the parameter <CODE>caesar_variable_1</CODE> contains a boolean variable and should
neither be modified, nor freed by the procedure <CODE>caesar_p</CODE>. <P>
Note: The memory
area pointed to by the parameter <CODE>caesar_variable_2</CODE> is already allocated
and should not be freed by the procedure <CODE>caesar_p</CODE>. <P>
Note: The actual value
passed to the parameter <CODE>caesar_label</CODE> when the procedure pointed to by <CODE>caesar_loop</CODE>
is invoked by <CODE>caesar_p</CODE> is meaningless with respect to boolean resolution
(the value passed to <CODE>caesar_label</CODE> will only be copied and possibly compared
to <CODE>NULL</CODE> by the resolution algorithms). The parameter <CODE>caesar_label</CODE> allows
to attach application-specific information to the edges going out of a boolean
variable; this information is retrieved in the diagnostic generated for
that variable. For instance, when using the ``solve_1'' library for model checking,
<CODE>caesar_label</CODE> may contain a pointer to a label of the labelled transition
system on which a temporal logic formula is verified. It is the users' responsibility
to manage the memory area pointed to by <CODE>caesar_label</CODE>; in particular, it
is recommended not to free this memory area until the resolution of the
boolean equation system is finished. <P>
The value of <CODE>CAESAR_INFO</CODE> has no effect
on the execution of procedure <CODE>CAESAR_CREATE_SOLVE_1()</CODE>. Parameter <CODE>CAESAR_INFO</CODE>
is intended to serve for future extensions of this procedure; when using
the current version of the ``solve_1'' library, it is recommended to set this
parameter to <CODE>NULL</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect25" HREF="#sect25"><CODE>CAESAR_CURRENT_SYSTEM_SOLVE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_SOLVE_1 CAESAR_CURRENT_SYSTEM_SOLVE_1 ()
   { ... }

</PRE>This function returns a pointer to the boolean equation system which is
currently under resolution. It should be called only within the functions
and procedures given as actual values for the formal parameters <CODE>CAESAR_VARIABLE_KIND</CODE>,
<CODE>CAESAR_VARIABLE_COMPARE</CODE>, <CODE>CAESAR_VARIABLE_HASH</CODE>, <CODE>CAESAR_VARIABLE_PRINT</CODE>, and
<CODE>CAESAR_VARIABLE_ITERATE</CODE> of procedure <CODE>CAESAR_CREATE_SOLVE_1()</CODE> (see above);
in this case, the result is a pointer to the boolean equation system created
by the call to <CODE>CAESAR_CREATE_SOLVE_1()</CODE>. If this function is called anywhere
else in the application program, the result is undefined. <P>
Note: This function
allows to invoke, within the five aforementioned functions and procedures,
various primitives of the ``solve_1'' library on the current boolean equation
system (e.g., resolution, printing, etc.). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect26" HREF="#sect26"><CODE>CAESAR_CURRENT_BLOCK_SOLVE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_CURRENT_BLOCK_SOLVE_1 ()
   { ... }

</PRE>This function returns the index of the equation block which is currently
under resolution; this block is in turn contained in the boolean equation
system which is currently under resolution, pointed to by the result of
function <CODE>CAESAR_CURRENT_SYSTEM_SOLVE_1()</CODE> (see above). It should be called
only within the functions and procedures given as actual values for the
formal parameters <CODE>CAESAR_VARIABLE_KIND</CODE>, <CODE>CAESAR_VARIABLE_COMPARE</CODE>, <CODE>CAESAR_VARIABLE_HASH</CODE>,
<CODE>CAESAR_VARIABLE_PRINT</CODE>, and <CODE>CAESAR_VARIABLE_ITERATE</CODE> of procedure <CODE>CAESAR_CREATE_SOLVE_1()</CODE>
(see above); in this case, the result is the index of the block, i.e., a
natural number in the range 0..N-1, where N is the number of blocks in the
boolean equation system created by the call to <CODE>CAESAR_CREATE_SOLVE_1()</CODE>.
If this function is called anywhere else in the application program, the
result is undefined. <P>
Note: This function allows to identify the block in
which the boolean variable(s) passed as arguments to the five aforementioned
functions and procedures are defined, and thus to handle these variables
accordingly (the size and the contents of variables defined in different
blocks may differ). It is especially useful when the number of blocks in
the boolean equation system is unknown statically (e.g., when using the ``solve_1''
library for model checking, the number of blocks is inferred from a temporal
logic formula read as input). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect27" HREF="#sect27"><CODE>CAESAR_DELETE_SOLVE_1</CODE></A></H3>
<PRE>void CAESAR_DELETE_SOLVE_1 (CAESAR_B)
   CAESAR_TYPE_SOLVE_1 *CAESAR_B;
   { ... }

</PRE>This procedure frees the memory space corresponding to the boolean equation
system pointed to by <CODE>*CAESAR_B</CODE> using <CODE>CAESAR_DELETE()</CODE>. The boolean variables
stored in internal tables allocated during previous resolutions (if any)
of the boolean equation system are also freed. Afterwards, the <CODE>NULL</CODE> value
is assigned to <CODE>*CAESAR_B</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect28" HREF="#sect28"><CODE>CAESAR_PURGE_BLOCK_SOLVE_1</CODE></A></H3>
<PRE>void CAESAR_PURGE_BLOCK_SOLVE_1 (CAESAR_B, CAESAR_I)
   CAESAR_TYPE_SOLVE_1 CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_I;
   { ... }

</PRE>This procedure reinitializes the information associated to the equation
block of index <CODE>CAESAR_I</CODE> of the boolean equation system pointed to by <CODE>CAESAR_B</CODE>.
The internal table associated to the block is emptied using <CODE>CAESAR_PURGE_TABLE_1()</CODE>.
Afterwards, the block is exactly in the same state as after the creation
of the boolean equation system using <CODE>CAESAR_CREATE_SOLVE_1()</CODE>. <P>
If the block
index <CODE>CAESAR_I</CODE> is outside the range 0..N-1 (where N is the number of blocks
in the system), the result is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect29" HREF="#sect29"><CODE>CAESAR_COMPUTE_SOLVE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_COMPUTE_SOLVE_1 (CAESAR_B, CAESAR_I, CAESAR_V)
   CAESAR_TYPE_SOLVE_1 CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_I;
   CAESAR_TYPE_POINTER CAESAR_V;
   { ... }

</PRE>This function computes the value of the boolean variable pointed to by
<CODE>CAESAR_V</CODE>, which must be defined in the equation block of index <CODE>CAESAR_I</CODE>
of the boolean equation system pointed to by <CODE>CAESAR_B</CODE>. It also sets a field
of type <CODE>CAESAR_TYPE_ERROR_SOLVE_1</CODE> associated to the block, indicating whether
the resolution was carried out successfully or not; this field can be inspected
using the function <CODE>CAESAR_STATUS_COMPUTE_SOLVE_1()</CODE> (see below). <P>
If the block
index <CODE>CAESAR_I</CODE> is outside the range 0..N-1 (where N is the number of blocks
in the system), the result is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect30" HREF="#sect30"><CODE>CAESAR_STATUS_COMPUTE_SOLVE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_ERROR_SOLVE_1 CAESAR_STATUS_COMPUTE_SOLVE_1 (CAESAR_B, CAESAR_I)
   CAESAR_TYPE_SOLVE_1 CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_I;
   { ... }

</PRE>This function returns the status of the last resolution performed by a
call to the function <CODE>CAESAR_COMPUTE_SOLVE_1()</CODE> (see above) on a boolean
variable defined in the equation block of index <CODE>CAESAR_I</CODE> of the boolean
equation system pointed to by <CODE>CAESAR_B</CODE>. <P>
If the block index <CODE>CAESAR_I</CODE> is outside
the range 0..N-1 (where N is the number of blocks in the system), the result
is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect31" HREF="#sect31"><CODE>CAESAR_ITERATE_STABLE_VARIABLE_SOLVE_1</CODE></A></H3>
<PRE>void CAESAR_ITERATE_STABLE_VARIABLE_SOLVE_1 (CAESAR_B, CAESAR_I, CAESAR_V,
                                             CAESAR_VALUE, CAESAR_LOOP)
   CAESAR_TYPE_SOLVE_1 CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_I;
   CAESAR_TYPE_POINTER CAESAR_V;
   CAESAR_TYPE_BOOLEAN *CAESAR_VALUE;
   void (*CAESAR_LOOP) (CAESAR_TYPE_SOLVE_1, CAESAR_TYPE_NATURAL,
      CAESAR_TYPE_POINTER, CAESAR_TYPE_BOOLEAN *);
   { ... }

</PRE>This procedure provides an iterator which enumerates the boolean variables
defined in the equation block of index <CODE>CAESAR_I</CODE> of the boolean equation
system pointed to by <CODE>CAESAR_B</CODE> which are stable, i.e., whose value was computed
by calls to the function <CODE>CAESAR_COMPUTE_SOLVE_1()</CODE> (see above). Only the
variables computed since the last call of this procedure (or, in the case
of the first call of this procedure, since the creation of the boolean
equation system pointed to by <CODE>CAESAR_B</CODE>) are enumerated. At each iteration,
<CODE>*CAESAR_VALUE</CODE> and the boolean variable pointed to by <CODE>CAESAR_V</CODE> are assigned
a new value, such that <CODE>CAESAR_V</CODE> is defined in the block of index <CODE>CAESAR_I</CODE>
of the boolean equation system pointed to by <CODE>CAESAR_B</CODE> and the value computed
for <CODE>CAESAR_V</CODE> is equal to <CODE>*CAESAR_VALUE</CODE>. At each iteration, the procedure
pointed to by <CODE>CAESAR_LOOP</CODE> is invoked, with the following parameters: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT>
<CODE>(*CAESAR_LOOP) (CAESAR_B, CAESAR_I, CAESAR_V, CAESAR_VALUE)</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>Therefore,
any actual parameter supplied for the formal parameter <CODE>CAESAR_LOOP</CODE> must
be a pointer to a procedure <CODE>caesar_p</CODE> whose declaration has the following
form: <PRE>        void caesar_p (caesar_bes, caesar_block, caesar_variable, caesar_value)
           CAESAR_TYPE_SOLVE_1 caesar_bes;
           CAESAR_TYPE_NATURAL caesar_block;
           CAESAR_TYPE_POINTER caesar_variable;
           CAESAR_TYPE_BOOLEAN *caesar_value;
           { ... }

</PRE>Note: Parameters <CODE>CAESAR_V</CODE> and <CODE>CAESAR_VALUE</CODE> must point to (distinct) memory
locations allocated before procedure <CODE>CAESAR_ITERATE_STABLE_VARIABLE_SOLVE_1()</CODE>
is invoked. In no event will <CODE>CAESAR_ITERATE_STABLE_VARIABLE_SOLVE_1()</CODE> and
<CODE>CAESAR_LOOP()</CODE> allocate memory for storing <CODE>CAESAR_V</CODE> and <CODE>CAESAR_VALUE</CODE>. <P>
Note:
More often than not, this procedure will have side-effects. For instance,
this procedure may count the number of stable variables, store them in
a list, a table, ... <P>
Note: It is probably a good programming style to keep
the body of this procedure as short as possible. <P>
Note: The code that implements
<CODE>CAESAR_ITERATE_STABLE_VARIABLE_SOLVE_1()</CODE> in the current version of the
``solve_1'' library is not reentrant, meaning that nested iterations will not
work properly. This implies that any actual procedure <CODE>caesar_p</CODE> passed as
value for formal parameter <CODE>CAESAR_LOOP</CODE> must not call (directly, nor transitively)
<CODE>CAESAR_ITERATE_STABLE_VARIABLE_SOLVE_1()</CODE>. <P>
Note: When invoked to solve a
variable of interest, the function <CODE>CAESAR_COMPUTE_SOLVE_1()</CODE> usually explores
and solves other variables upon which the variable of interest depends.
This implies that the set of variables enumerated by a call to <CODE>CAESAR_ITERATE_STABLE_VARIABLE_SOLVE_1()</CODE>
is usually larger than the set of variables defined in the block of index
<CODE>CAESAR_I</CODE> of the system pointed to by <CODE>CAESAR_B</CODE> on which <CODE>CAESAR_COMPUTE_SOLVE_1()</CODE>
was invoked since the last call of <CODE>CAESAR_ITERATE_STABLE_VARIABLE_SOLVE_1()</CODE>.
<P>
If the block index <CODE>CAESAR_I</CODE> is outside the range 0..N-1 (where N is the number
of blocks in the system), the effect is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect32" HREF="#sect32"><CODE>CAESAR_START_DIAGNOSTIC_SOLVE_1</CODE></A></H3>
<PRE>void CAESAR_START_DIAGNOSTIC_SOLVE_1 (CAESAR_B, CAESAR_I, CAESAR_V,
                                      CAESAR_MINIMAL, CAESAR_P)
   CAESAR_TYPE_SOLVE_1 CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_I;
   CAESAR_TYPE_POINTER CAESAR_V;
   CAESAR_TYPE_BOOLEAN CAESAR_MINIMAL;
   CAESAR_TYPE_POINTER *CAESAR_P;
   { ... }

</PRE>This procedure initializes the diagnostic generation for the boolean variable
pointed to by <CODE>CAESAR_V</CODE>, which must be defined in the equation block of
index <CODE>CAESAR_I</CODE> of the boolean equation system pointed to by <CODE>CAESAR_B</CODE>. It
must be called before starting to explore the diagnostic for the boolean
variable using the procedure <CODE>CAESAR_ITERATE_DIAGNOSTIC_SOLVE_1()</CODE> (see below).
<P>
Diagnostic information is computed by the resolution routines and kept
in the internal tables associated to the blocks. Therefore, diagnostics
can be generated only for boolean variables that were already solved by
calls to <CODE>CAESAR_COMPUTE_SOLVE_1()</CODE> (see above). If the boolean variable pointed
to by <CODE>CAESAR_V</CODE> was previously solved, the address of this boolean variable,
which was stored in the internal table associated to the block of index
<CODE>CAESAR_I</CODE>, is assigned to <CODE>*CAESAR_P</CODE>. If the boolean variable pointed to by
<CODE>CAESAR_V</CODE> was not previously solved or a memory allocation failed during
diagnostic recomputation (see below), the <CODE>NULL</CODE> value is assigned to <CODE>*CAESAR_P</CODE>.
<P>
Note: The memory area pointed to by <CODE>*CAESAR_P</CODE> must neither be modified,
nor freed by the application program. <P>
The value of <CODE>CAESAR_MINIMAL</CODE> influences
the depth of the diagnostic (i.e., the length of the longest sequence without
repeated vertices contained in the diagnostic) that will be generated for
the boolean variable pointed to by <CODE>CAESAR_V</CODE>. If the value of <CODE>CAESAR_MINIMAL</CODE>
is <CODE>CAESAR_TRUE</CODE>, then the diagnostic of the boolean variable will be recomputed
in order to reduce its depth. If the value of <CODE>CAESAR_MINIMAL</CODE> is <CODE>CAESAR_FALSE</CODE>,
the diagnostic of the boolean variable will be left unchanged, i.e., as it
was computed when the variable was solved. <P>
Note: Setting the value of <CODE>CAESAR_MINIMAL</CODE>
to <CODE>CAESAR_TRUE</CODE> usually increases diagnostic generation time, especially
if the variable pointed to by <CODE>CAESAR_V</CODE> was solved using a resolution mode
based on depth-first search, such as resolution modes 0, 2, 3, and 4 (see
the procedure <CODE>CAESAR_CREATE_SOLVE_1()</CODE> above). <P>
If the block index <CODE>CAESAR_I</CODE>
is outside the range 0..N-1 (where N is the number of blocks in the system),
the effect is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect33" HREF="#sect33"><CODE>CAESAR_ITERATE_DIAGNOSTIC_SOLVE_1</CODE></A></H3>
<PRE>void CAESAR_ITERATE_DIAGNOSTIC_SOLVE_1 (CAESAR_B, CAESAR_I1, CAESAR_V1,
                                        CAESAR_L, CAESAR_I2, CAESAR_V2,
                                        CAESAR_LOOP)
   CAESAR_TYPE_SOLVE_1 CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_I1;
   CAESAR_TYPE_POINTER CAESAR_V1;
   CAESAR_TYPE_POINTER *CAESAR_L;
   CAESAR_TYPE_NATURAL *CAESAR_I2;
   CAESAR_TYPE_POINTER *CAESAR_V2;
   void (*CAESAR_LOOP) (CAESAR_TYPE_SOLVE_1, CAESAR_TYPE_NATURAL,
      CAESAR_TYPE_POINTER, CAESAR_TYPE_POINTER *,
      CAESAR_TYPE_NATURAL *, CAESAR_TYPE_POINTER *);
   { ... }

</PRE>This procedure provides an iterator which enumerates the successors of
the boolean variable pointed to by <CODE>CAESAR_V1</CODE> that are contained in the
diagnostic of this variable. The variable pointed to by <CODE>CAESAR_V1</CODE> must be
defined in the equation block of index <CODE>CAESAR_I1</CODE> of the boolean equation
system pointed to by <CODE>CAESAR_B</CODE>. At each iteration, <CODE>*CAESAR_I2</CODE> and <CODE>*CAESAR_V2</CODE>
are respectively assigned a block index and a pointer to a boolean variable
such that ``(<CODE>CAESAR_V1</CODE>, <CODE>*CAESAR_V2</CODE>)'' is an edge of the diagnostic computed
for the boolean variable pointed to by <CODE>CAESAR_V1</CODE>. The boolean variable pointed
to by <CODE>*CAESAR_V2</CODE> is defined in the equation block of index <CODE>*CAESAR_I2</CODE> and
is stored in the internal table associated to that block. Also, <CODE>*CAESAR_L</CODE>
is assigned the information attached to the edge ``(<CODE>CAESAR_V1</CODE>, <CODE>*CAESAR_V2</CODE>)''
by the procedure pointed to by <CODE>caesar_loop</CODE> invoked by the iterator procedure
<CODE>caesar_p</CODE> given as value for formal parameter <CODE>CAESAR_VARIABLE_ITERATE</CODE> when
the boolean equation system pointed to by <CODE>CAESAR_B</CODE> was created (see procedure
<CODE>CAESAR_CREATE_SOLVE_1()</CODE> above). <P>
Note: Parameter <CODE>CAESAR_V1</CODE> must contain the
address of a boolean variable already stored in the internal table associated
to the equation block of index <CODE>CAESAR_I1</CODE>. Such addresses of boolean variables
are obtained as values assigned to the <CODE>*CAESAR_P</CODE> parameter of the <CODE>CAESAR_START_DIAGNOSTIC_SOLVE_1()</CODE>
procedure (see above) or to the <CODE>*CAESAR_V2</CODE> parameter of the <CODE>CAESAR_ITERATE_DIAGNOSTIC_SOLVE_1()</CODE>
procedure. If parameter <CODE>CAESAR_V1</CODE> does not meet this condition, the effect
is undefined. <P>
Note: The memory area pointed to by <CODE>*CAESAR_V2</CODE> should neither
be modified, nor freed by the application program. <P>
Note: The memory area
pointed to by <CODE>*CAESAR_L</CODE> is entirely managed by the application program.
The resolution algorithms manipulate the address of this memory area only
by copying it and possibly by comparing it to <CODE>NULL</CODE> (see also procedure
<CODE>CAESAR_CREATE_SOLVE_1()</CODE> above). <P>
At each iteration, the procedure pointed
to by <CODE>CAESAR_LOOP</CODE> is invoked, with the following parameters: <PRE>        (*CAESAR_LOOP) (CAESAR_B, CAESAR_I1, CAESAR_V1,
                        CAESAR_L, CAESAR_I2, CAESAR_V2)

</PRE>Therefore, any actual parameter supplied for the formal parameter <CODE>CAESAR_LOOP</CODE>
must be a pointer to a procedure <CODE>caesar_p</CODE> whose declaration has the following
form: <PRE>        void caesar_p (caesar_bes, caesar_block_1, caesar_variable_1,
                       caesar_label, caesar_block_2, caesar_variable_2)
           CAESAR_TYPE_SOLVE_1 caesar_bes;
           CAESAR_TYPE_NATURAL caesar_block_1;
           CAESAR_TYPE_POINTER caesar_variable_1;
           CAESAR_TYPE_POINTER *caesar_label;
           CAESAR_TYPE_NATURAL *caesar_block_2;
           CAESAR_TYPE_POINTER *caesar_variable_2;
           { ... }

</PRE>Note: Parameters <CODE>CAESAR_I2</CODE> and <CODE>CAESAR_V2</CODE> must point to (distinct) memory
locations allocated before procedure <CODE>CAESAR_ITERATE_DIAGNOSTIC_SOLVE_1()</CODE>
is invoked. In no event will <CODE>CAESAR_ITERATE_DIAGNOSTIC_SOLVE_1()</CODE> and <CODE>CAESAR_LOOP()</CODE>
allocate memory for storing <CODE>CAESAR_I2</CODE> and <CODE>CAESAR_V2</CODE>. <P>
Note: More often than
not, this procedure will have side-effects. For instance, this procedure
may count the number of successors, store them in a list, a table, ... <P>
Note:
It is probably a good programming style to keep the body of this procedure
as short as possible. <P>
Note: The code that implements <CODE>CAESAR_ITERATE_DIAGNOSTIC_SOLVE_1()</CODE>
in the current version of the ``solve_1'' library is not reentrant, meaning
that nested iterations will not work properly. This implies that any actual
procedure <CODE>caesar_p</CODE> passed as value for formal parameter <CODE>CAESAR_LOOP</CODE> must
not call (directly, nor transitively) <CODE>CAESAR_ITERATE_DIAGNOSTIC_SOLVE_1()</CODE>.
<P>
Additionally, this procedure sets two fields <CODE>caesar_creation</CODE> and <CODE>caesar_truncation</CODE>
of type <CODE>CAESAR_TYPE_NATURAL</CODE> associated to the equation block of index <CODE>CAESAR_I1</CODE>.
After any call to <CODE>CAESAR_ITERATE_DIAGNOSTIC_SOLVE_1()</CODE>, these fields can
be inspected using the two functions <CODE>CAESAR_CREATION_DIAGNOSTIC_SOLVE_1()</CODE>
and <CODE>CAESAR_TRUNCATION_DIAGNOSTIC_SOLVE_1()</CODE> (see below). The values of these
fields are set as follows: 
<UL>
<LI type=disc>If the computation normally succeeds, then <CODE>caesar_creation</CODE>
is set to the number of successors of the variable pointed to by <CODE>CAESAR_V1</CODE>
that are contained in the diagnostic of this variable and <CODE>caesar_truncation</CODE>
is set to zero. </LI><P><LI type=disc>If allocation fails when enumerating the successors (due
to a lack of memory), only a subset of the successors is enumerated. Then
<CODE>caesar_creation</CODE> is set to the number of successors enumerated and <CODE>caesar_truncation</CODE>
is set to the number of successors that have not been enumerated (this
number is greater than zero). </LI><P>
</UL>
<P>
If the block index <CODE>CAESAR_I1</CODE> is outside the
range 0..N-1 (where N is the number of blocks in the system), the effect is
undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect34" HREF="#sect34"><CODE>CAESAR_CREATION_DIAGNOSTIC_SOLVE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_CREATION_DIAGNOSTIC_SOLVE_1 (CAESAR_B, CAESAR_I)
   CAESAR_TYPE_SOLVE_1 CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_I;
   { ... }

</PRE>This function returns the value of the field <CODE>caesar_creation</CODE> associated
to the equation block of index <CODE>CAESAR_I</CODE> of the boolean equation system
pointed to by <CODE>CAESAR_B</CODE>, that was computed during the last call to <CODE>CAESAR_ITERATE_DIAGNOSTIC_SOLVE_1()</CODE>
(see above). This field can only be inspected using this function. <P>
If the
block index <CODE>CAESAR_I</CODE> is outside the range 0..N-1 (where N is the number of
blocks in the system), the effect is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect35" HREF="#sect35"><CODE>CAESAR_TRUNCATION_DIAGNOSTIC_SOLVE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_TRUNCATION_DIAGNOSTIC_SOLVE_1 (CAESAR_B, CAESAR_I)
   CAESAR_TYPE_SOLVE_1 CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_I;
   { ... }

</PRE>This function returns the value of the field <CODE>caesar_truncation</CODE> associated
to the equation block of index <CODE>CAESAR_I</CODE> of the boolean equation system
pointed to by <CODE>CAESAR_B</CODE>, that was computed during the last call to <CODE>CAESAR_ITERATE_DIAGNOSTIC_SOLVE_1()</CODE>
(see above). This field can only be inspected using this function. <P>
If the
block index <CODE>CAESAR_I</CODE> is outside the range 0..N-1 (where N is the number of
blocks in the system), the effect is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect36" HREF="#sect36"><CODE>CAESAR_READ_SOLVE_1</CODE></A></H3>
<PRE>void CAESAR_READ_SOLVE_1 (CAESAR_B, CAESAR_FILE,
                          CAESAR_BLOCK_UNIQUE_RESOLUTION,
                          CAESAR_BLOCK_SOLVE_MODE)
   CAESAR_TYPE_SOLVE_1 *CAESAR_B;
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_BOOLEAN_FUNCTION_SOLVE_1 CAESAR_BLOCK_UNIQUE_RESOLUTION;
   CAESAR_TYPE_NATURAL_FUNCTION_SOLVE_1 CAESAR_BLOCK_SOLVE_MODE;
   { ... }

</PRE>This procedure allocates a boolean equation system using <CODE>CAESAR_CREATE_SOLVE_1()</CODE>
and assigns its address to <CODE>*CAESAR_B</CODE>. If the allocation fails, the <CODE>NULL</CODE>
value is assigned to <CODE>*CAESAR_B</CODE>. <P>
The value of <CODE>CAESAR_FILE</CODE> determines the
file from which the boolean equation system (represented in textual form)
will be read. Before this procedure is called, <CODE>CAESAR_FILE</CODE> must have been
properly opened, for instance using <CODE>fopen(3)</CODE>. <P>
The boolean equation system
file is parsed: its contents is analyzed and stored into the boolean equation
system <CODE>*CAESAR_B</CODE>. <P>
So doing, various error conditions may occur: <CODE>CAESAR_FILE</CODE>
is empty or has syntax errors; it has semantic errors (such as block or
variable indexes out of range), etc. In such case, a detailed error message
is displayed using the <CODE>CAESAR_WARNING()</CODE> procedure, and the <CODE>NULL</CODE> value is
assigned to <CODE>*CAESAR_B</CODE>. <P>
The actual values of the two remaining formal parameters
will be stored and associated to the boolean equation system pointed to
by <CODE>*CAESAR_B</CODE>. <P>
The value of <CODE>CAESAR_BLOCK_UNIQUE_RESOLUTION</CODE> determines, for
each equation block, whether only one variable (or several variables) of
the block will be solved. If the value of <CODE>CAESAR_BLOCK_UNIQUE_RESOLUTION</CODE>
is different from <CODE>NULL</CODE>, it will be given to the corresponding parameter
in the call to <CODE>CAESAR_CREATE_SOLVE_1()</CODE> used to create the boolean equation
system pointed to by <CODE>*CAESAR_B</CODE>. If the value of <CODE>CAESAR_BLOCK_UNIQUE_RESOLUTION</CODE>
is <CODE>NULL</CODE>, then the value of the corresponding parameter in the call to <CODE>CAESAR_CREATE_SOLVE_1()</CODE>
will be determined by the contents of <CODE>CAESAR_FILE</CODE>. <P>
The value of <CODE>CAESAR_BLOCK_SOLVE_MODE</CODE>
determines, for each equation block, its corresponding resolution mode,
determining which algorithm will be used by the resolution routine associated
to the block. If the value of <CODE>CAESAR_BLOCK_SOLVE_MODE</CODE> is different from
<CODE>NULL</CODE>, it will be given to the corresponding parameter in the call to <CODE>CAESAR_CREATE_SOLVE_1()</CODE>
used to create the boolean equation system pointed to by <CODE>*CAESAR_B</CODE>. If the
value of <CODE>CAESAR_BLOCK_SOLVE_MODE</CODE> is <CODE>NULL</CODE>, then the value of the corresponding
parameter in the call to <CODE>CAESAR_CREATE_SOLVE_1()</CODE> will be determined by
the contents of <CODE>CAESAR_FILE</CODE>. <P>
Note: These two parameters allow to overwrite
the values of the corresponding parameters of <CODE>CAESAR_CREATE_SOLVE_1()</CODE> determined
by the contents of <CODE>CAESAR_FILE</CODE>. This is useful for applying last minute
changes on the resolution of the boolean equation system read from <CODE>CAESAR_FILE</CODE>.
<P>
The contents of the boolean variables defined in the equation blocks of
the system pointed to by <CODE>*CAESAR_B</CODE> are natural numbers, i.e., values of type
<CODE>CAESAR_TYPE_NATURAL</CODE>. Each variable <CODE>Xi</CODE> defined by an equation of the system
is represented by the value <CODE>i</CODE> of its index. As an example, the following
portion of C code implements the resolution of a boolean equation system
created using <CODE>CAESAR_READ_SOLVE_1()</CODE>: <PRE>        CAESAR_TYPE_SOLVE_1 caesar_bes;
        CAESAR_TYPE_FILE caesar_file;
        CAESAR_TYPE_NATURAL caesar_variable;
        CAESAR_TYPE_BOOLEAN caesar_value;
 
        if ((caesar_file = fopen ("file.bes", "r")) != NULL) {
           CAESAR_READ_SOLVE_1 (&amp;caesar_bes, caesar_file, NULL, NULL);
           if (caesar_bes != NULL) {
              /* resolution of variable 0 defined in the block of index
0 */
              caesar_variable = 0;
              caesar_value = CAESAR_COMPUTE_SOLVE_1 (caesar_bes, 0,
                                (CAESAR_TYPE_POINTER) (&amp;caesar_variable));
           }
        }

</PRE><P>
<P>
 <HR><BR>
 
<H3><A NAME="sect37" HREF="#sect37"><CODE>CAESAR_WRITE_SOLVE_1</CODE></A></H3>
<PRE>void CAESAR_WRITE_SOLVE_1 (CAESAR_B, CAESAR_I, CAESAR_V,
                           CAESAR_FILE, CAESAR_DIAGNOSTIC)
   CAESAR_TYPE_SOLVE_1 CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_I;
   CAESAR_TYPE_POINTER CAESAR_V;
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_BOOLEAN CAESAR_DIAGNOSTIC;
   { ... }

</PRE>This procedure writes a portion of the boolean equation system pointed
to by <CODE>CAESAR_B</CODE> in textual form into the file <CODE>CAESAR_FILE</CODE>. The portion written
contains equations defining boolean variables upon which the boolean variable
pointed to by <CODE>CAESAR_V</CODE>, which must be defined in the equation block of
index <CODE>CAESAR_I</CODE>, depends either directly, or transitively. <P>
Before this procedure
is called, <CODE>CAESAR_FILE</CODE> must have been properly opened, for instance using
<CODE>fopen(3)</CODE>. <P>
So doing, various error conditions may occur: <CODE>CAESAR_FILE</CODE> is not
writable; a memory allocation failed, etc. In such case, a detailed error
message is displayed using the <CODE>CAESAR_WARNING()</CODE> procedure and the portion
of boolean equation system written into <CODE>CAESAR_FILE</CODE> may be truncated. <P>
If
the block index <CODE>CAESAR_I</CODE> is outside the range 0..N-1 (where N is the number
of blocks in the system), the effect is undefined. <P>
If the value of <CODE>CAESAR_DIAGNOSTIC</CODE>
is equal to <CODE>CAESAR_FALSE</CODE>, the portion of boolean equation system written
into <CODE>CAESAR_FILE</CODE> will contain all equations defining the boolean variables
upon which the boolean variable pointed to by <CODE>CAESAR_V</CODE> depends. Otherwise,
this portion will contain only the equations defining the variables contained
in the diagnostic for the variable pointed to by <CODE>CAESAR_V</CODE>, which must have
been solved previously by using <CODE>CAESAR_COMPUTE_SOLVE_1()</CODE>; if this is not
the case, an error message is displayed using the <CODE>CAESAR_WARNING()</CODE> procedure
and nothing is written into <CODE>CAESAR_FILE</CODE>. <P>
Note: This procedure does not perform
the resolution of the variable pointed to by <CODE>CAESAR_V</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect38" HREF="#sect38"><CODE>CAESAR_FORMAT_SOLVE_1</CODE></A></H3>
<PRE>CAESAR_FORMAT CAESAR_FORMAT_SOLVE_1 (CAESAR_B, CAESAR_FORMAT)
   CAESAR_TYPE_SOLVE_1 CAESAR_B;
   CAESAR_TYPE_FORMAT CAESAR_FORMAT;
   { ... }

</PRE>This function allows to control the format under which the boolean equation
system pointed to by <CODE>CAESAR_B</CODE> will be printed by the procedure <CODE>CAESAR_PRINT_SOLVE_1()</CODE>
(see below). Currently, the following formats are available: <P>

<UL>
<LI type=disc>With format
0, statistical information concerning the boolean equation system is displayed
such as: the size of variables and resolution modes for each equation block
of the system, the number of boolean variables explored during resolution,
etc. </LI><P><LI type=disc>With format 1, statistical information concerning the internal tables
associated to the equation blocks of the system is printed using the procedure
<CODE>CAESAR_PRINT_TABLE_1()</CODE>. </LI><P><LI type=disc>With format 2, the contents of the internal tables
associated to the equation blocks of the system are printed using the procedure
<CODE>CAESAR_PRINT_TABLE_1()</CODE>. </LI><P><LI type=disc>(no other format available yet) </LI><P>
</UL>
<P>
By default, the
current format of each boolean equation system is initialized to 0. <P>
When
called with <CODE>CAESAR_FORMAT</CODE> between 0 and 2, this fonction sets the current
format of <CODE>CAESAR_B</CODE> to <CODE>CAESAR_FORMAT</CODE> and returns an undefined result. <P>
When
called with another value of <CODE>CAESAR_FORMAT</CODE>, this function does not modify
the current format of <CODE>CAESAR_B</CODE> but returns a result defined as follows.
If <CODE>CAESAR_FORMAT</CODE> is equal to the constant <CODE>CAESAR_CURRENT_FORMAT</CODE>, the result
is the value of the current format of <CODE>CAESAR_B</CODE>. If <CODE>CAESAR_FORMAT</CODE> is equal
to the constant <CODE>CAESAR_MAXIMAL_FORMAT</CODE>, the result is the maximal format
value (i.e., 2). In all other cases, the effect of this function is undefined.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect39" HREF="#sect39"><CODE>CAESAR_MAX_FORMAT_SOLVE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_MAX_FORMAT_SOLVE_1 ()
   { ... }

</PRE>Caution! This function is deprecated. It should no longer be used, as it
might be removed from future versions of the <I>OPEN/CAESAR</I>. Use function <CODE>CAESAR_FORMAT_SOLVE_1()</CODE>
instead, called with argument <CODE>CAESAR_MAXIMAL_FORMAT</CODE>. <P>
This function returns
the maximal format value available for printing boolean equation systems.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect40" HREF="#sect40"><CODE>CAESAR_PRINT_SOLVE_1</CODE></A></H3>
<PRE>void CAESAR_PRINT_SOLVE_1 (CAESAR_FILE, CAESAR_B)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_SOLVE_1 CAESAR_B;
   { ... }

</PRE>This procedure prints on file <CODE>CAESAR_FILE</CODE> an ASCII text containing various
informations about the boolean equation system pointed to by <CODE>CAESAR_B</CODE>. The
nature of these informations is determined by the current format of the
boolean equation system pointed to by <CODE>CAESAR_B</CODE>. <P>
Before this procedure is
called, <CODE>CAESAR_FILE</CODE> must have been properly opened, for instance using
<CODE>fopen(3)</CODE>. <P>

<H2><A NAME="sect41" HREF="#sect41">Bibliography</A></H2>
[Mat03] Radu Mateescu. A Generic On-the-Fly Solver for
Alternation-Free Boolean Equation Systems. In Hubert Garavel and John Hatcliff,
editors, Proceedings of the 9th International Conference on Tools and Algorithms
for the Construction and Analysis of Systems TACAS'2003 (Warsaw, Poland),
Lecture Notes in Computer Science vol. 2619, pages 81--96. Springer Verlag,
April 2003. Available from <A HREF="http://cadp.inria.fr/publications/Mateescu-03-a.html"><CODE>http://cadp.inria.fr/publications/Mateescu-03-a.html</CODE></A>

<P>
[Mat06] Radu Mateescu. CAESAR_SOLVE: A Generic Library for On-the-Fly Resolution
of Alternation-Free Boolean Equation Systems. Springer International Journal
on Software Tools for Technology Transfer (STTT), 8(1):37--56, February 2006.
Available from <A HREF="http://cadp.inria.fr/publications/Mateescu-06-a.html"><CODE>http://cadp.inria.fr/publications/Mateescu-06-a.html</CODE></A>
 <P>
<P>
 <HR><BR>
 
<H2><A NAME="sect42" HREF="#sect42">Author(s)</A></H2>
Radu Mateescu 
<H2><A NAME="sect43" HREF="#sect43">Files</A></H2>
 
<DL><DD><DL COMPACT>

<DT><B>$CADP/incl/caesar_graph.h</B> </DT>
<DD>interface of the
graph module </DD><P>

<DT><B>$CADP/incl/caesar_*.h</B> </DT>
<DD>interfaces of the storage module </DD><P>

<DT><B>$CADP/bin.`arch`/libcaesar.a</B>
</DT>
<DD>object code of the storage module </DD><P>

<DT><B>$CADP/src/open_caesar/*.c</B> </DT>
<DD>source code
of various exploration modules </DD><P>

<DT><B>$CADP/com/lotos.open</B> </DT>
<DD>shell script to run
OPEN/CAESAR  </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect44" HREF="#sect44">See Also</A></H2>
Reference Manuals of OPEN/CAESAR, CAESAR, and CAESAR.ADT,
<A HREF="lotos.open.html"><B>lotos.open</B></A>
, <A HREF="caesar.html"><B>caesar</B></A>
, <A HREF="caesar.adt.html"><B>caesar.adt</B></A>
 <P>
Additional information
is available from the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives
for installation are given in files <B>$CADP/INSTALLATION_*.</B> <P>
Recent changes
and improvements to this software are reported and commented in file <B>$CADP/HISTORY.</B>

<H2><A NAME="sect45" HREF="#sect45">Bugs</A></H2>
Known bugs are described in the Reference Manual of OPEN/CAESAR. Please
report new bugs to <A HREF="mailto:cadp@inria.fr?Subject=CADP-Bug-Report">cadp@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Purpose</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Usage</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Boolean Equation Systems</A></LI>
<LI><A NAME="toc4" HREF="#sect4">on the Fly Resolution</A></LI>
<LI><A NAME="toc5" HREF="#sect5">Boolean Graphs</A></LI>
<LI><A NAME="toc6" HREF="#sect6">Resolution Modes</A></LI>
<LI><A NAME="toc7" HREF="#sect7">Internal Representation</A></LI>
<LI><A NAME="toc8" HREF="#sect8">Diagnostic Generation</A></LI>
<LI><A NAME="toc9" HREF="#sect9">Description</A></LI>
<LI><A NAME="toc10" HREF="#sect10">Features</A></LI>
<UL>
<LI><A NAME="toc11" HREF="#sect11">CAESAR_TYPE_SOLVE_1</A></LI>
<LI><A NAME="toc12" HREF="#sect12">CAESAR_TYPE_BLOCK_SIGN_SOLVE_1</A></LI>
<LI><A NAME="toc13" HREF="#sect13">CAESAR_MINIMAL_FIXED_POINT_SOLVE_1</A></LI>
<LI><A NAME="toc14" HREF="#sect14">CAESAR_MAXIMAL_FIXED_POINT_SOLVE_1</A></LI>
<LI><A NAME="toc15" HREF="#sect15">CAESAR_TYPE_VARIABLE_KIND_SOLVE_1</A></LI>
<LI><A NAME="toc16" HREF="#sect16">CAESAR_DISJUNCTIVE_VARIABLE_SOLVE_1</A></LI>
<LI><A NAME="toc17" HREF="#sect17">CAESAR_CONJUNCTIVE_VARIABLE_SOLVE_1</A></LI>
<LI><A NAME="toc18" HREF="#sect18">CAESAR_TYPE_BLOCK_SIGN_FUNCTION_SOLVE_1</A></LI>
<LI><A NAME="toc19" HREF="#sect19">CAESAR_TYPE_VARIABLE_KIND_FUNCTION_SOLVE_1</A></LI>
<LI><A NAME="toc20" HREF="#sect20">CAESAR_TYPE_AREA_FUNCTION_SOLVE_1</A></LI>
<LI><A NAME="toc21" HREF="#sect21">CAESAR_TYPE_BOOLEAN_FUNCTION_SOLVE_1</A></LI>
<LI><A NAME="toc22" HREF="#sect22">CAESAR_TYPE_NATURAL_FUNCTION_SOLVE_1</A></LI>
<LI><A NAME="toc23" HREF="#sect23">CAESAR_TYPE_ERROR_SOLVE_1</A></LI>
<LI><A NAME="toc24" HREF="#sect24">CAESAR_CREATE_SOLVE_1</A></LI>
<LI><A NAME="toc25" HREF="#sect25">CAESAR_CURRENT_SYSTEM_SOLVE_1</A></LI>
<LI><A NAME="toc26" HREF="#sect26">CAESAR_CURRENT_BLOCK_SOLVE_1</A></LI>
<LI><A NAME="toc27" HREF="#sect27">CAESAR_DELETE_SOLVE_1</A></LI>
<LI><A NAME="toc28" HREF="#sect28">CAESAR_PURGE_BLOCK_SOLVE_1</A></LI>
<LI><A NAME="toc29" HREF="#sect29">CAESAR_COMPUTE_SOLVE_1</A></LI>
<LI><A NAME="toc30" HREF="#sect30">CAESAR_STATUS_COMPUTE_SOLVE_1</A></LI>
<LI><A NAME="toc31" HREF="#sect31">CAESAR_ITERATE_STABLE_VARIABLE_SOLVE_1</A></LI>
<LI><A NAME="toc32" HREF="#sect32">CAESAR_START_DIAGNOSTIC_SOLVE_1</A></LI>
<LI><A NAME="toc33" HREF="#sect33">CAESAR_ITERATE_DIAGNOSTIC_SOLVE_1</A></LI>
<LI><A NAME="toc34" HREF="#sect34">CAESAR_CREATION_DIAGNOSTIC_SOLVE_1</A></LI>
<LI><A NAME="toc35" HREF="#sect35">CAESAR_TRUNCATION_DIAGNOSTIC_SOLVE_1</A></LI>
<LI><A NAME="toc36" HREF="#sect36">CAESAR_READ_SOLVE_1</A></LI>
<LI><A NAME="toc37" HREF="#sect37">CAESAR_WRITE_SOLVE_1</A></LI>
<LI><A NAME="toc38" HREF="#sect38">CAESAR_FORMAT_SOLVE_1</A></LI>
<LI><A NAME="toc39" HREF="#sect39">CAESAR_MAX_FORMAT_SOLVE_1</A></LI>
<LI><A NAME="toc40" HREF="#sect40">CAESAR_PRINT_SOLVE_1</A></LI>
</UL>
<LI><A NAME="toc41" HREF="#sect41">Bibliography</A></LI>
<LI><A NAME="toc42" HREF="#sect42">Author(s)</A></LI>
<LI><A NAME="toc43" HREF="#sect43">Files</A></LI>
<LI><A NAME="toc44" HREF="#sect44">See Also</A></LI>
<LI><A NAME="toc45" HREF="#sect45">Bugs</A></LI>
</UL>
</BODY></HTML>
