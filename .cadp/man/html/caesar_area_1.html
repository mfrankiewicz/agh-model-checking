  <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>caesar_area_1 manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
caesar_area_1 - the ``area_1'' library of OPEN/CAESAR 
<H2><A NAME="sect1" HREF="#sect1">Purpose</A></H2>
The ``area_1''
library provides primitives for managing ``areas'', which are memory chunks
of various sizes and alignment factors. This library provides for genericity
by allowing different objects (states, labels, character strings, user-defined
memory chunks) to be handled uniformly. <P>
<P>

<H2><A NAME="sect2" HREF="#sect2">Usage</A></H2>
The ``area_1'' library consists
of: 
<UL>
<LI type=disc>a predefined header file <CODE>caesar_area_1.h</CODE>; </LI><P><LI type=disc>the precompiled library file
<CODE>libcaesar.a</CODE>, which implements the features described in <CODE>caesar_area_1.h</CODE>. </LI><P>
</UL>
<P>
Note:
The ``area_1'' library is a software layer built above the primitives offered
by the ``standard'' and ``hash'' libraries, and by the <I>OPEN/CAESAR</I> graph module.
<P>
<P>

<H2><A NAME="sect3" HREF="#sect3">Description</A></H2>
An ``area'' is basically a memory chunk (i.e., a sequence of contiguous
bytes) characterized by its (fixed) size and its alignment factor (see
the description of <CODE>CAESAR_ALIGNMENT_POINTER()</CODE> in the ``standard'' library for
a definition of the alignment factor). <P>
There are five different kinds of
areas: 
<UL>
<LI type=disc>an ``ordinary area'' may contain any kind of data; the precise contents
of an ordinary area is left to the user and is not specified in the context
of the ``area_1'' library; </LI><P><LI type=disc>an ``empty area'' is a special area of zero bytes; </LI><P><LI type=disc>a
``state area'' is a special area dedicated to contain a state, as described
in the graph module, i.e., a value of type <CODE>CAESAR_BODY_STATE</CODE>; </LI><P><LI type=disc>a ``label area''
is a special area dedicated to contain a label, as described in the graph
module, i.e., a value of type <CODE>CAESAR_BODY_LABEL</CODE>; </LI><P><LI type=disc>a ``string area'' is a special
area dedicated to contain a pointer to a null-terminated character string,
i.e., a value of type <CODE>CAESAR_TYPE_STRING</CODE>. Notice that a string area does not
contain a (variable length) character string but a (fixed length) pointer
to a (variable length) character string. </LI><P>
</UL>
<P>
<P>

<H2><A NAME="sect4" HREF="#sect4">Features</A></H2>
<P>
 <HR><BR>
 
<H3><A NAME="sect5" HREF="#sect5"><CODE>CAESAR_TYPE_AREA_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_NATURAL CAESAR_TYPE_AREA_1;
#define CAESAR_EXPONENT_EMPTY_AREA_1     0
#define CAESAR_EXPONENT_STATE_AREA_1     1
#define CAESAR_EXPONENT_LABEL_AREA_1     2
#define CAESAR_EXPONENT_STRING_AREA_1    3

</PRE>Concretely, the type <CODE>CAESAR_TYPE_AREA_1</CODE> is represented as a numerical type
(32-bit or 64-bit natural number depending on the machine architecture). Logically,
a value of type <CODE>CAESAR_TYPE_AREA_1</CODE> is a pair (length field, exponent field),
where: <P>

<UL>
<LI type=disc>the exponent field is an unsigned natural number coded on the 4
highest bits (thus, in the range 0..15), and </LI><P><LI type=disc>the length field is an unsigned
natural number coded on the remaining (all but 4) lowest bits, i.e., either
coded on 28 bits (and thus, in the range 0...268,435,455) on 32-bit machines,
or coded on 60 bits (and thus, in the range 0...1,152,921,504,606,846,975)
on 64-bit machines. </LI><P>
</UL>
<P>
The different kinds of areas are represented as follows:
<P>

<UL>
<LI type=disc>for an ordinary area, the length field is different from zero and represents
the size (in bytes) of the area; if the exponent field is equal to a value
f different from zero, the alignment factor (in bytes) of the area is equal
to 2^{f-1}; the case in which the exponent field is equal to zero corresponds
to a backward compatibility situation, which is now obsolete and in which
the alignment factor is guessed empirically from the value of the length
field (see the definition of <CODE>CAESAR_ALIGNMENT_AREA_1()</CODE> below); </LI><P><LI type=disc>for an empty
area, the length field is equal to zero and the exponent field is equal
to the constant <CODE>CAESAR_EXPONENT_EMPTY_AREA_1</CODE>; </LI><P><LI type=disc>for a state area, the length
field is equal to zero and the exponent field is equal to the constant
<CODE>CAESAR_EXPONENT_STATE_AREA_1</CODE>; </LI><P><LI type=disc>for a label area, the length field is equal
to zero and the exponent field is equal to the constant <CODE>CAESAR_EXPONENT_LABEL_AREA_1</CODE>;
</LI><P><LI type=disc>for a string area, the length field is equal to zero and the exponent field
is equal to the constant <CODE>CAESAR_EXPONENT_STRING_AREA_1</CODE>; </LI><P><LI type=disc>any other case
in which the length field is equal to zero is undefined. </LI><P>
</UL>
<P>
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect6" HREF="#sect6"><CODE>CAESAR_LENGTH_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_LENGTH_AREA_1 (CAESAR_AREA)
   CAESAR_TYPE_AREA_1 CAESAR_AREA;
   { ... }

</PRE>This function returns the length field of the area <CODE>CAESAR_AREA</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect7" HREF="#sect7"><CODE>CAESAR_EXPONENT_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_EXPONENT_AREA_1 (CAESAR_AREA)
   CAESAR_TYPE_AREA_1 CAESAR_AREA;
   { ... }

</PRE>This function returns the exponent field of the area <CODE>CAESAR_AREA</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect8" HREF="#sect8"><CODE>CAESAR_AREA_1</CODE></A></H3>
<PRE>CAESAR_AREA_1 CAESAR_AREA_1 (CAESAR_LENGTH, CAESAR_EXPONENT)
   CAESAR_TYPE_NATURAL CAESAR_LENGTH;
   CAESAR_TYPE_NATURAL CAESAR_EXPONENT;
   { ... }

</PRE>This function returns the area with a length field equal to <CODE>CAESAR_LENGTH</CODE>
and an exponent field equal to <CODE>CAESAR_EXPONENT</CODE>. <P>
Note: this function does
not check that its parameters are consistent, e.g., that for an ordinary
area the alignment (specified by the exponent field) is an exact divider
of the size (specified by the length field). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect9" HREF="#sect9"><CODE>CAESAR_EMPTY_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_AREA_1 CAESAR_EMPTY_AREA_1 ()
   { ... }

</PRE>This function returns the area with a length field equal to 0 and an exponent
field equal to <CODE>CAESAR_EXPONENT_EMPTY_AREA_1</CODE> (i.e., corresponding to an empty
area). <P>
Note: For backward compatibility reasons, <CODE>CAESAR_EMPTY_AREA_1()</CODE> is
equal to 0. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect10" HREF="#sect10"><CODE>CAESAR_STATE_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_AREA_1 CAESAR_STATE_AREA_1 ()
   { ... }

</PRE>This function returns the area with a length field equal to 0 and an exponent
field equal to <CODE>CAESAR_EXPONENT_STATE_AREA_1</CODE> (i.e., corresponding to a state
area). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect11" HREF="#sect11"><CODE>CAESAR_LABEL_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_AREA_1 CAESAR_LABEL_AREA_1 ()
   { ... }

</PRE>This function returns the area with a length field equal to 0 and an exponent
field equal to <CODE>CAESAR_EXPONENT_LABEL_AREA_1</CODE> (i.e., corresponding to a label
area). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect12" HREF="#sect12"><CODE>CAESAR_STRING_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_AREA_1 CAESAR_STRING_AREA_1 ()
   { ... }

</PRE>This function returns the area with a length field equal to 0 and an exponent
field equal to <CODE>CAESAR_EXPONENT_STRING_AREA_1</CODE> (i.e., corresponding to a string
area). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect13" HREF="#sect13"><CODE>CAESAR_BYTE_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_AREA_1 CAESAR_BYTE_AREA_1 (CAESAR_LENGTH)
   CAESAR_TYPE_NATURAL CAESAR_LENGTH;
   { ... }

</PRE>This function returns the area with a length field equal to <CODE>CAESAR_LENGTH</CODE>
and an exponent field corresponding to a byte or a character (i.e., a memory
area with an alignment of 1). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect14" HREF="#sect14"><CODE>CAESAR_NATURAL_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_AREA_1 CAESAR_NATURAL_AREA_1 (CAESAR_LENGTH)
   CAESAR_TYPE_NATURAL CAESAR_LENGTH;
   { ... }

</PRE>This function returns the area with a length field equal to <CODE>CAESAR_LENGTH</CODE>
and an exponent field corresponding to a natural or integer number (i.e.,
a memory area with an alignment suitable for a value of type <CODE>CAESAR_TYPE_NATURAL</CODE>
or <CODE>CAESAR_TYPE_INTEGER</CODE>). <P>
Note: In principle, such an area should not contain
pointers. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect15" HREF="#sect15"><CODE>CAESAR_POINTER_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_AREA_1 CAESAR_POINTER_AREA_1 (CAESAR_LENGTH)
   CAESAR_TYPE_NATURAL CAESAR_LENGTH;
   { ... }

</PRE>This function returns the area with a length field equal to <CODE>CAESAR_LENGTH</CODE>
and an exponent field corresponding to a pointer (i.e., a memory area with
an alignment equal to <CODE>CAESAR_ALIGNMENT_POINTER()</CODE>). <P>
Note: In principle, such
an area should contain at least one pointer, because pointers usually have
the strongest alignment constraints. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect16" HREF="#sect16"><CODE>CAESAR_SIZE_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_SIZE_AREA_1 (CAESAR_AREA)
   CAESAR_TYPE_AREA_1 CAESAR_AREA;
   { ... }

</PRE>This function returns the size (in bytes) of the area <CODE>CAESAR_AREA</CODE>: 
<UL>
<LI type=disc>for
an ordinary area, this size is equal to the length field of <CODE>CAESAR_AREA</CODE>;
</LI><P><LI type=disc>for an empty area, this size is equal to zero; </LI><P><LI type=disc>for a state area, this size
is given by the <CODE>CAESAR_SIZE_STATE()</CODE> function exported by the graph module;
</LI><P><LI type=disc>for a label area, this size is given by the <CODE>CAESAR_SIZE_LABEL()</CODE> function
exported by the graph module; </LI><P><LI type=disc>for a string area, this size is equal to
<CODE>CAESAR_SIZE_POINTER()</CODE> (which corresponds to the size of a character string
pointer). </LI><P>
</UL>
<P>
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect17" HREF="#sect17"><CODE>CAESAR_HASH_SIZE_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_HASH_SIZE_AREA_1 (CAESAR_AREA)
   CAESAR_TYPE_AREA_1 CAESAR_AREA;
   { ... }

</PRE>This function returns the ``hashable'' size (in bytes) of the area <CODE>CAESAR_AREA</CODE>:

<UL>
<LI type=disc>for an ordinary area, this size is equal to the length field of <CODE>CAESAR_AREA</CODE>
(this is an arbitrary definition, since the actual contents of <CODE>CAESAR_AREA</CODE>
are unknown); </LI><P><LI type=disc>for an empty area, this size is equal to zero (which expresses
the fact that an empty area is not appropriate for hashing); </LI><P><LI type=disc>for a state
area, this size is given by the <CODE>CAESAR_HASH_SIZE_STATE()</CODE> function exported
by the graph module; </LI><P><LI type=disc>for a label area, this size is given by the <CODE>CAESAR_HASH_SIZE_LABEL()</CODE>
function exported by the graph module; </LI><P><LI type=disc>for a string area, this size is
equal to zero (which expresses the fact that a character string pointer,
i.e., a value of type <CODE>(CAESAR_TYPE_STRING *)</CODE>, is not directly appropriate
for hashing). </LI><P>
</UL>
<P>
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect18" HREF="#sect18"><CODE>CAESAR_ALIGNMENT_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_ALIGNMENT_AREA_1 (CAESAR_AREA)
   CAESAR_TYPE_AREA_1 CAESAR_AREA;
   { ... }

</PRE>This function returns the alignment factor (in bytes) of the area <CODE>CAESAR_AREA</CODE>:

<UL>
<LI type=disc>for an ordinary area whose exponent field f is different from zero, the
alignment factor is equal to 2^{f-1}; </LI><P><LI type=disc>for an ordinary area whose exponent
field is equal to zero (backward compatibility case), the alignment factor
is guessed empirically from the size of <CODE>CAESAR_AREA</CODE> (precisely, the alignment
factor will be the largest value in the set {1, 2, 4, 8} that divides the
size of <CODE>CAESAR_AREA</CODE> exactly; this is an arbitrary definition, since the
actual contents of <CODE>CAESAR_AREA</CODE> are unknown); </LI><P><LI type=disc>for an empty area, this alignment
factor is equal to one (which expresses the fact that an empty area has
no specific alignment constraint); </LI><P><LI type=disc>for a state area, this alignment factor
is given by the <CODE>CAESAR_ALIGNMENT_STATE()</CODE> function exported by the graph
module; </LI><P><LI type=disc>for a label area, this alignment factor is given by the <CODE>CAESAR_ALIGNMENT_LABEL()</CODE>
function exported by the graph module; </LI><P><LI type=disc>for a string area, this alignment
factor is equal to <CODE>CAESAR_ALIGNMENT_POINTER()</CODE> (which corresponds to the
alignment factor of a character string pointer). </LI><P>
</UL>
<P>
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect19" HREF="#sect19"><CODE>CAESAR_COPY_AREA_1</CODE></A></H3>
<PRE>void CAESAR_COPY_AREA_1 (CAESAR_P1, CAESAR_P2, CAESAR_SIZE)
   CAESAR_TYPE_POINTER CAESAR_P1;
   CAESAR_TYPE_POINTER CAESAR_P2;
   CAESAR_TYPE_NATURAL CAESAR_SIZE;
   { ... }

</PRE>This procedure copies the memory area (of <CODE>CAESAR_SIZE</CODE> bytes) pointed to
by <CODE>CAESAR_P2</CODE> to the location pointed to by <CODE>CAESAR_P1</CODE>. <P>
Note: This function
is implemented as a simple wrapper for the POSIX function <CODE>memcpy(3)</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect20" HREF="#sect20"><CODE>CAESAR_COMPARE_EMPTY_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_COMPARE_EMPTY_AREA_1 (CAESAR_P1, CAESAR_P2)
   CAESAR_TYPE_POINTER CAESAR_P1;
   CAESAR_TYPE_POINTER CAESAR_P2;
   { ... }

</PRE>This function is intended to compare two empty areas and, thus, always
returns a value different from 0 (since there is only one empty area). <P>
Note:
this function is used by the <CODE>CAESAR_USE_COMPARE_FUNCTION_AREA_1()</CODE> function
described below. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect21" HREF="#sect21"><CODE>CAESAR_COMPARE_STRING_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_COMPARE_STRING_AREA_1 (CAESAR_S1, CAESAR_S2)
   CAESAR_TYPE_STRING *CAESAR_S1;
   CAESAR_TYPE_STRING *CAESAR_S2;
   { ... }

</PRE>This function returns a value different from 0 if both character strings
pointed to by <CODE>*CAESAR_S1</CODE> and <CODE>*CAESAR_S2</CODE> are identical, or 0 if they are
not. <P>
Note: This function uses the POSIX function <CODE>strcmp(3)</CODE>. <P>
Note: this function
is used by the <CODE>CAESAR_USE_COMPARE_FUNCTION_AREA_1()</CODE> function described
below. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect22" HREF="#sect22"><CODE>CAESAR_USE_COMPARE_FUNCTION_AREA_1</CODE></A></H3>
<PRE>void CAESAR_USE_COMPARE_FUNCTION_AREA_1 (CAESAR_AREA, CAESAR_COMPARE_FUNCTION)
   CAESAR_TYPE_AREA_1 CAESAR_AREA;
   CAESAR_TYPE_COMPARE_FUNCTION *CAESAR_COMPARE_FUNCTION;
   { ... }

</PRE>This procedure modifies the (function pointer) value pointed to by <CODE>*CAESAR_COMPARE_FUNCTION</CODE>
(possibly to assign this function pointer a default value if it is equal
to <CODE>NULL</CODE> before the procedure is invoked) in the following cases: <P>

<UL>
<LI type=disc>if <CODE>CAESAR_AREA</CODE>
is an empty area and if <CODE>*CAESAR_COMPARE_FUNCTION</CODE> is equal to <CODE>NULL</CODE>, then
the <CODE>CAESAR_COMPARE_EMPTY_AREA_1()</CODE> function defined above will be assigned
to <CODE>*CAESAR_COMPARE_FUNCTION</CODE>; <P>
Note: it is not allowed to call this procedure
if <CODE>CAESAR_AREA</CODE> is an empty area, and if <CODE>*CAESAR_COMPARE_FUNCTION</CODE> is different
from both <CODE>NULL</CODE> and <CODE>CAESAR_COMPARE_EMPTY_AREA_1()</CODE>, since in this case <CODE>CAESAR_COMPARE_EMPTY_AREA_1()</CODE>
is the only sensible comparison function; </LI><P><LI type=disc>if <CODE>CAESAR_AREA</CODE> is a state area
and if <CODE>*CAESAR_COMPARE_FUNCTION</CODE> is equal to <CODE>NULL</CODE>, then the <CODE>CAESAR_COMPARE_STATE()</CODE>
function of the graph module will be assigned to <CODE>*CAESAR_COMPARE_FUNCTION</CODE>;
<P>
Note: it is not allowed to call this procedure if <CODE>CAESAR_AREA</CODE> is a state
area, and if <CODE>*CAESAR_COMPARE_FUNCTION</CODE> is different from both <CODE>NULL</CODE> and <CODE>CAESAR_COMPARE_STATE()</CODE>,
and if the result of <CODE>CAESAR_HASH_SIZE_STATE()</CODE> is strictly less than the
result of <CODE>CAESAR_SIZE_STATE()</CODE>, since in this case <CODE>CAESAR_COMPARE_STATE()</CODE>
is the only sensible comparison function; </LI><P><LI type=disc>if <CODE>CAESAR_AREA</CODE> is a label area
and if <CODE>*CAESAR_COMPARE_FUNCTION</CODE> is equal to <CODE>NULL</CODE>, then the <CODE>CAESAR_COMPARE_LABEL()</CODE>
function of the graph module will be assigned to <CODE>*CAESAR_COMPARE_FUNCTION</CODE>;
<P>
Note: it is not allowed to call this procedure if <CODE>CAESAR_AREA</CODE> is a label
area, and if <CODE>*CAESAR_COMPARE_FUNCTION</CODE> is different from both <CODE>NULL</CODE> and <CODE>CAESAR_COMPARE_LABEL()</CODE>,
and if the result of <CODE>CAESAR_HASH_SIZE_LABEL()</CODE> is strictly less than the
result of <CODE>CAESAR_SIZE_LABEL()</CODE>, since in this case <CODE>CAESAR_COMPARE_LABEL()</CODE>
is the only sensible comparison function; </LI><P><LI type=disc>if <CODE>CAESAR_AREA</CODE> is a string area
and if <CODE>*CAESAR_COMPARE_FUNCTION</CODE> is equal to <CODE>NULL</CODE>, then the <CODE>CAESAR_COMPARE_STRING_AREA_1()</CODE>
function defined above will be assigned to <CODE>*CAESAR_COMPARE_FUNCTION</CODE>. </LI><P>
</UL>
<P>
In
any other case, <CODE>*CAESAR_COMPARE_FUNCTION</CODE> is kept unchanged. <P>
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect23" HREF="#sect23"><CODE>CAESAR_COMPARE_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_COMPARE_AREA_1 (CAESAR_COMPARE_FUNCTION,
                                           CAESAR_P1, CAESAR_P2, CAESAR_SIZE)
   CAESAR_TYPE_COMPARE_FUNCTION CAESAR_COMPARE_FUNCTION;
   CAESAR_TYPE_POINTER CAESAR_P1;
   CAESAR_TYPE_POINTER CAESAR_P2;
   CAESAR_TYPE_NATURAL CAESAR_SIZE;
   { ... }

</PRE>This function compares the two memory areas (of <CODE>CAESAR_SIZE</CODE> bytes) pointed
to by <CODE>CAESAR_P1</CODE> and <CODE>CAESAR_P2</CODE> using either <CODE>CAESAR_COMPARE_FUNCTION</CODE> if this
function pointer is not <CODE>NULL</CODE>, or the POSIX function <CODE>memcmp(3)</CODE> otherwise.
The result is <CODE>CAESAR_TRUE</CODE> if and only if both memory areas are found to
be equal. Note: Before calling <CODE>CAESAR_COMPARE_AREA_1()</CODE>, the actual value
of <CODE>CAESAR_COMPARE_FUNCTION</CODE> should have been set by calling the <CODE>CAESAR_USE_COMPARE_FUNCTION_AREA_1()</CODE>
function. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect24" HREF="#sect24"><CODE>CAESAR_HASH_EMPTY_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_HASH_EMPTY_AREA_1 (CAESAR_P, CAESAR_MODULUS)
   CAESAR_TYPE_POINTER CAESAR_P;
   CAESAR_TYPE_NATURAL CAESAR_MODULUS;
   { ... }

</PRE>This function is intended to compute an hash-value on empty areas and, thus,
always returns 0 (since there is only one empty area). If <CODE>CAESAR_MODULUS</CODE>
is equal to 0, the result is undefined. <P>
Note: this function is used by the
<CODE>CAESAR_USE_HASH_FUNCTION_AREA_1()</CODE> function described below. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect25" HREF="#sect25"><CODE>CAESAR_HASH_STRING_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_HASH_STRING_AREA_1 (CAESAR_P, CAESAR_MODULUS)
   CAESAR_TYPE_POINTER CAESAR_P;
   CAESAR_TYPE_NATURAL CAESAR_MODULUS;
   { ... }

</PRE>This function is intended to compute an hash-value on string areas. It returns
a value in the range 0..(<CODE>CAESAR_MODULUS</CODE>-1), computed from the character string
pointed to by <CODE>*CAESAR_P</CODE> (and not by <CODE>CAESAR_P</CODE>, as <CODE>CAESAR_P</CODE> is expected to
be of type <CODE>(CAESAR_TYPE_STRING *)</CODE>, not <CODE>CAESAR_TYPE_STRING</CODE>). <P>
Note: to compute
the hash-value, this function invokes the <CODE>CAESAR_STRING_0_HASH()</CODE> function
of the ``hash'' library. <P>
Note: this function is used by the <CODE>CAESAR_USE_HASH_FUNCTION_AREA_1()</CODE>
function described below. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect26" HREF="#sect26"><CODE>CAESAR_USE_HASH_FUNCTION_AREA_1</CODE></A></H3>
<PRE>void CAESAR_USE_HASH_FUNCTION_AREA_1 (CAESAR_AREA, CAESAR_HASH_FUNCTION)
   CAESAR_TYPE_AREA_1 CAESAR_AREA;
   CAESAR_TYPE_HASH_FUNCTION *CAESAR_HASH_FUNCTION;
   { ... }

</PRE>This procedure modifies the (function pointer) value pointed to by <CODE>*CAESAR_HASH_FUNCTION</CODE>
(possibly to assign this function pointer a default value if it is equal
to <CODE>NULL</CODE> before the procedure is invoked) in the following cases: <P>

<UL>
<LI type=disc>if <CODE>CAESAR_AREA</CODE>
is an empty area and if <CODE>*CAESAR_HASH_FUNCTION</CODE> is equal to <CODE>NULL</CODE>, then the
<CODE>CAESAR_HASH_EMPTY_AREA_1()</CODE> function defined above will be assigned to <CODE>*CAESAR_HASH_FUNCTION</CODE>;
<P>
Note: it is not allowed to call this procedure if <CODE>CAESAR_AREA</CODE> is an empty
area, and if <CODE>*CAESAR_HASH_FUNCTION</CODE> is different from both <CODE>NULL</CODE> and <CODE>CAESAR_HASH_EMPTY_AREA_1()</CODE>,
since in this case <CODE>CAESAR_HASH_EMPTY_AREA_1()</CODE> is the only sensible hashing
function; </LI><P><LI type=disc>if <CODE>CAESAR_AREA</CODE> is a state area and if <CODE>*CAESAR_HASH_FUNCTION</CODE> is
equal to <CODE>NULL</CODE>, then the <CODE>CAESAR_HASH_STATE()</CODE> function of the graph module
will be assigned to <CODE>*CAESAR_HASH_FUNCTION</CODE>; <P>
Note: it is not allowed to call
this procedure if <CODE>CAESAR_AREA</CODE> is a state area, and if <CODE>*CAESAR_HASH_FUNCTION</CODE>
is different from both <CODE>NULL</CODE> and <CODE>CAESAR_HASH_STATE()</CODE>, and if the result
of <CODE>CAESAR_HASH_SIZE_STATE()</CODE> is equal to zero, since in this case <CODE>CAESAR_HASH_STATE()</CODE>
is the only sensible hashing function; </LI><P><LI type=disc>if <CODE>CAESAR_AREA</CODE> is a label area and
if <CODE>*CAESAR_HASH_FUNCTION</CODE> is equal to <CODE>NULL</CODE>, then the <CODE>CAESAR_HASH_LABEL()</CODE>
function of the graph module will be assigned to <CODE>*CAESAR_HASH_FUNCTION</CODE>;
<P>
Note: it is not allowed to call this procedure if <CODE>CAESAR_AREA</CODE> is a label
area, and if <CODE>*CAESAR_HASH_FUNCTION</CODE> is different from both <CODE>NULL</CODE> and <CODE>CAESAR_HASH_LABEL()</CODE>,
and if the result of <CODE>CAESAR_HASH_SIZE_LABEL()</CODE> is equal to zero, since in
this case <CODE>CAESAR_HASH_LABEL()</CODE> is the only sensible hashing function; </LI><P><LI type=disc>if
<CODE>CAESAR_AREA</CODE> is a string area and if <CODE>*CAESAR_HASH_FUNCTION</CODE> is equal to <CODE>NULL</CODE>,
then the <CODE>CAESAR_HASH_STRING_AREA_1()</CODE> function of the ``hash'' library will
be assigned to <CODE>*CAESAR_HASH_FUNCTION</CODE>. </LI><P>
</UL>
<P>
In any other case, <CODE>*CAESAR_HASH_FUNCTION</CODE>
is kept unchanged. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect27" HREF="#sect27"><CODE>CAESAR_HASH_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_HASH_AREA_1 (CAESAR_HASH_FUNCTION, CAESAR_P,
                                        CAESAR_HASH_SIZE, CAESAR_MODULUS)
   CAESAR_TYPE_HASH_FUNCTION CAESAR_HASH_FUNCTION;
   CAESAR_TYPE_POINTER CAESAR_P;
   CAESAR_TYPE_NATURAL CAESAR_HASH_SIZE;
   CAESAR_TYPE_NATURAL CAESAR_MODULUS;
   { ... }

</PRE>This function computes a hash value for the memory area pointed to by <CODE>CAESAR_P</CODE>
using either <CODE>CAESAR_HASH_FUNCTION</CODE> if this function pointer is not <CODE>NULL</CODE>,
or function <CODE>CAESAR_0_HASH()</CODE> of the ``hash'' library otherwise. Hashing is performed
on the <CODE>CAESAR_HASH_SIZE</CODE> first bytes and the hash value returned is in the
range 0..(<CODE>CAESAR_MODULUS</CODE>-1). <P>
Note: Before calling <CODE>CAESAR_HASH_AREA_1()</CODE>, the
actual value of <CODE>CAESAR_HASH_FUNCTION</CODE> should have been set by calling the
<CODE>CAESAR_USE_HASH_FUNCTION_AREA_1()</CODE> function. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect28" HREF="#sect28"><CODE>CAESAR_CONVERT_EMPTY_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_STRING CAESAR_CONVERT_EMPTY_AREA_1 (CAESAR_P)
   CAESAR_TYPE_POINTER CAESAR_P;
   { ... }

</PRE>This function returns a constant, user-readable character string representing
the empty area. <P>
Note: It is not allowed to modify the character string returned
by <CODE>CAESAR_CONVERT_EMPTY_AREA_1()</CODE> nor to free it, for instance using <CODE>free(3)</CODE>.
<P>
Note: this function is used by the <CODE>CAESAR_USE_CONVERT_FUNCTION_AREA_1()</CODE>
function described below. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect29" HREF="#sect29"><CODE>CAESAR_CONVERT_STRING_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_STRING CAESAR_CONVERT_STRING_AREA_1 (CAESAR_S)
   CAESAR_TYPE_STRING *CAESAR_S;
   { ... }

</PRE>This function returns the character string pointed to by <CODE>*CAESAR_S</CODE>. <P>
Note:
this function is used by the <CODE>CAESAR_USE_CONVERT_FUNCTION_AREA_1()</CODE> function
described below. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect30" HREF="#sect30"><CODE>CAESAR_CONVERT_BINARY_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_STRING CAESAR_CONVERT_BINARY_AREA_1 (CAESAR_P, CAESAR_SIZE)
   CAESAR_TYPE_POINTER CAESAR_P;
   CAESAR_TYPE_NATURAL CAESAR_SIZE;
   { ... }

</PRE>This function returns a pointer to a character string corresponding to
the hexadecimal representation for the <CODE>CAESAR_SIZE</CODE> bytes-long memory chunk
pointed to by <CODE>CAESAR_P</CODE>. <P>
Note: It is not allowed to modify the character
string returned by <CODE>CAESAR_CONVERT_BINARY_AREA_1()</CODE> nor to free it, for instance
using <CODE>free(3)</CODE>. <P>
Note: this function is used by the <CODE>CAESAR_CONVERT_AREA_1()</CODE>
function described below. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect31" HREF="#sect31"><CODE>CAESAR_USE_CONVERT_FUNCTION_AREA_1</CODE></A></H3>
<PRE>void CAESAR_USE_CONVERT_FUNCTION_AREA_1 (CAESAR_AREA, CAESAR_CONVERT_FUNCTION)
   CAESAR_TYPE_AREA_1 CAESAR_AREA;
   CAESAR_TYPE_CONVERT_FUNCTION *CAESAR_CONVERT_FUNCTION;
   { ... }

</PRE>This procedure modifies the (function pointer) value pointed to by <CODE>*CAESAR_CONVERT_FUNCTION</CODE>
(possibly to assign this function pointer a default value if it is equal
to <CODE>NULL</CODE> before the procedure is invoked) in the following cases: <P>

<UL>
<LI type=disc>if <CODE>CAESAR_AREA</CODE>
is an empty area and if <CODE>*CAESAR_CONVERT_FUNCTION</CODE> is equal to <CODE>NULL</CODE>, then
the <CODE>CAESAR_CONVERT_EMPTY_AREA_1()</CODE> function defined above will be assigned
to <CODE>*CAESAR_CONVERT_FUNCTION</CODE>; </LI><P><LI type=disc>if <CODE>CAESAR_AREA</CODE> is a state area and if <CODE>*CAESAR_CONVERT_FUNCTION</CODE>
is equal to <CODE>NULL</CODE>, then the effect of this procedure is undefined; </LI><P><LI type=disc>if <CODE>CAESAR_AREA</CODE>
is a label area and if <CODE>*CAESAR_CONVERT_FUNCTION</CODE> is equal to <CODE>NULL</CODE>, then
the <CODE>CAESAR_STRING_LABEL()</CODE> function of the graph module will be assigned
to <CODE>*CAESAR_CONVERT_FUNCTION</CODE>; </LI><P><LI type=disc>if <CODE>CAESAR_AREA</CODE> is a string area and if <CODE>*CAESAR_CONVERT_FUNCTION</CODE>
is equal to <CODE>NULL</CODE>, then the <CODE>CAESAR_CONVERT_STRING_AREA_1()</CODE> function defined
above will be assigned to <CODE>*CAESAR_CONVERT_FUNCTION</CODE>. </LI><P>
</UL>
<P>
In any other case, <CODE>*CAESAR_CONVERT_FUNCTION</CODE>
is kept unchanged. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect32" HREF="#sect32"><CODE>CAESAR_CONVERT_AREA_1</CODE></A></H3>
<PRE>CAESAR_TYPE_STRING CAESAR_CONVERT_AREA_1 (CAESAR_CONVERT_FUNCTION, CAESAR_P,
                                          CAESAR_SIZE)
   CAESAR_TYPE_CONVERT_FUNCTION CAESAR_CONVERT_FUNCTION;
   CAESAR_TYPE_POINTER CAESAR_P;
   CAESAR_TYPE_NATURAL CAESAR_SIZE;
   { ... }

</PRE>This function converts the memory area (of <CODE>CAESAR_SIZE</CODE> bytes) pointed to
by <CODE>CAESAR_P</CODE> into a character string using either <CODE>CAESAR_CONVERT_FUNCTION</CODE>
if this function pointer is not <CODE>NULL</CODE>, or function <CODE>CAESAR_CONVERT_BINARY_AREA_1()</CODE>
otherwise. <P>
Note: Before calling <CODE>CAESAR_CONVERT_AREA_1()</CODE>, the actual value
of <CODE>CAESAR_CONVERT_FUNCTION</CODE> should have been set by calling the <CODE>CAESAR_USE_CONVERT_FUNCTION_AREA_1()</CODE>
function. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect33" HREF="#sect33"><CODE>CAESAR_PRINT_EMPTY_AREA_1</CODE></A></H3>
<PRE>void CAESAR_PRINT_EMPTY_AREA_1 (CAESAR_FILE, CAESAR_P)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_POINTER CAESAR_P;
   { ... }

</PRE>This procedure prints to file <CODE>CAESAR_FILE</CODE> a constant, user-readable character
string representing the empty area. <P>
Before this procedure is called, <CODE>CAESAR_FILE</CODE>
must have been properly opened, for instance using <CODE>fopen(3)</CODE>. <P>
Note: this
function is used by the <CODE>CAESAR_USE_PRINT_FUNCTION_AREA_1()</CODE> function described
below. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect34" HREF="#sect34"><CODE>CAESAR_PRINT_STRING_AREA_1</CODE></A></H3>
<PRE>void CAESAR_PRINT_STRING_AREA_1 (CAESAR_FILE, CAESAR_S)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_STRING *CAESAR_S;
   { ... }

</PRE>This procedure prints to file <CODE>CAESAR_FILE</CODE> the character string pointed
to by <CODE>*CAESAR_S</CODE>. <P>
Before this procedure is called, <CODE>CAESAR_FILE</CODE> must have
been properly opened, for instance using <CODE>fopen(3)</CODE>. <P>
Note: this function is
used by the <CODE>CAESAR_USE_PRINT_FUNCTION_AREA_1()</CODE> function described below.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect35" HREF="#sect35"><CODE>CAESAR_PRINT_BINARY_AREA_1</CODE></A></H3>
<PRE>void CAESAR_PRINT_BINARY_AREA_1 (CAESAR_FILE, CAESAR_P, CAESAR_SIZE)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_POINTER CAESAR_P;
   CAESAR_TYPE_NATURAL CAESAR_SIZE;
   { ... }

</PRE>This procedure prints to file <CODE>CAESAR_FILE</CODE> the character string corresponding
to the hexadecimal representation for the <CODE>CAESAR_SIZE</CODE> bytes-long memory
chunk pointed to by <CODE>CAESAR_P</CODE>. <P>
Before this procedure is called, <CODE>CAESAR_FILE</CODE>
must have been properly opened, for instance using <CODE>fopen(3)</CODE>. <P>
Note: this
function is used by the <CODE>CAESAR_PRINT_AREA_1()</CODE> function described below.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect36" HREF="#sect36"><CODE>CAESAR_USE_PRINT_FUNCTION_AREA_1</CODE></A></H3>
<PRE>void CAESAR_USE_PRINT_FUNCTION_AREA_1 (CAESAR_AREA, CAESAR_PRINT_FUNCTION)
   CAESAR_TYPE_AREA_1 CAESAR_AREA;
   CAESAR_TYPE_PRINT_FUNCTION *CAESAR_PRINT_FUNCTION;
   { ... }

</PRE>This procedure modifies the (function pointer) value pointed to by <CODE>*CAESAR_PRINT_FUNCTION</CODE>
(possibly to assign this function pointer a default value if it is equal
to <CODE>NULL</CODE> before the procedure is invoked) in the following cases: <P>

<UL>
<LI type=disc>if <CODE>CAESAR_AREA</CODE>
is an empty area and if <CODE>*CAESAR_PRINT_FUNCTION</CODE> is equal to <CODE>NULL</CODE>, then the
<CODE>CAESAR_PRINT_EMPTY_AREA_1()</CODE> function defined above will be assigned to
<CODE>*CAESAR_PRINT_FUNCTION</CODE>; </LI><P><LI type=disc>if <CODE>CAESAR_AREA</CODE> is a state area and if <CODE>*CAESAR_PRINT_FUNCTION</CODE>
is equal to <CODE>NULL</CODE>, then the <CODE>CAESAR_PRINT_STATE()</CODE> function of the graph module
will be assigned to <CODE>*CAESAR_PRINT_FUNCTION</CODE>; </LI><P><LI type=disc>if <CODE>CAESAR_AREA</CODE> is a label area
and if <CODE>*CAESAR_PRINT_FUNCTION</CODE> is equal to <CODE>NULL</CODE>, then the <CODE>CAESAR_PRINT_LABEL()</CODE>
function of the graph module will be assigned to <CODE>*CAESAR_PRINT_FUNCTION</CODE>;
</LI><P><LI type=disc>if <CODE>CAESAR_AREA</CODE> is a string area and if <CODE>*CAESAR_PRINT_FUNCTION</CODE> is equal
to <CODE>NULL</CODE>, then the <CODE>CAESAR_PRINT_STRING_AREA_1()</CODE> function defined above will
be assigned to <CODE>*CAESAR_PRINT_FUNCTION</CODE>. </LI><P>
</UL>
<P>
In any other case, <CODE>*CAESAR_PRINT_FUNCTION</CODE>
is kept unchanged. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect37" HREF="#sect37"><CODE>CAESAR_PRINT_AREA_1</CODE></A></H3>
<PRE>void CAESAR_PRINT_AREA_1 (CAESAR_PRINT_FUNCTION, CAESAR_FILE, CAESAR_P,
                          CAESAR_SIZE)
   CAESAR_TYPE_PRINT_FUNCTION CAESAR_PRINT_FUNCTION;
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_POINTER CAESAR_P;
   CAESAR_TYPE_NATURAL CAESAR_SIZE;
   { ... }

</PRE>This function prints to file <CODE>CAESAR_FILE</CODE> a character string representing
the memory area (of <CODE>CAESAR_SIZE</CODE> bytes) pointed to by <CODE>CAESAR_P</CODE>. Printing
is done using either <CODE>CAESAR_PRINT_FUNCTION</CODE> if this function pointer is
not <CODE>NULL</CODE>, or function <CODE>CAESAR_PRINT_BINARY_AREA_1()</CODE> otherwise. <P>
Before this
procedure is called, <CODE>CAESAR_FILE</CODE> must have been properly opened, for instance
using <CODE>fopen(3)</CODE>. <P>
Note: Before calling <CODE>CAESAR_PRINT_AREA_1()</CODE>, the actual value
of <CODE>CAESAR_PRINT_FUNCTION</CODE> should have been set by calling the <CODE>CAESAR_USE_PRINT_FUNCTION_AREA_1()</CODE>
function. <P>
<P>
 <HR><BR>
 
<H2><A NAME="sect38" HREF="#sect38">Author(s)</A></H2>
Hubert Garavel 
<H2><A NAME="sect39" HREF="#sect39">Files</A></H2>
 
<DL><DD><DL COMPACT>

<DT><B>$CADP/incl/caesar_graph.h</B> </DT>
<DD>interface of the
graph module </DD><P>

<DT><B>$CADP/incl/caesar_*.h</B> </DT>
<DD>interfaces of the storage module </DD><P>

<DT><B>$CADP/bin.`arch`/libcaesar.a</B>
</DT>
<DD>object code of the storage module </DD><P>

<DT><B>$CADP/src/open_caesar/*.c</B> </DT>
<DD>source code
of various exploration modules </DD><P>

<DT><B>$CADP/com/lotos.open</B> </DT>
<DD>shell script to run
OPEN/CAESAR  </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect40" HREF="#sect40">See Also</A></H2>
Reference Manuals of OPEN/CAESAR, CAESAR, and CAESAR.ADT,
<A HREF="lotos.open.html"><B>lotos.open</B></A>
, <A HREF="caesar.html"><B>caesar</B></A>
, <A HREF="caesar.adt.html"><B>caesar.adt</B></A>
 <P>
Additional information
is available from the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives
for installation are given in files <B>$CADP/INSTALLATION_*.</B> <P>
Recent changes
and improvements to this software are reported and commented in file <B>$CADP/HISTORY.</B>

<H2><A NAME="sect41" HREF="#sect41">Bugs</A></H2>
Known bugs are described in the Reference Manual of OPEN/CAESAR. Please
report new bugs to <A HREF="mailto:cadp@inria.fr?Subject=CADP-Bug-Report">cadp@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Purpose</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Usage</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Description</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Features</A></LI>
<UL>
<LI><A NAME="toc5" HREF="#sect5">CAESAR_TYPE_AREA_1</A></LI>
<LI><A NAME="toc6" HREF="#sect6">CAESAR_LENGTH_AREA_1</A></LI>
<LI><A NAME="toc7" HREF="#sect7">CAESAR_EXPONENT_AREA_1</A></LI>
<LI><A NAME="toc8" HREF="#sect8">CAESAR_AREA_1</A></LI>
<LI><A NAME="toc9" HREF="#sect9">CAESAR_EMPTY_AREA_1</A></LI>
<LI><A NAME="toc10" HREF="#sect10">CAESAR_STATE_AREA_1</A></LI>
<LI><A NAME="toc11" HREF="#sect11">CAESAR_LABEL_AREA_1</A></LI>
<LI><A NAME="toc12" HREF="#sect12">CAESAR_STRING_AREA_1</A></LI>
<LI><A NAME="toc13" HREF="#sect13">CAESAR_BYTE_AREA_1</A></LI>
<LI><A NAME="toc14" HREF="#sect14">CAESAR_NATURAL_AREA_1</A></LI>
<LI><A NAME="toc15" HREF="#sect15">CAESAR_POINTER_AREA_1</A></LI>
<LI><A NAME="toc16" HREF="#sect16">CAESAR_SIZE_AREA_1</A></LI>
<LI><A NAME="toc17" HREF="#sect17">CAESAR_HASH_SIZE_AREA_1</A></LI>
<LI><A NAME="toc18" HREF="#sect18">CAESAR_ALIGNMENT_AREA_1</A></LI>
<LI><A NAME="toc19" HREF="#sect19">CAESAR_COPY_AREA_1</A></LI>
<LI><A NAME="toc20" HREF="#sect20">CAESAR_COMPARE_EMPTY_AREA_1</A></LI>
<LI><A NAME="toc21" HREF="#sect21">CAESAR_COMPARE_STRING_AREA_1</A></LI>
<LI><A NAME="toc22" HREF="#sect22">CAESAR_USE_COMPARE_FUNCTION_AREA_1</A></LI>
<LI><A NAME="toc23" HREF="#sect23">CAESAR_COMPARE_AREA_1</A></LI>
<LI><A NAME="toc24" HREF="#sect24">CAESAR_HASH_EMPTY_AREA_1</A></LI>
<LI><A NAME="toc25" HREF="#sect25">CAESAR_HASH_STRING_AREA_1</A></LI>
<LI><A NAME="toc26" HREF="#sect26">CAESAR_USE_HASH_FUNCTION_AREA_1</A></LI>
<LI><A NAME="toc27" HREF="#sect27">CAESAR_HASH_AREA_1</A></LI>
<LI><A NAME="toc28" HREF="#sect28">CAESAR_CONVERT_EMPTY_AREA_1</A></LI>
<LI><A NAME="toc29" HREF="#sect29">CAESAR_CONVERT_STRING_AREA_1</A></LI>
<LI><A NAME="toc30" HREF="#sect30">CAESAR_CONVERT_BINARY_AREA_1</A></LI>
<LI><A NAME="toc31" HREF="#sect31">CAESAR_USE_CONVERT_FUNCTION_AREA_1</A></LI>
<LI><A NAME="toc32" HREF="#sect32">CAESAR_CONVERT_AREA_1</A></LI>
<LI><A NAME="toc33" HREF="#sect33">CAESAR_PRINT_EMPTY_AREA_1</A></LI>
<LI><A NAME="toc34" HREF="#sect34">CAESAR_PRINT_STRING_AREA_1</A></LI>
<LI><A NAME="toc35" HREF="#sect35">CAESAR_PRINT_BINARY_AREA_1</A></LI>
<LI><A NAME="toc36" HREF="#sect36">CAESAR_USE_PRINT_FUNCTION_AREA_1</A></LI>
<LI><A NAME="toc37" HREF="#sect37">CAESAR_PRINT_AREA_1</A></LI>
</UL>
<LI><A NAME="toc38" HREF="#sect38">Author(s)</A></LI>
<LI><A NAME="toc39" HREF="#sect39">Files</A></LI>
<LI><A NAME="toc40" HREF="#sect40">See Also</A></LI>
<LI><A NAME="toc41" HREF="#sect41">Bugs</A></LI>
</UL>
</BODY></HTML>
