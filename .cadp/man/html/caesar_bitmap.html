  <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>caesar_bitmap manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
caesar_bitmap - the ``bitmap'' library of OPEN/CAESAR 
<H2><A NAME="sect1" HREF="#sect1">Purpose</A></H2>
The ``bitmap''
library provides primitives for implementing the ``bit state space'' verification
technique proposed by Gerard Holzmann. <P>

<H2><A NAME="sect2" HREF="#sect2">Usage</A></H2>
The ``bitmap'' library consists
of: 
<UL>
<LI type=disc>a predefined header file <CODE>caesar_bitmap.h</CODE>; </LI><P><LI type=disc>the precompiled library file
<CODE>libcaesar.a</CODE>, which implements the features described in <CODE>caesar_bitmap.h</CODE>. </LI><P>
</UL>
<P>
Note:
The ``bitmap'' library is a software layer built above the primitives offered
by the ``standard'' and ``hash'' libraries. <P>

<H2><A NAME="sect3" HREF="#sect3">Description</A></H2>
A ``bitmap'' of size N is basically
an array of N bits numbered from 0 to N-1. The value of N is usually large
(e.g., some tenth million states). <P>
Additionally, statistics are attached to
each bitmap. These statistics consist of a ``success counter'' (which counts
how many bits equal to 1 have been read) and a ``failure counter'' (which counts
how many bits equal to 0 have been read). <P>

<H2><A NAME="sect4" HREF="#sect4">Features</A></H2>
<P>
 <HR><BR>
 
<H3><A NAME="sect5" HREF="#sect5"><CODE>CAESAR_TYPE_BITMAP</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_ABSTRACT (...) CAESAR_TYPE_BITMAP;

</PRE>This type denotes a pointer to the concrete representation of a bitmap,
which is supposed to be ``opaque''. <P>
 <HR><BR>
 
<H3><A NAME="sect6" HREF="#sect6"><CODE>CAESAR_CREATE_BITMAP</CODE></A></H3>
<PRE>void CAESAR_CREATE_BITMAP (CAESAR_B, CAESAR_SIZE, CAESAR_PRIME)
   CAESAR_TYPE_BITMAP *CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_SIZE;
   CAESAR_TYPE_BOOLEAN CAESAR_PRIME;
   { ... }

</PRE>This procedure allocates a bitmap using <CODE>CAESAR_CREATE()</CODE> and assigns its
address to <CODE>*CAESAR_B</CODE>. The size N of this bitmap is determined by the values
of formal parameters <CODE>CAESAR_SIZE</CODE> and <CODE>CAESAR_PRIME</CODE>, and also by the amount
of memory available. <P>
Note: because <CODE>CAESAR_TYPE_BITMAP</CODE> is a pointer type,
any variable <CODE>CAESAR_B</CODE> of type <CODE>CAESAR_TYPE_BITMAP</CODE> must be allocated before
used, for instance using: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_CREATE_BITMAP (&amp;CAESAR_B, ...)</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
If the value
of <CODE>CAESAR_SIZE</CODE> is different from 0, then the number N of bits in the bitmap
will be <CODE>CAESAR_SIZE</CODE>. <P>
If the value of <CODE>CAESAR_SIZE</CODE> is equal to 0, then N will
be given a default value as large as possible. <P>
Note: in this case, the bitmap
will fill most of the memory space available for the current process. Therefore,
if <CODE>CAESAR_CREATE_BITMAP()</CODE> is to be called with <CODE>CAESAR_SIZE</CODE> = 0, it should
be called only after having allocated all the other data structures (e.g.,
stacks, ...), otherwise there may be not enough memory for these data structures.
<P>
In both cases, the value of N can be reduced to a smaller value as to fit
into the amount of available memory. <P>
If the value of <CODE>CAESAR_PRIME</CODE> is different
from 0, the value of N can also be reduced to the immediately smaller prime
number (since some hash functions require prime modulus). If the value of
<CODE>CAESAR_PRIME</CODE> is equal to 0, the value of N is not changed. <P>
If (in spite
of various attempts) the allocation fails, the <CODE>NULL</CODE> value is assigned to
<CODE>*CAESAR_B</CODE>. <P>
If the allocation succeeds, the final value of N can be known
using the function <CODE>CAESAR_SIZE_BITMAP()</CODE> (see below). <P>
If the allocation succeeds,
the N bits of the bitmap are initialized to 0. The success and failure counters
attached to the bitmap are also initialized to 0. <P>
Note: since variable <CODE>CAESAR_SIZE</CODE>
is a value of type <CODE>CAESAR_TYPE_NATURAL</CODE>, a bitmap can contain at most 2^{8n}-1
bits, where: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> n = <CODE>sizeof (CAESAR_TYPE_NATURAL)</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>It is assumed that n &gt;=
4. For n = 4, this makes 4,294,967,295 bits, that is approximately 537 Megabytes
of memory, which is currently enough. <P>
 <HR><BR>
 
<H3><A NAME="sect7" HREF="#sect7"><CODE>CAESAR_DELETE_BITMAP</CODE></A></H3>
<PRE>void CAESAR_DELETE_BITMAP (CAESAR_B)
   CAESAR_TYPE_BITMAP *CAESAR_B;
   { ... }

</PRE>This procedure frees the memory space corresponding to the bitmap pointed
to by <CODE>*CAESAR_B</CODE> using <CODE>CAESAR_DELETE()</CODE>. Afterwards, the <CODE>NULL</CODE> value is assigned
to <CODE>*CAESAR_B</CODE>. <P>
 <HR><BR>
 
<H3><A NAME="sect8" HREF="#sect8"><CODE>CAESAR_PURGE_BITMAP</CODE></A></H3>
<PRE>void CAESAR_PURGE_BITMAP (CAESAR_B)
   CAESAR_TYPE_BITMAP CAESAR_B;
   { ... }

</PRE>This procedure empties the bitmap pointed to by <CODE>CAESAR_B</CODE> without deleting
it. Afterwards, this bitmap is exactly in the same state as after its creation
using <CODE>CAESAR_CREATE_BITMAP()</CODE>. Its size remains unchanged. <P>
 <HR><BR>
 
<H3><A NAME="sect9" HREF="#sect9"><CODE>CAESAR_SIZE_BITMAP</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_SIZE_BITMAP (CAESAR_B)
   CAESAR_TYPE_BITMAP CAESAR_B;
   { ... }

</PRE>This function returns the size (i.e., number of bits) of the bitmap pointed
to by <CODE>CAESAR_B</CODE>. This size is determined when the bitmap is created using
<CODE>CAESAR_CREATE_BITMAP()</CODE> and remains constant. <P>
 <HR><BR>
 
<H3><A NAME="sect10" HREF="#sect10"><CODE>CAESAR_SET_BITMAP</CODE></A></H3>
<PRE>void CAESAR_SET_BITMAP (CAESAR_B, CAESAR_I)
   CAESAR_TYPE_BITMAP CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_I;
   { ... }

</PRE>This procedure sets to 1 the <CODE>CAESAR_I</CODE>-th bit of the bitmap pointed to by
<CODE>CAESAR_B</CODE>. The value of <CODE>CAESAR_I</CODE> is such that: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> 0 &lt;= <CODE>CAESAR_I</CODE> &lt;= <CODE>CAESAR_SIZE_BITMAP
(CAESAR_B)</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>It is usually the result of some hash-code computation. <P>
 <HR><BR>
 
<H3><A NAME="sect11" HREF="#sect11"><CODE>CAESAR_RESET_BITMAP</CODE></A></H3>
<PRE>void CAESAR_RESET_BITMAP (CAESAR_B, CAESAR_I)
   CAESAR_TYPE_BITMAP CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_I;
   { ... }

</PRE>This procedure sets to 0 the <CODE>CAESAR_I</CODE>-th bit of the bitmap pointed to by
<CODE>CAESAR_B</CODE>. The value of <CODE>CAESAR_I</CODE> is such that: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> 0 &lt;= <CODE>CAESAR_I</CODE> &lt;= <CODE>CAESAR_SIZE_BITMAP
(CAESAR_B)</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>It is usually the result of some hash-code computation. <P>
 <HR><BR>
 
<H3><A NAME="sect12" HREF="#sect12"><CODE>CAESAR_TEST_BITMAP</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_TEST_BITMAP (CAESAR_B, CAESAR_I)
   CAESAR_TYPE_BITMAP CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_I;
   { ... }

</PRE>This function returns 0 if the <CODE>CAESAR_I</CODE>-th bit of the bitmap pointed to
by <CODE>CAESAR_B</CODE> is equal to 0, or a value different from 0 if this bit is equal
to 1. The value of <CODE>CAESAR_I</CODE> is such that: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> 0 &lt;= <CODE>CAESAR_I</CODE> &lt;= <CODE>CAESAR_SIZE_BITMAP
(CAESAR_B)</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>It is usually the result of some hash-code computation. <P>
A return
value of 0 increments the failure counter attached to the bitmap pointed
to by <CODE>CAESAR_B</CODE>, whereas a return value of 1 increments the success counter.
<P>
 <HR><BR>
 
<H3><A NAME="sect13" HREF="#sect13"><CODE>CAESAR_TEST_AND_SET_BITMAP</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_TEST_AND_SET_BITMAP (CAESAR_B, CAESAR_I)
   CAESAR_TYPE_BITMAP CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_I;
   { ... }

</PRE>This function returns 0 if the <CODE>CAESAR_I</CODE>-th bit of the bitmap pointed to
by <CODE>CAESAR_B</CODE> is equal to 0, or a value different from 0 if this bit is equal
to 1. The value of <CODE>CAESAR_I</CODE> is such that: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> 0 &lt;= <CODE>CAESAR_I</CODE> &lt;= <CODE>CAESAR_SIZE_BITMAP
(CAESAR_B)</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>It is usually the result of some hash-code computation. <P>
The <CODE>CAESAR_I</CODE>-th
bit of the bitmap pointed to by <CODE>CAESAR_B</CODE> is set to 1 if it was equal to
0. <P>
A return value of 0 increments the failure counter attached to the bitmap
pointed to by <CODE>CAESAR_B</CODE>, whereas a return value of 1 increments the success
counter. <P>
 <HR><BR>
 
<H3><A NAME="sect14" HREF="#sect14"><CODE>CAESAR_TEST_AND_RESET_BITMAP</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_TEST_AND_RESET_BITMAP (CAESAR_B, CAESAR_I)
   CAESAR_TYPE_BITMAP CAESAR_B;
   CAESAR_TYPE_NATURAL CAESAR_I;
   { ... }

</PRE>This function returns 0 if the <CODE>CAESAR_I</CODE>-th bit of the bitmap pointed to
by <CODE>CAESAR_B</CODE> is equal to 0, or a value different from 0 if this bit is equal
to 1. The value of <CODE>CAESAR_I</CODE> is such that: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> 0 &lt;= <CODE>CAESAR_I</CODE> &lt;= <CODE>CAESAR_SIZE_BITMAP
(CAESAR_B)</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>It is usually the result of some hash-code computation. <P>
The <CODE>CAESAR_I</CODE>-th
bit of the bitmap pointed to by <CODE>CAESAR_B</CODE> is set to 0 if it was equal to
1. <P>
A return value of 0 increments the failure counter attached to the bitmap
pointed to by <CODE>CAESAR_B</CODE>, whereas a return value of 1 increments the success
counter. <P>
 <HR><BR>
 
<H3><A NAME="sect15" HREF="#sect15"><CODE>CAESAR_ZERO_BITMAP</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_ZERO_BITMAP (CAESAR_B)
   CAESAR_TYPE_BITMAP CAESAR_B;
   { ... }

</PRE>This function returns the number of bits which are equal to 0 in the bitmap
pointed to by <CODE>CAESAR_B</CODE>. <P>
 <HR><BR>
 
<H3><A NAME="sect16" HREF="#sect16"><CODE>CAESAR_ONE_BITMAP</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_ONE_BITMAP (CAESAR_B)
   CAESAR_TYPE_BITMAP CAESAR_B;
   { ... }

</PRE>This function returns the number of bits which are equal to 1 in the bitmap
pointed to by <CODE>CAESAR_B</CODE>. <P>
Note: for any bitmap <CODE>CAESAR_B</CODE>: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_ZERO_BITMAP
(CAESAR_B)</CODE> + <CODE>CAESAR_ONE_BITMAP (CAESAR_B)</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>is equal to: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_SIZE_BITMAP
(CAESAR_B)</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
 <HR><BR>
 
<H3><A NAME="sect17" HREF="#sect17"><CODE>CAESAR_FAILURE_BITMAP</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_FAILURE_BITMAP (CAESAR_B)
   CAESAR_TYPE_BITMAP CAESAR_B;
   { ... }

</PRE>This function returns the value of the failure counter of the bitmap pointed
to by <CODE>CAESAR_B</CODE>, i.e., the number of searches that failed (see functions <CODE>CAESAR_TEST_BITMAP()</CODE>,
<CODE>CAESAR_TEST_AND_SET_BITMAP()</CODE>, and <CODE>CAESAR_TEST_AND_RESET()</CODE> above). <P>
 <HR><BR>
 
<H3><A NAME="sect18" HREF="#sect18"><CODE>CAESAR_SUCCESS_BITMAP</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_SUCCESS_BITMAP (CAESAR_B)
   CAESAR_TYPE_BITMAP CAESAR_B;
   { ... }

</PRE>This function returns the value of the success counter of the bitmap pointed
to by <CODE>CAESAR_B</CODE>, i.e., the number of searches that succeeded (see functions
<CODE>CAESAR_TEST_BITMAP()</CODE>, <CODE>CAESAR_TEST_AND_SET_BITMAP()</CODE>, and <CODE>CAESAR_TEST_AND_RESET()</CODE>
above). <P>
 <HR><BR>
 
<H3><A NAME="sect19" HREF="#sect19"><CODE>CAESAR_FORMAT_BITMAP</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_FORMAT_BITMAP (CAESAR_B, CAESAR_FORMAT)
   CAESAR_TYPE_BITMAP CAESAR_B;
   CAESAR_TYPE_FORMAT CAESAR_FORMAT;
   { ... }

</PRE>This function allows to control the format under which the bitmap pointed
to by <CODE>CAESAR_B</CODE> will be printed by the procedure <CODE>CAESAR_PRINT_BITMAP()</CODE> (see
below). Currently, the following formats are available: <P>

<UL>
<LI type=disc>With format 0, statistical
information about the bitmap is displayed such as: the size in bytes, the
number of bits, the number of bits equal to 0, the number of bits equal
to 1, the success counter, the failure counter, etc. </LI><P><LI type=disc>With format 1, the
contents of the bitmap are printed in hexadecimal. This can be useful for
debugging bitmaps of small size. </LI><P><LI type=disc>With format 2, the list of bits which are
equal to 0 is printed. This can be useful for debugging bitmaps with almost
all bits equal to 1. </LI><P><LI type=disc>With format 3, the list of bits which are equal to
1 is printed. This can be useful for debugging bitmaps with almost all bits
equal to 0. </LI><P><LI type=disc>(no other format available yet). </LI><P>
</UL>
<P>
By default, the current format
of each bitmap is initialized to 0. <P>
When called with <CODE>CAESAR_FORMAT</CODE> between
0 and 3, this fonction sets the current format of <CODE>CAESAR_B</CODE> to <CODE>CAESAR_FORMAT</CODE>
and returns an undefined result. <P>
When called with another value of <CODE>CAESAR_FORMAT</CODE>,
this function does not modify the current format of <CODE>CAESAR_B</CODE> but returns
a result defined as follows. If <CODE>CAESAR_FORMAT</CODE> is equal to the constant <CODE>CAESAR_CURRENT_FORMAT</CODE>,
the result is the value of the current format of <CODE>CAESAR_B</CODE>. If <CODE>CAESAR_FORMAT</CODE>
is equal to the constant <CODE>CAESAR_MAXIMAL_FORMAT</CODE>, the result is the maximal
format value (i.e., 3). In all other cases, the effect of this function is
undefined. <P>
 <HR><BR>
 
<H3><A NAME="sect20" HREF="#sect20"><CODE>CAESAR_MAX_FORMAT_BITMAP</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_MAX_FORMAT_BITMAP ()
   { ... }

</PRE>Caution! This function is deprecated. It should no longer be used, as it
might be removed from future versions of the <I>OPEN/CAESAR</I>. Use function <CODE>CAESAR_FORMAT_BITMAP()</CODE>
instead, called with argument <CODE>CAESAR_MAXIMAL_FORMAT</CODE>. <P>
This function returns
the maximal format value available for printing bitmaps. <P>
 <HR><BR>
 
<H3><A NAME="sect21" HREF="#sect21"><CODE>CAESAR_PRINT_BITMAP</CODE></A></H3>
<PRE>void CAESAR_PRINT_BITMAP (CAESAR_FILE, CAESAR_B)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_BITMAP CAESAR_B;
   { ... }

</PRE>This procedure prints to file <CODE>CAESAR_FILE</CODE> a character string containing
information about the bitmap pointed to by <CODE>CAESAR_B</CODE>. The nature of the information
is determined by the current format of the bitmap pointed to by <CODE>CAESAR_B</CODE>.
<P>
Before this procedure is called, <CODE>CAESAR_FILE</CODE> must have been properly opened,
for instance using <CODE>fopen(3)</CODE>. <P>
 <HR><BR>
 
<H2><A NAME="sect22" HREF="#sect22">Author(s)</A></H2>
Hubert Garavel 
<H2><A NAME="sect23" HREF="#sect23">Files</A></H2>
 
<DL><DD><DL COMPACT>

<DT><B>$CADP/incl/caesar_graph.h</B> </DT>
<DD>interface of the
graph module </DD><P>

<DT><B>$CADP/incl/caesar_*.h</B> </DT>
<DD>interfaces of the storage module </DD><P>

<DT><B>$CADP/bin.`arch`/libcaesar.a</B>
</DT>
<DD>object code of the storage module </DD><P>

<DT><B>$CADP/src/open_caesar/*.c</B> </DT>
<DD>source code
of various exploration modules </DD><P>

<DT><B>$CADP/com/lotos.open</B> </DT>
<DD>shell script to run
OPEN/CAESAR  </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect24" HREF="#sect24">See Also</A></H2>
Reference Manuals of OPEN/CAESAR, CAESAR, and CAESAR.ADT,
<A HREF="lotos.open.html"><B>lotos.open</B></A>
, <A HREF="caesar.html"><B>caesar</B></A>
, <A HREF="caesar.adt.html"><B>caesar.adt</B></A>
 <P>
Additional information
is available from the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives
for installation are given in files <B>$CADP/INSTALLATION_*.</B> <P>
Recent changes
and improvements to this software are reported and commented in file <B>$CADP/HISTORY.</B>

<H2><A NAME="sect25" HREF="#sect25">Bugs</A></H2>
Known bugs are described in the Reference Manual of OPEN/CAESAR. Please
report new bugs to <A HREF="mailto:cadp@inria.fr?Subject=CADP-Bug-Report">cadp@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Purpose</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Usage</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Description</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Features</A></LI>
<UL>
<LI><A NAME="toc5" HREF="#sect5">CAESAR_TYPE_BITMAP</A></LI>
<LI><A NAME="toc6" HREF="#sect6">CAESAR_CREATE_BITMAP</A></LI>
<LI><A NAME="toc7" HREF="#sect7">CAESAR_DELETE_BITMAP</A></LI>
<LI><A NAME="toc8" HREF="#sect8">CAESAR_PURGE_BITMAP</A></LI>
<LI><A NAME="toc9" HREF="#sect9">CAESAR_SIZE_BITMAP</A></LI>
<LI><A NAME="toc10" HREF="#sect10">CAESAR_SET_BITMAP</A></LI>
<LI><A NAME="toc11" HREF="#sect11">CAESAR_RESET_BITMAP</A></LI>
<LI><A NAME="toc12" HREF="#sect12">CAESAR_TEST_BITMAP</A></LI>
<LI><A NAME="toc13" HREF="#sect13">CAESAR_TEST_AND_SET_BITMAP</A></LI>
<LI><A NAME="toc14" HREF="#sect14">CAESAR_TEST_AND_RESET_BITMAP</A></LI>
<LI><A NAME="toc15" HREF="#sect15">CAESAR_ZERO_BITMAP</A></LI>
<LI><A NAME="toc16" HREF="#sect16">CAESAR_ONE_BITMAP</A></LI>
<LI><A NAME="toc17" HREF="#sect17">CAESAR_FAILURE_BITMAP</A></LI>
<LI><A NAME="toc18" HREF="#sect18">CAESAR_SUCCESS_BITMAP</A></LI>
<LI><A NAME="toc19" HREF="#sect19">CAESAR_FORMAT_BITMAP</A></LI>
<LI><A NAME="toc20" HREF="#sect20">CAESAR_MAX_FORMAT_BITMAP</A></LI>
<LI><A NAME="toc21" HREF="#sect21">CAESAR_PRINT_BITMAP</A></LI>
</UL>
<LI><A NAME="toc22" HREF="#sect22">Author(s)</A></LI>
<LI><A NAME="toc23" HREF="#sect23">Files</A></LI>
<LI><A NAME="toc24" HREF="#sect24">See Also</A></LI>
<LI><A NAME="toc25" HREF="#sect25">Bugs</A></LI>
</UL>
</BODY></HTML>
