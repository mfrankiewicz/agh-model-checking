 <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>BCG_WRITE manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
bcg_write - a simple interface to produce a BCG graph 
<H2><A NAME="sect1" HREF="#sect1">Description</A></H2>
This
interface generates a BCG graph from an  application program written in
C or C++. To keep things simple, this interface does not give access to
the whole BCG format, but only to a subset, in which states are assumed
to be unsigned integer numbers and labels of the edges are assumed to be
character strings. Note: this subset of BCG is equivalent to the <B>.aut</B> format
described in the <A HREF="aldebaran.html"><B>aldebaran</B></A>
 manual page, although it is much more
compact. <P>

<H2><A NAME="sect2" HREF="#sect2">Usage</A></H2>
The application program should start with the following directive:
<P>
<CODE>   #include "bcg_user.h"</CODE> <P>
Then the BCG library should be initialized by invoking
the  following function: <P>
<CODE>   BCG_INIT ();</CODE> <P>
Not invoking this function might
cause a run-time error, e.g., a segmentation fault. Invoking <CODE>BCG_INIT()</CODE> more
than once is harmless, although not recommended. 
<H2><A NAME="sect3" HREF="#sect3">Data Types</A></H2>
The functions
of this interface use the followings types, whose definitions are provided
by the "bcg_user.h" file: 
<UL>
<LI type=disc><CODE>BCG_TYPE_BOOLEAN</CODE> </LI><P><LI type=disc><CODE>BCG_TYPE_NATURAL</CODE> </LI><P><LI type=disc><CODE>BCG_TYPE_C_STRING</CODE>
</LI><P><LI type=disc><CODE>BCG_TYPE_FILE_NAME</CODE> </LI><P><LI type=disc><CODE>BCG_TYPE_LABEL_STRING</CODE> </LI><P><LI type=disc><CODE>BCG_TYPE_STATE_NUMBER</CODE> </LI><P><LI type=disc><CODE>BCG_TYPE_DATA_FORMAT</CODE>
</LI><P>
</UL>

<H2><A NAME="sect4" HREF="#sect4">Features</A></H2>
<P>
 <HR><BR>
 <P>

<H3><A NAME="sect5" HREF="#sect5"><CODE>BCG_IO_WRITE_BCG_BEGIN</CODE></A></H3>
<PRE> BCG_TYPE_BOOLEAN BCG_IO_WRITE_BCG_BEGIN (filename, 
              initial_state, format, comment, monitor)

  BCG_TYPE_FILE_NAME                    filename;
  BCG_TYPE_STATE_NUMBER                 initial_state;
  BCG_TYPE_NATURAL                      format;
  BCG_TYPE_C_STRING                     comment;
  BCG_TYPE_BOOLEAN                      monitor;
  { ... }

</PRE>This function opens a BCG file. Its arguments have the following meaning:

<DL><DD><DL COMPACT>

<DT><I>filename</I> </DT>
<DD>is a character string containing the path name of the BCG file
to be written. It should contain the  "<CODE>.bcg</CODE>" suffix (if the "<CODE>.bcg</CODE>" suffix
is missing, it will be added automatically). </DD><P>

<DT><I>initial_state</I> </DT>
<DD>is the number
of the initial state (usually 0). </DD><P>

<DT><I>format</I> </DT>
<DD>is equal to 2 if, in the forthcoming
successive invocations of function <CODE>BCG_IO_WRITE_BCG_EDGE()</CODE>, the sequence
of actual values given to the <I>state1</I> argument of <CODE>BCG_IO_WRITE_BCG_EDGE()</CODE>
will increase monotonically or equal to 1 otherwise. The format 1 applies
in general but is less efficient in terms of time or BCG file compression.
The format 2 is more efficient but only applies to specific situations
(in particular, when the BCG graph is generated in a breadth-first search).
</DD><P>

<DT><I>comment</I> </DT>
<DD>is a character string containing information about the application
tool which is creating the BCG graph. If <I>comment</I> is equal to NULL, then
it will be replaced with a default string. </DD><P>

<DT><I>monitor</I> </DT>
<DD>should be equal to <CODE>BCG_TRUE</CODE>
if a Tcl/Tk window should be opened  for monitoring in real-time the generation
of the BCG graph or equal to <CODE>BCG_FALSE</CODE> otherwise. </DD><P>
</DL></DD><P></DL>
<P>
By default, if <I>filename</I>
cannot be opened for writing, <CODE>BCG_IO_WRITE_BCG_BEGIN()</CODE> will emit an error
message and exit the program. However, if the following function call: <P>
<CODE>
   BCG_IO_WRITE_BCG_SURVIVE (BCG_TRUE);</CODE> <P>
has occured before the call to
<CODE>BCG_IO_WRITE_BCG_BEGIN()</CODE>, then <CODE>BCG_IO_WRITE_BCG_BEGIN()</CODE> will neither emit
an error message nor exit the program, but return normally a boolean result
that is equal to <CODE>BCG_TRUE</CODE> if and only if <I>filename</I> cannot be opened. <P>
Below,
we assume that the <CODE>BCG_IO_WRITE_BCG_BEGIN()</CODE> function has returned successfully.
<P>
 <HR><BR>
 <P>

<H3><A NAME="sect6" HREF="#sect6"><CODE>BCG_IO_WRITE_BCG_SURVIVE</CODE></A></H3>
<PRE> BCG_IO_WRITE_BCG_SURVIVE (mode)

  BCG_TYPE_BOOLEAN mode;
  { ... }

</PRE>This function controls how the <CODE>BCG_IO_WRITE_BCG_BEGIN()</CODE> function defined
above will behave if the BCG file cannot be opened for writing: 
<UL>
<LI type=disc>If <I>mode</I>
equals <CODE>BCG_FALSE</CODE>, then <CODE>BCG_IO_WRITE_BCG_BEGIN()</CODE> will emit an error message
and exit the program. This is the default  behaviour. </LI><P><LI type=disc>If <I>mode</I> equals <CODE>BCG_TRUE</CODE>,
then <CODE>BCG_IO_WRITE_BCG_BEGIN()</CODE> will neither emit an error message nor exit
the program, but return a  boolean result. The default behaviour can be
restored by calling: </LI><P>
</UL>
<P>
<CODE>    BCG_IO_WRITE_BCG_SURVIVE (BCG_FALSE);</CODE> <P>
 <HR><BR>
 <P>

<H3><A NAME="sect7" HREF="#sect7"><CODE>BCG_IO_WRITE_BCG_EDGE</CODE></A></H3>
<PRE> BCG_IO_WRITE_BCG_EDGE (state1, label, state2)

  BCG_TYPE_STATE_NUMBER state1;
  BCG_TYPE_LABEL_STRING label;
  BCG_TYPE_STATE_NUMBER state2;
  { ... }

</PRE>This function must be invoked once for each edge to be created in the BCG
 graph.  It writes in the previously opened BCG file an edge such that <I>state1</I>
is the number of the origin state, <I>state2</I> is the number of the destination
state, and <I>label</I> is a character string containing the label. <P>
Note: <I>label</I>
should not contain the characters newline (<CODE>'\n'</CODE>) or carriage return (<CODE>'\r'</CODE>). <P>
Note:
the invisible (also known as hidden, or tau) label is represented by  the
character string <CODE>"i"</CODE> (as it is the case in LOTOS). <P>
 <HR><BR>
 <P>

<H3><A NAME="sect8" HREF="#sect8"><CODE>BCG_IO_WRITE_BCG_PARSING</CODE></A></H3>
<PRE> BCG_IO_WRITE_BCG_PARSING (data_format)

  BCG_TYPE_DATA_FORMAT data_format;
  { ... }

</PRE>This function can be (optionally) invoked to modify the way labels are
parsed. For details about label parsing, see the  <B>LABEL PARSING</B> section
below. <P>
Calling <CODE>BCG_IO_WRITE_BCG_PARSING()</CODE> with <I>data_format</I> equal to the
constant value <CODE>BCG_UNPARSED_DATA_FORMAT</CODE> disables the parsing of labels.
<P>
Calling <CODE>BCG_IO_WRITE_BCG_PARSING()</CODE> with <I>data_format</I> equal to the constant
value <CODE>BCG_STANDARD_DATA_FORMAT</CODE> enables the parsing of labels. <P>
By default
(i.e., if <CODE>BCG_IO_WRITE_BCG_PARSING()</CODE> is not invoked), label parsing is enabled.
In order to improve inter-operability between tools, we recommend to leave
label parsing enabled. <P>
The call to <CODE>BCG_IO_WRITE_BCG_PARSING()</CODE> must be done
after invoking <CODE>BCG_INIT()</CODE> and before invoking <CODE>BCG_IO_WRITE_BCG_BEGIN()</CODE>.
 <P>
 <HR><BR>
 <P>

<H3><A NAME="sect9" HREF="#sect9"><CODE>BCG_IO_WRITE_BCG_END</CODE></A></H3>
<PRE> BCG_IO_WRITE_BCG_END ()

  { ... }

</PRE>This function properly closes the BCG file. <P>
 <HR><BR>
 <P>

<H3><A NAME="sect10" HREF="#sect10"><CODE>BCG_IO_WRITE_BCG_ABORT</CODE></A></H3>
<PRE> BCG_IO_WRITE_BCG_ABORT ()

  { ... }

</PRE>This function stops the generation of the BCG file, and removes this file.
This function should be invoked in case of a fatal error, so as not to
 leave an unfinished, invalid BCG file. <P>
 <HR><BR>
  
<H2><A NAME="sect11" HREF="#sect11">Example</A></H2>
The following piece of C code creates a BCG graph with an initial
state numbered 0: <PRE>#include "bcg_user.h"
int main ()
{
   BCG_TYPE_STATE_NUMBER S1;
   BCG_TYPE_LABEL_STRING L;
   BCG_TYPE_STATE_NUMBER S2;
   BCG_INIT ();
   BCG_IO_WRITE_BCG_BEGIN ("test.bcg", 0, 2, "created by tool", 1);
   /* for each transition labelled with L from state S1 to state S2 */
   {
      BCG_IO_WRITE_BCG_EDGE (S1, L, S2);
   }
   BCG_IO_WRITE_BCG_END ();
   return (0);
}
</PRE>
<H2><A NAME="sect12" HREF="#sect12">Label Parsing</A></H2>
The <I>label</I> argument passed to the <CODE>BCG_IO_WRITE_BCG_EDGE()</CODE> function
is a character string that should only contain printable characters; the
meaning of "printable" is given by the POSIX isprint() function with locale
"C" (namely, ASCII characters with decimal codes in the range from 32 to
126,  bounds included). Otherwise, the effect is undefined. In particular,
a label string should not be terminated with line-feed and/or carriage-return
characters. Wide characters (e.g., UTF-8, UTF-16, etc.) are not supported because
their usefulness for concurrency theory may not be worth their complexity.
<P>
The <I>label</I> arguments can be interpreted in two different ways, depending
whether label parsing is enabled or not. <P>
If label parsing is disabled, each
label is stored in the generated BCG file  as a 1-tuple (L) whose unique
field L is exactly the character string passed to <CODE>BCG_IO_WRITE_EDGE()</CODE>. In
the generated BCG file, this unique field has the RAW type (see the FIELD
PARSING section below for information about this type). <P>
Note: In legacy
BCG files generated by CADP versions up to 2014-h included, this unique
field had the STRING type; this situation is detected by more recent versions
of CADP, which automatically convert that field to the RAW type to ensure
backward compatibility. <P>
The remainder of this section discusses the case
where label parsing is enabled.  <P>
In such case, each label string is assumed
to a notation for a  tuple of typed data values (V0, V1, ..., V<I>n</I>) called <I>fields</I>.
 The number <I>n</I> is not necessarily the same for all labels, meaning that
each label can have its own number of fields. <P>
Therefore, function <CODE>BCG_IO_WRITE_BCG_EDGE()</CODE>
will attempt at parsing its <I>label</I> argument to cut it into a sequence of
fields, and analyze each field to infer its type and extract its value.
In the resulting BCG file, labels will be represented as tuple of field
values. <P>
Parsing labels is not mandatory, but it is recommended, because
it enables  certain model checkers of CADP, namely <A HREF="evaluator4.html"><B>evaluator4</B></A>
 and
<A HREF="xtl.html"><B>xtl</B></A>
 to know about the types present in labels and to use field values
to express powerful temporal logic properties. <P>
There are other CADP tools
that treat labels as mere character strings, and do not attempt at considering
fields individually. For such tools, label parsing can still be enabled,
as it is (almost) transparent: each label string is parsed and stored in
the BCG file as a tuple of binary fields; this tuple can later be converted
back into a label string by those tools that do  not examine fields. Notice,
however, that this latter label string can be slightly different from the
former one, because of various <I>normalization</I> actions that will be described
below. <P>
As a tribute to tradition, parsed labels are not noted as mathematical
tuples: <CODE>"(V0, V1, V2, ..., Vn)"</CODE>, but use the notation for labels established
by the CSP and LOTOS process algebras: <CODE>"V0 !V1 !V2 !... !Vn"</CODE>. If there is only
one field, the label is noted <CODE>"V0"</CODE>. <P>
It is recommended to leave one space
before the '<CODE>!</CODE>' character and no space after. Labels that do not follow this
convention will still be parsed properly, but will be normalized under
the recommended form if  converted back to character strings. <P>
Rules for
label parsing continue with the next section, which specifically discusses
the parsing of label fields. 
<H2><A NAME="sect13" HREF="#sect13">Field Parsing</A></H2>
<P>
Fields can be of eight possible
types: GATE, BOOLEAN, NATURAL, INTEGER, REAL,  CHARACTER, STRING, and RAW.
<P>
Note: BCG files generated with versions 1.0 or 1.1 of the BCG format (namely,
 before September 2014) had only six of these types. The NATURAL and RAW
types  were not defined; these files did not contain any value of the CHARACTER
type, and their STRING type behaved as the current RAW type. <P>
For some of
these eight types, there can be multiple field notations that lead to the
same value. For instance, the two different fields <CODE>"1"</CODE> and <CODE>"01"</CODE> express
the same number. Normalization also applies to fields and puts them under
canonical textual representation. <P>
The rules for parsing fields are applied
in the following order: 
<OL>
<LI>If the first field V0 of a label starts with a
letter that is followed by  any number of letters, digits, and/or underscore
characters, then it is  recognized and inserted in the BCG file as a value
of the GATE type. This type is an enumerated type that gathers all the gate
identifiers contained in the labels of the graph. For each gate identifier,
a corresponding constant function of type GATE is inserted in the BCG file.
The precise rules for translating fields denoting GATE values into binary
values stored in memory, and vice versa, are given by two functions <CODE>bcg_gate_scan()</CODE>
and <CODE>bcg_gate_print()</CODE> defined in file <CODE>$CADP/incl/adt_gate.h</CODE>. </LI><P><LI>If a field is
equal to "<CODE>TRUE</CODE>" or "<CODE>FALSE</CODE>" (or to their case-insensitive variants "<CODE>true</CODE>",
"<CODE>false</CODE>", "<CODE>True</CODE>", "<CODE>False</CODE>", etc.), then it is recognized and inserted in the
BCG file as a value of the BOOLEAN type.  The precise rules for translating
fields denoting BOOLEAN values into binary values stored in memory, and
vice versa, are given by two functions <CODE>bcg_boolean_scan()</CODE> and <CODE>bcg_boolean_print()</CODE>
defined in file <CODE>$CADP/incl/adt_boolean.h</CODE>. Normalization converts BOOLEAN
values to upper-case letters, either "<CODE>TRUE</CODE>" or "<CODE>FALSE</CODE>". </LI><P><LI>If a field denotes
an unsigned integer number (e.g., <CODE>0</CODE>, <CODE>1</CODE>,  <CODE>9999</CODE>, etc.), then it is recognized
and inserted in the BCG file as a value of the NATURAL type. The syntax
of NATURAL fields is the one accepted by the POSIX function <B>strtoul</B>(3).
The number must not be prefixed with a '<CODE>+</CODE>' sign. At present, only 32-bit unsigned
integers are recognized as values of the NATURAL type; larger numbers will
be considered as values of the REAL type. The precise rules for translating
fields denoting NATURAL values into binary values stored in memory, and
vice versa, are given by two functions <CODE>bcg_natural_scan()</CODE> and <CODE>bcg_natural_print()</CODE>
defined in file <CODE>$CADP/incl/adt_natural.h</CODE>. Normalization removes leading zeros
in NATURAL values. </LI><P><LI>If a field denotes a signed integer number (e.g., -9999,
<CODE>+0</CODE>,  <CODE>+1</CODE>, <CODE>+9999</CODE>, etc.), then it is recognized and inserted in the BCG  file
as a value of the INTEGER type. The syntax of INTEGER fields is the one
accepted by the POSIX function <B>strtol</B>(3). The number (even if it is zero)
must be prefixed with either a '<CODE>+</CODE>' or '<CODE>-</CODE>' sign. At present, only 32-bit signed
integers are recognized as  values of the INTEGER type; smaller or larger
numbers will be considered as values of the REAL type. The precise rules
for translating fields denoting INTEGER values into binary values stored
in memory, and vice versa, are given by two functions <CODE>bcg_integer_scan()</CODE>
and <CODE>bcg_integer_print()</CODE> defined in file <CODE>$CADP/incl/adt_integer.h</CODE>. Normalization
removes leading zeros in INTEGER values. </LI><P><LI>If a field denotes a floating-point
number (e.g., <CODE>3.1415</CODE>, <CODE>-1.2E+10</CODE>, etc.), then it is recognized and inserted in
the BCG file as a value of the REAL type. The syntax of REAL fields is the
one accepted by the POSIX function <B>strtod</B>(3). The precise rules for translating
fields denoting REAL values into binary values stored in memory, and vice
versa, are given by two functions <CODE>bcg_real_scan()</CODE> and <CODE>bcg_real_print()</CODE>
defined in file <CODE>$CADP/incl/adt_real.h</CODE>. Normalization removes leading zeros
and may add trailing zeros to REAL values. </LI><P><LI>If a field denotes a character
value (e.g., <CODE>'a'</CODE>, <CODE>'\012'</CODE>, <CODE>'\x0A'</CODE>, <CODE>'\n'</CODE>, etc.), then it is recognized and inserted in
the BCG file as a value of the CHARACTER type. The syntax of CHARACTER fields
is a simplified subset of the C language syntax: characters are enclosed
between single quotes; any printable character <I>c</I> different from the single
quote and backslash characters can be used to form a value '<I>c</I>'; the octal
 notation '\<I>ooo</I>' (where <I>ooo</I> denotes exactly three octal digits) and the hexadecimal
notation '\x<I>hh</I>' (where <I>hh</I> denotes exactly two hexadecimal digits) are supported;
the standard C notations <CODE>'\0'</CODE>, <CODE>'\a'</CODE>, <CODE>'\b'</CODE>, <CODE>'\f'</CODE>, <CODE>'\n'</CODE>, <CODE>'\r'</CODE>, <CODE>'\t'</CODE>, <CODE>'\v'</CODE>, <CODE>'\"'</CODE>, <CODE>'\\'</CODE>, <CODE>'\''</CODE> and <CODE>'\?'</CODE> are also supported;
notice that the single quote and backslash characters must be always be
escaped with a backslash, whereas the double quote and  interrogation mark
characters may be escaped or not, e.g., <CODE>'"'</CODE> or <CODE>'\"'</CODE>. The precise rules for translating
fields denoting CHARACTER values into binary values stored in memory, and
vice versa, are given by two functions <CODE>bcg_character_scan()</CODE> and <CODE>bcg_character_print()</CODE>
defined in file <CODE>$CADP/incl/adt_character.h</CODE>. Normalization converts any unprintable
CHARACTER value (the meaning  of "printable" being given  by the POSIX
isprint() function with locale "C") into three-digit octal notation; printable
CHARACTER values are displayed as such; for instance, <CODE>'\n'</CODE> and <CODE>'\x23'</CODE> are normalized
as <CODE>'\012'</CODE> and <CODE>'#'</CODE>, respectively. </LI><P><LI>If a field denotes a string value (e.g., <CODE>""</CODE>, <CODE>"a\012\x04\n"</CODE>,
 etc.), then it is recognized and inserted in the BCG file as a value of
the  STRING type. The syntax of STRING fields is a subset of that of the
C  language: characters are enclosed between double quotes and follow the
same notations as for the CHARACTER type. The only two differences are the
following: single quotes (which are always escaped in characters) can be
escaped or not in strings, while double quotes (which can be escaped or
not in characters) must be escaped in strings.  The precise rules for translating
fields denoting STRING values into binary values stored in memory, and
vice versa, are given by two functions <CODE>bcg_string_scan()</CODE> and <CODE>bcg_string_print()</CODE>
defined in file <CODE>$CADP/incl/adt_string.h</CODE>. Normalization follows the same rules
as for the CHARACTER type. If a null character (noted '<CODE>\0</CODE>', '<CODE>\000</CODE>', or '<CODE>\x00</CODE>') occurs
in the middle of a field, the remaining characters of this field will be
ignored. </LI><P><LI>If a field does not match any of the rules above (e.g., <CODE>x+y</CODE>,  <CODE>cons
(1, nil)</CODE>, etc.), then it is considered as "raw data" and inserted  in the
BCG file as a value of the RAW type. This type gathers all values whose
type cannot be determined easily. In particular, any empty field is considered
as a value of type RAW. A field of type RAW may also contain "embedded"
character and string values (e.g., <CODE>pair ("name", 'k', 28)</CODE>, etc.). Characters
in RAW fields follow the same notations as for the CHARACTER type.  The
'<CODE>!</CODE>' character, which usually signals the end of the current field and the
beginning of a new field, may occur in a RAW field provided that it  is
escaped (i.e., noted '<CODE>\!</CODE>', '<CODE>\041</CODE>', or '<CODE>\x21</CODE>');  however, this character does not need
to be escaped if it occurs in an embedded character or an embedded string.
Values of the RAW type are stored  in memory as byte strings. The precise
rules for translating fields denoting RAW values into binary values stored
in memory, and vice versa, are given by two functions <CODE>bcg_raw_scan()</CODE> and
<CODE>bcg_raw_print()</CODE> defined in file <CODE>$CADP/incl/adt_raw.h</CODE>. </LI><P>
</OL>
<P>
To summarize the effects
of label parsing and normalization on one example,  the following label
string <CODE>"   G!  true ! 003!+01E+0   "</CODE> passed to  function <CODE>BCG_IO_WRITE_BCG_EDGE()</CODE>
will be stored in the BCG file as a tuple (G, TRUE, 3, 1.0). If converted
back to a character string, it will display as "G !TRUE !3 !1.000000". 
<H2><A NAME="sect14" HREF="#sect14">Compiling
and Link Editing</A></H2>
To compile the application tool, the following options
must be passed to the C or C++ compiler: <P>
<B>-I$CADP/incl -L$CADP/bin.`$CADP/com/arch`
-lBCG_IO -lBCG -lm</B> <P>
as in, e.g., <P>
<PRE>     $CADP/src/com/cadp_cc tool.c -o tool -I$CADP/incl \
     -L$CADP/bin.`$CADP/com/arch` -lBCG_IO -lBCG -lm
</PRE>
<H2><A NAME="sect15" HREF="#sect15">Exit Status</A></H2>
Application tools share common conventions with respect to diagnostics.
 Exit status is 0 if everything is alright, 1 otherwise. 
<H2><A NAME="sect16" HREF="#sect16">Authors</A></H2>
Hubert Garavel
(definition of the BCG format) and Renaud Ruffiot (implementation of the
BCG environment). 
<H2><A NAME="sect17" HREF="#sect17">Files</A></H2>
See the <A HREF="bcg.html"><B>bcg</B></A>
 manual page for a description
of the files. 
<H2><A NAME="sect18" HREF="#sect18">See Also</A></H2>
<A HREF="bcg.html"><B>bcg</B></A>
 <P>
Additional information is available from
the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives for installation
are given in files <B>$CADP/INSTALLATION_*.</B> <P>
Recent changes and improvements
to this software are reported and commented in file <B>$CADP/HISTORY.</B> 
<H2><A NAME="sect19" HREF="#sect19">Bugs</A></H2>
Please
report bugs to <A HREF="mailto:Hubert.Garavel@inria.fr?Subject=CADP-Bug-Report">Hubert.Garavel@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Description</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Usage</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Data Types</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Features</A></LI>
<UL>
<LI><A NAME="toc5" HREF="#sect5">BCG_IO_WRITE_BCG_BEGIN</A></LI>
<LI><A NAME="toc6" HREF="#sect6">BCG_IO_WRITE_BCG_SURVIVE</A></LI>
<LI><A NAME="toc7" HREF="#sect7">BCG_IO_WRITE_BCG_EDGE</A></LI>
<LI><A NAME="toc8" HREF="#sect8">BCG_IO_WRITE_BCG_PARSING</A></LI>
<LI><A NAME="toc9" HREF="#sect9">BCG_IO_WRITE_BCG_END</A></LI>
<LI><A NAME="toc10" HREF="#sect10">BCG_IO_WRITE_BCG_ABORT</A></LI>
</UL>
<LI><A NAME="toc11" HREF="#sect11">Example</A></LI>
<LI><A NAME="toc12" HREF="#sect12">Label Parsing</A></LI>
<LI><A NAME="toc13" HREF="#sect13">Field Parsing</A></LI>
<LI><A NAME="toc14" HREF="#sect14">Compiling and Link Editing</A></LI>
<LI><A NAME="toc15" HREF="#sect15">Exit Status</A></LI>
<LI><A NAME="toc16" HREF="#sect16">Authors</A></LI>
<LI><A NAME="toc17" HREF="#sect17">Files</A></LI>
<LI><A NAME="toc18" HREF="#sect18">See Also</A></LI>
<LI><A NAME="toc19" HREF="#sect19">Bugs</A></LI>
</UL>
</BODY></HTML>
