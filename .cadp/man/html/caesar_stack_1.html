  <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>caesar_stack_1 manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
caesar_stack_1 - the ``stack_1'' library of OPEN/CAESAR 
<H2><A NAME="sect1" HREF="#sect1">Purpose</A></H2>
The ``stack_1''
library provides primitives for managing a stack when performing depth-first
search in the state graph. <P>
<P>

<H2><A NAME="sect2" HREF="#sect2">Usage</A></H2>
The ``stack_1'' library consists of: 
<UL>
<LI type=disc>a predefined
header file <CODE>caesar_stack_1.h</CODE>; </LI><P><LI type=disc>the precompiled library file <CODE>libcaesar.a</CODE>, which
implements the features described in <CODE>caesar_stack_1.h</CODE>. </LI><P>
</UL>
<P>
Note: The ``stack_1''
library is a software layer built above the primitives offered by the ``standard''
and ``edge'' libraries, and by the <I>OPEN/CAESAR</I> graph module. <P>
Note: The ``stack_1''
library relies on the ``edge'' library. Therefore, when using the ``stack_1'' library,
there are restrictions concerning the use of the ``edge'' library primitives.
These restrictions are listed in the sequel. <P>
<P>

<H2><A NAME="sect3" HREF="#sect3">Description</A></H2>
Each item in the
stack is basically a tuple with 3 fields: 
<UL>
<LI type=disc>(1) a ``label'' field containing
a label, </LI><P><LI type=disc>(2) a ``state'' field containing a state, </LI><P><LI type=disc>(3) an ``edge'' field containing
a list of edges (see the ``edge'' library). </LI><P>
</UL>
<P>
There is no constraint on the contents
of these fields. Yet, if the stack is used for a depth-first search in the
state graph (see below) it is likely that the following invariants hold:
<P>

<UL>
<LI type=disc>the state field of the stack base is the initial state of the graph; </LI><P><LI type=disc>the
label field of the stack base is undefined; </LI><P><LI type=disc>the state field of the stack
top is the current state; </LI><P><LI type=disc>the label and state fields of the stack determine
the path leading from the initial state to the current state. If, for a
given stack item (different from the top), the state field is equal to
S_1, and if, for the immediately above stack item, the label and state
fields are respectively equal to L and S_2, then ``(S_1, L, S_2)'' is an edge
of the graph; </LI><P><LI type=disc>if, for a given stack item, the state field is equal to S,
then the ``edge'' field of this item contains a list of edges outgoing from
state S; more precisely, it is the list of edges that have not been explored
yet. </LI><P><LI type=disc>the lists of edges associated to the stack items are pairwise disjoint.
Said differently, the edge fields respectively attached to different stack
items do not have shared items in common. </LI><P>
</UL>
<P>
<P>

<H2><A NAME="sect4" HREF="#sect4">Features</A></H2>
<P>
 <HR><BR>
 
<H3><A NAME="sect5" HREF="#sect5"><CODE>CAESAR_TYPE_STACK_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_ABSTRACT (...) CAESAR_TYPE_STACK_1;

</PRE>This type denotes a pointer to the concrete representation of a stack. The
stack representation is supposed to be ``opaque''. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect6" HREF="#sect6"><CODE>CAESAR_TYPE_OVERFLOW_FUNCTION_STACK_1</CODE></A></H3>
<PRE>typedef void (*CAESAR_TYPE_OVERFLOW_FUNCTION_STACK_1) (CAESAR_TYPE_STACK_1);

</PRE></CODE><CODE>CAESAR_TYPE_OVERFLOW_FUNCTION_STACK_1</CODE> is the ``pointer to an overflow procedure''
type used in the ``stack_1'' library. An overflow procedure takes one parameter
of type <CODE>CAESAR_TYPE_STACK_1</CODE>. Examples of overflow procedures are <CODE>CAESAR_OVERFLOW_SIGNAL_STACK_1()</CODE>,
<CODE>CAESAR_OVERFLOW_ABORT_STACK_1()</CODE>, and <CODE>CAESAR_OVERFLOW_IGNORE_STACK_1()</CODE> defined
below. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect7" HREF="#sect7"><CODE>CAESAR_OVERFLOW_SIGNAL_STACK_1</CODE></A></H3>
<PRE>void CAESAR_OVERFLOW_SIGNAL_STACK_1 (CAESAR_K)
    CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This procedure is a possible action that can be performed in case the stack
pointed to by <CODE>CAESAR_K</CODE> overflows (because there is not enough memory to
store new items). <P>
It first prints an error message to the standard output,
and also various statistics about the stack (including the number of items
that could not be stored in memory). Then, it returns. Practically, this
means that some portions of the graph will not be explored, but an error
message will be issued. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect8" HREF="#sect8"><CODE>CAESAR_OVERFLOW_ABORT_STACK_1</CODE></A></H3>
<PRE>void CAESAR_OVERFLOW_ABORT_STACK_1 (CAESAR_K)
    CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This procedure is a possible action that can be performed in case the stack
pointed to by <CODE>CAESAR_K</CODE> overflows (because there is not enough memory to
store new items). <P>
It first prints an error message to the standard output,
and also various statistics about the stack (including the number of items
that could not be stored in memory). Then, it aborts the program using the
C function <CODE>exit(3)</CODE>. The error code 1 is returned. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect9" HREF="#sect9"><CODE>CAESAR_OVERFLOW_IGNORE_STACK_1</CODE></A></H3>
<PRE>void CAESAR_OVERFLOW_IGNORE_STACK_1 (CAESAR_K)
    CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This procedure is a possible action that can be performed in case the stack
pointed to by <CODE>CAESAR_K</CODE> overflows (because there is not enough memory to
store new items). <P>
This procedure does nothing and returns. Practically, this
means that some portions of the graph will not be explored; they are silently
ignored. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect10" HREF="#sect10"><CODE>CAESAR_INIT_STACK_1</CODE></A></H3>
<PRE>void CAESAR_INIT_STACK_1 ()
   { ... }

</PRE>This initialization procedure must be called before using any other primitive
of the ``stack_1'' library. <P>
This procedure calls internally the initialization
procedure of the ``edge'' library; the call is done as follows: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_INIT_EDGE
(0, 1, 1, CAESAR_SIZE_POINTER(), CAESAR_ALIGNMENT_POINTER());</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
Consequently,
when using the ``stack_1'' library, it is forbidden: <P>

<UL>
<LI type=disc>to call <CODE>CAESAR_INIT_EDGE()</CODE>
directly (which would result in several calls to this procedure with undefined
results); </LI><P><LI type=disc>to use any primitive of the ``edge'' library relying on the existence
of the ``previous state'' field. </LI><P>
</UL>
<P>
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect11" HREF="#sect11"><CODE>CAESAR_CREATE_STACK_1</CODE></A></H3>
<PRE>void CAESAR_CREATE_STACK_1 (CAESAR_K, CAESAR_ORDER, CAESAR_OVERFLOW)
   CAESAR_TYPE_STACK_1 *CAESAR_K;
   CAESAR_TYPE_NATURAL CAESAR_ORDER;
   CAESAR_TYPE_OVERFLOW_FUNCTION_STACK_1 CAESAR_OVERFLOW;
   { ... }

</PRE>This procedure allocates a stack using <CODE>CAESAR_CREATE()</CODE> and assigns its
address to <CODE>*CAESAR_K</CODE>. If the allocation fails, the <CODE>NULL</CODE> value is assigned
to <CODE>*CAESAR_K</CODE>. <P>
Note: because <CODE>CAESAR_TYPE_STACK_1</CODE> is a pointer type, any variable
<CODE>CAESAR_K</CODE> of type <CODE>CAESAR_TYPE_STACK_1</CODE> must be allocated before used, for
instance using: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_CREATE_STACK_1 (&amp;CAESAR_K, ...);</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
The actual value
of the formal parameter <CODE>CAESAR_ORDER</CODE> will be stored and associated to the
stack pointed to by <CODE>*CAESAR_K</CODE>. This parameter follows the same conventions
as the formal parameter <CODE>CAESAR_ORDER</CODE> of the <CODE>CAESAR_CREATE_EDGE_LIST()</CODE> procedure
of the ``edge'' library. It will be used subsequently to determine the order
of the list of edges contained in the ``edge'' fields of the items of the stack
pointed to by <CODE>*CAESAR_K</CODE>. See below for more details. <P>
The actual value of
the formal parameter <CODE>CAESAR_OVERFLOW</CODE> will be stored and associated to the
stack pointed to by <CODE>*CAESAR_K</CODE>. It will be used subsequently to determine
the action to take if the stack pointed to by <CODE>*CAESAR_K</CODE> overflows: in this
case, the procedure pointed to by <CODE>CAESAR_OVERFLOW</CODE> will be called with the
overflowing stack <CODE>*CAESAR_K</CODE> passed as actual parameter. <P>
The above procedures
<CODE>CAESAR_OVERFLOW_SIGNAL_STACK_1()</CODE>, <CODE>CAESAR_OVERFLOW_ABORT_STACK_1()</CODE>, and
<CODE>CAESAR_OVERFLOW_IGNORE_STACK_1()</CODE>, can be used as actual values for the
formal parameter <CODE>CAESAR_OVERFLOW</CODE>. <P>
If the actual value of the formal parameter
<CODE>CAESAR_OVERFLOW</CODE> is <CODE>NULL</CODE>, it is replaced by the default value <CODE>CAESAR_OVERFLOW_SIGNAL_STACK_1</CODE>.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect12" HREF="#sect12"><CODE>CAESAR_DELETE_STACK_1</CODE></A></H3>
<PRE>void CAESAR_DELETE_STACK_1 (CAESAR_K)
   CAESAR_TYPE_STACK_1 *CAESAR_K;
   { ... }

</PRE>This procedure frees the memory space corresponding to the stack pointed
to by <CODE>*CAESAR_K</CODE> using <CODE>CAESAR_DELETE()</CODE>. Each stack item is also freed, as
well as each item of the ``edge'' field of each stack item. Afterwards, the
<CODE>NULL</CODE> value is assigned to <CODE>*CAESAR_K</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect13" HREF="#sect13"><CODE>CAESAR_PURGE_STACK_1</CODE></A></H3>
<PRE>void CAESAR_PURGE_STACK_1 (CAESAR_K)
   CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This procedure empties the stack pointed to by <CODE>CAESAR_K</CODE> without deleting
it. Each stack item is freed, as well as each item of the ``edge'' field of
each stack item. Afterwards, the stack is exactly in the same state as after
its creation using <CODE>CAESAR_CREATE_STACK_1()</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect14" HREF="#sect14"><CODE>CAESAR_COPY_STACK_1</CODE></A></H3>
<PRE>void CAESAR_COPY_STACK_1 (CAESAR_K1, CAESAR_K2, CAESAR_FULL)
   CAESAR_TYPE_STACK_1 CAESAR_K1;
   CAESAR_TYPE_STACK_1 CAESAR_K2;
   CAESAR_TYPE_BOOLEAN CAESAR_FULL;
   { ... }

</PRE>This procedure empties the stack pointed to by <CODE>CAESAR_K1</CODE> using <CODE>CAESAR_PURGE_STACK_1()</CODE>.
This stack must have been created previously using <CODE>CAESAR_CREATE_STACK_1()</CODE>.
<P>
Afterwards, the contents of the stack pointed to by <CODE>CAESAR_K2</CODE> are copied
to the stack pointed to by <CODE>CAESAR_K1</CODE>. For each item of the stack pointed
to by <CODE>CAESAR_K2</CODE>, a duplicated item is allocated and inserted into the stack
pointed to by <CODE>CAESAR_K1</CODE>. Said differently, after the copy, both stacks do
not have shared items in common. <P>
If <CODE>CAESAR_FULL</CODE> is equal to zero, the ``edge''
fields of all items in the stack pointed to by <CODE>CAESAR_K1</CODE> are set to NULL;
the ``edge'' fields of the items in the stack pointed to by <CODE>CAESAR_K2</CODE> are not
duplicated. This is useful for storing a path leading from the initial state
to the current state. <P>
In case of memory shortage, the overflow procedure
associated with <CODE>CAESAR_K1</CODE> is called with the actual parameter <CODE>CAESAR_K1</CODE>.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect15" HREF="#sect15"><CODE>CAESAR_DEPTH_STACK_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_DEPTH_STACK_1 (CAESAR_K)
   CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This function returns the number of items in the stack pointed to by <CODE>CAESAR_K</CODE>.
It returns 0 if this stack is empty. <P>
Note: the depth of a stack is the number
of states (not the number of labels) stored in the stack. Even if a stack
contains only a single state (in a depth-first search, this state is likely
to be the initial state of the graph), the depth of the stack will be 1,
not 0. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect16" HREF="#sect16"><CODE>CAESAR_BREADTH_STACK_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_BREADTH_STACK_1 (CAESAR_K)
   CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This function returns the number of items that have not been explored yet
in the stack pointed to by <CODE>CAESAR_K</CODE>. More precisely, it returns the sum,
for all stack items, of the respective lengths of the ``edge'' fields of these
items. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect17" HREF="#sect17"><CODE>CAESAR_TOP_STATE_STACK_1</CODE></A></H3>
<PRE>CAESAR_TYPE_STATE CAESAR_TOP_STATE_STACK_1 (CAESAR_K)
   CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This function returns a pointer to the ``state'' field of the item on the top
of the stack pointed to by <CODE>CAESAR_K</CODE>. If the stack is empty, the result is
undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect18" HREF="#sect18"><CODE>CAESAR_TOP_LABEL_STACK_1</CODE></A></H3>
<PRE>CAESAR_TYPE_LABEL CAESAR_TOP_LABEL_STACK_1 (CAESAR_K)
   CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This function returns a pointer to the ``label'' field of the item on the top
of the stack pointed to by <CODE>CAESAR_K</CODE>. If the stack is empty, the result is
undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect19" HREF="#sect19"><CODE>CAESAR_TOP_EDGE_STACK_1</CODE></A></H3>
<PRE>CAESAR_TYPE_EDGE CAESAR_TOP_EDGE_STACK_1 (CAESAR_K)
   CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This function returns a pointer to the ``edge'' field of the item on the top
of the stack pointed to by <CODE>CAESAR_K</CODE>. If the stack is empty, the result is
undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect20" HREF="#sect20"><CODE>CAESAR_EMPTY_STACK_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_EMPTY_STACK_1 (CAESAR_K)
   CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This function returns a value different from 0 if the stack pointed to
by <CODE>CAESAR_K</CODE> is empty, and 0 otherwise. <CODE>CAESAR_EMPTY_STACK_1 (CAESAR_K)</CODE> is
always equivalent to: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_DEPTH_STACK_1 (CAESAR_K) == 0</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
<P>
 <HR><BR>
 
<H3><A NAME="sect21" HREF="#sect21"><CODE>CAESAR_EXPLORED_STACK_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_EXPLORED_STACK_1 (CAESAR_K)
   CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This function returns a value different from 0 if the ``edge'' field of the
item on the top of the stack pointed to by <CODE>CAESAR_K</CODE> is equal to <CODE>NULL</CODE> (i.e.,
the empty edge list), and 0 otherwise. If the stack is empty, the result
is undefined. <CODE>CAESAR_EXPLORED_STACK_1 (CAESAR_K)</CODE> is always equivalent to:
<CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>*(CAESAR_TOP_EDGE_STACK_1 (CAESAR_K)) == NULL</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
<P>
 <HR><BR>
 
<H3><A NAME="sect22" HREF="#sect22"><CODE>CAESAR_CREATE_TOP_EDGE_STACK_1</CODE></A></H3>
<PRE>void CAESAR_CREATE_TOP_EDGE_STACK_1 (CAESAR_K)
   CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This procedure computes the list of the edges going out from the ``state''
field of the top of the stack pointed to by <CODE>CAESAR_K</CODE>, and assigns the result
to the ``edge'' field of the stack top. <P>
If the stack is empty, or if the ``edge''
field of the stack top is not equal to the empty list when the procedure
is called, the result is undefined. <P>
This is done by calling the <CODE>CAESAR_CREATE_EDGE_LIST()</CODE>
procedure of the ``edge'' library. The actual value given to the formal parameter
<CODE>CAESAR_ORDER</CODE> of this procedure is equal to the actual value of the formal
parameter <CODE>CAESAR_ORDER</CODE> at the time the stack was created using <CODE>CAESAR_CREATE_STACK_1()</CODE>.
<P>
In case of memory shortage, either when allocating the new item or the
list of its outgoing edges, the overflow procedure associated with <CODE>CAESAR_K</CODE>
is called with the actual parameter <CODE>CAESAR_K</CODE>. <P>
The functions <CODE>CAESAR_CREATION_EDGE_LIST()</CODE>
and <CODE>CAESAR_TRUNCATION_EDGE_LIST()</CODE> can be used in the overflow procedure.
They can also be used after any call to <CODE>CAESAR_CREATE_TOP_EDGE_STACK_1()</CODE>,
assuming that the overflow procedure has not aborted the program. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect23" HREF="#sect23"><CODE>CAESAR_DELETE_TOP_EDGE_STACK_1</CODE></A></H3>
<PRE>void CAESAR_DELETE_TOP_EDGE_STACK_1 (CAESAR_K)
   CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This procedure frees the list of the edges in the ``edge'' field of the top
of the stack pointed to by <CODE>CAESAR_K</CODE>. Afterwards, the <CODE>NULL</CODE> value is assigned
to the ``edge'' field of the stack top. <P>
If the stack is empty, the result is
undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect24" HREF="#sect24"><CODE>CAESAR_PUSH_STACK_1</CODE></A></H3>
<PRE>void CAESAR_PUSH_STACK_1 (CAESAR_K, CAESAR_L, CAESAR_S)
   CAESAR_TYPE_STACK_1 CAESAR_K;
   CAESAR_TYPE_LABEL CAESAR_L;
   CAESAR_TYPE_STATE CAESAR_S;
   { ... }

</PRE>This procedure allocates a new item, using <CODE>CAESAR_CREATE()</CODE>, and pushes
it onto the top of the stack pointed to by <CODE>CAESAR_K</CODE>. <P>
The label pointed to
by <CODE>CAESAR_L</CODE> is copied into the ``label'' field of the new stack top. However,
if <CODE>CAESAR_L</CODE> is equal to <CODE>NULL</CODE>, the ``label'' field of the new stack top is left
undefined (this is useful for pushing the base when the stack is still
empty). <P>
The state pointed to by <CODE>CAESAR_S</CODE> is copied into the ``state'' field
of the new stack top. However, if <CODE>CAESAR_S</CODE> is equal to <CODE>NULL</CODE>, the ``state'' field
of the new stack top is left undefined (this is useful for pushing the
base when the stack is still empty). <P>
The ``edge'' field of the new stack top
is initialized to <CODE>NULL</CODE>. <P>
In case of memory shortage when allocating the new
item, the overflow procedure associated with <CODE>CAESAR_K</CODE> is called with the
actual parameter <CODE>CAESAR_K</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect25" HREF="#sect25"><CODE>CAESAR_POP_STACK_1</CODE></A></H3>
<PRE>void CAESAR_POP_STACK_1 (CAESAR_K)
   CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This procedure pops the item on the top of the stack pointed to by <CODE>CAESAR_K</CODE>.
This item is freed using <CODE>CAESAR_DELETE()</CODE>. <P>
If the stack is empty, or if the
``edge'' field of the old stack top is not equal to the empty list, the result
is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect26" HREF="#sect26"><CODE>CAESAR_SWAP_STACK_1</CODE></A></H3>
<PRE>void CAESAR_SWAP_STACK_1 (CAESAR_K)
   CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This procedure removes the first item of the list of edges pointed to by
the ``edge'' field of the top of the stack pointed to by <CODE>CAESAR_K</CODE>, and pushes
it onto the top of the stack. <P>
If the stack is empty, or if the ``edge'' field
of the old stack top is equal to the empty list, the result is undefined.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect27" HREF="#sect27"><CODE>CAESAR_REJECT_STACK_1</CODE></A></H3>
<PRE>void CAESAR_REJECT_STACK_1 (CAESAR_K)
   CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This procedure removes the first item of the list of edges pointed to by
the ``edge'' field of the top of the stack pointed to by <CODE>CAESAR_K</CODE>. This item
is freed using <CODE>CAESAR_DELETE()</CODE>. <P>
If the stack is empty, or if the ``edge'' field
of the old stack top is equal to the empty list, the result is undefined.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect28" HREF="#sect28"><CODE>CAESAR_FORMAT_STACK_1</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_FORMAT_STACK_1 (CAESAR_K, CAESAR_FORMAT)
   CAESAR_TYPE_STACK_1 CAESAR_K;
   CAESAR_TYPE_FORMAT CAESAR_FORMAT;
   { ... }

</PRE>This function allows to control the format under which the stack pointed
to by <CODE>CAESAR_K</CODE> will be printed by the procedure <CODE>CAESAR_PRINT_STACK_1()</CODE>
(see below). Currently, the following formats are available: <P>

<UL>
<LI type=disc>With format
0, statistical information about the stack is displayed such as: current
depth, memory size, etc. </LI><P><LI type=disc>With format 1, the items are printed from the stack
base to the stack top. For each item, the ``label'' field is printed; however,
the ``label'' field of the stack base is not printed, since it is supposed
to be undefined. The ``state'' and ``edge'' fields are not printed. <P>
This format can
be used to display the execution sequence leading from the initial state
to the current state. </LI><P><LI type=disc>With format 2, the items are printed from the stack
base to the stack top. For each item, the ``label'' and ``state'' fields are printed;
however, the ``label'' field of the stack base is not printed, since it is
supposed to be undefined. The ``edge'' fields are not printed. <P>
This format is
intended mainly for debugging purpose. </LI><P><LI type=disc>With format 3, the items are printed
from the stack top to the stack base. For each item, the ``label'' and ``state''
fields are printed; however, the ``label'' field of the stack base is not printed,
since it is supposed to be undefined. The ``edge'' fields are not printed. <P>
This
format is intended mainly for debugging purpose. </LI><P><LI type=disc>With format 4, the items
are printed from the stack base to the stack top. For each item, the ``label'',
``state'', and ``edge'' fields are printed; however, the ``label'' field of the stack
base is not printed, since it is supposed to be undefined. <P>
This format is
intended mainly for debugging purpose. </LI><P><LI type=disc>With format 5, the items are printed
from the stack top to the stack base. For each item, the ``label'', ``state'', and
``edge'' fields are printed; however, the ``label'' field of the stack base is
not printed, since it is supposed to be undefined. <P>
This format is intended
mainly for debugging purpose. </LI><P><LI type=disc>(no other format available yet). </LI><P>
</UL>
<P>
Note: whatever
the format chosen, the stack will be displayed in a form compatible with
the SEQ format defined in the <CODE>seq</CODE> manual page of CADP. <P>
By default, the current
format of each stack is initialized to 0. <P>
When called with <CODE>CAESAR_FORMAT</CODE>
between 0 and 5, this fonction sets the current format of <CODE>CAESAR_K</CODE> to <CODE>CAESAR_FORMAT</CODE>
and returns an undefined result. <P>
When called with another value of <CODE>CAESAR_FORMAT</CODE>,
this function does not modify the current format of <CODE>CAESAR_K</CODE> but returns
a result defined as follows. If <CODE>CAESAR_FORMAT</CODE> is equal to the constant <CODE>CAESAR_CURRENT_FORMAT</CODE>,
the result is the value of the current format of <CODE>CAESAR_K</CODE>. If <CODE>CAESAR_FORMAT</CODE>
is equal to the constant <CODE>CAESAR_MAXIMAL_FORMAT</CODE>, the result is the maximal
format value (i.e., 5). In all other cases, the effect of this function is
undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect29" HREF="#sect29"><CODE>CAESAR_MAX_FORMAT_STACK_1</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_MAX_FORMAT_STACK_1 ()
   { ... }

</PRE>Caution! This function is deprecated. It should no longer be used, as it
might be removed from future versions of the <I>OPEN/CAESAR</I>. Use function <CODE>CAESAR_FORMAT_STACK_1()</CODE>
instead, called with argument <CODE>CAESAR_MAXIMAL_FORMAT</CODE>. <P>
This function returns
the maximal format value available for printing stacks. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect30" HREF="#sect30"><CODE>CAESAR_PRINT_STACK_1</CODE></A></H3>
<PRE>void CAESAR_PRINT_STACK_1 (CAESAR_FILE, CAESAR_K)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_STACK_1 CAESAR_K;
   { ... }

</PRE>This procedure prints to file <CODE>CAESAR_FILE</CODE> a text containing information
about the stack pointed to by <CODE>CAESAR_K</CODE>. The nature of the information is
determined by the current format of the stack pointed to by <CODE>CAESAR_K</CODE>. <P>
Before
this procedure is called, <CODE>CAESAR_FILE</CODE> must have been properly opened, for
instance using <CODE>fopen(3)</CODE>. <P>

<H2><A NAME="sect31" HREF="#sect31">Example</A></H2>
The following portion of C code implements
a standard depth-first search using the above primitives: <P>
<PRE>#include "caesar_stack_1.h"
 
int main ()
{
CAESAR_TYPE_STACK_1 caesar_k;
 
CAESAR_INIT_GRAPH ();
CAESAR_INIT_STACK_1 ();
 
CAESAR_CREATE_STACK_1 (&amp;caesar_k, 0, NULL);
CAESAR_PUSH_STACK_1 (caesar_k, NULL, NULL);
CAESAR_START_STATE (CAESAR_TOP_STATE_STACK_1 (caesar_k));
CAESAR_CREATE_TOP_EDGE_STACK_1 (caesar_k);
 
while (! CAESAR_EMPTY_STACK_1 (caesar_k)) {
        if (CAESAR_EXPLORED_STACK_1 (caesar_k))
                CAESAR_POP_STACK_1 (caesar_k);
        else if /* first successor already known */
                CAESAR_REJECT_STACK_1 (caesar_k);
        else    {
                CAESAR_SWAP_STACK_1 (caesar_k);
                CAESAR_CREATE_TOP_EDGE_STACK_1 (caesar_k);
                /* add new top in the heap */
             }
        }
exit (0);
}

</PRE><P>
 <HR><BR>
 
<H2><A NAME="sect32" HREF="#sect32">Author(s)</A></H2>
Hubert Garavel 
<H2><A NAME="sect33" HREF="#sect33">Files</A></H2>
 
<DL><DD><DL COMPACT>

<DT><B>$CADP/incl/caesar_graph.h</B> </DT>
<DD>interface of the
graph module </DD><P>

<DT><B>$CADP/incl/caesar_*.h</B> </DT>
<DD>interfaces of the storage module </DD><P>

<DT><B>$CADP/bin.`arch`/libcaesar.a</B>
</DT>
<DD>object code of the storage module </DD><P>

<DT><B>$CADP/src/open_caesar/*.c</B> </DT>
<DD>source code
of various exploration modules </DD><P>

<DT><B>$CADP/com/lotos.open</B> </DT>
<DD>shell script to run
OPEN/CAESAR  </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect34" HREF="#sect34">See Also</A></H2>
Reference Manuals of OPEN/CAESAR, CAESAR, and CAESAR.ADT,
<A HREF="lotos.open.html"><B>lotos.open</B></A>
, <A HREF="caesar.html"><B>caesar</B></A>
, <A HREF="caesar.adt.html"><B>caesar.adt</B></A>
 <P>
Additional information
is available from the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives
for installation are given in files <B>$CADP/INSTALLATION_*.</B> <P>
Recent changes
and improvements to this software are reported and commented in file <B>$CADP/HISTORY.</B>

<H2><A NAME="sect35" HREF="#sect35">Bugs</A></H2>
Known bugs are described in the Reference Manual of OPEN/CAESAR. Please
report new bugs to <A HREF="mailto:cadp@inria.fr?Subject=CADP-Bug-Report">cadp@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Purpose</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Usage</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Description</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Features</A></LI>
<UL>
<LI><A NAME="toc5" HREF="#sect5">CAESAR_TYPE_STACK_1</A></LI>
<LI><A NAME="toc6" HREF="#sect6">CAESAR_TYPE_OVERFLOW_FUNCTION_STACK_1</A></LI>
<LI><A NAME="toc7" HREF="#sect7">CAESAR_OVERFLOW_SIGNAL_STACK_1</A></LI>
<LI><A NAME="toc8" HREF="#sect8">CAESAR_OVERFLOW_ABORT_STACK_1</A></LI>
<LI><A NAME="toc9" HREF="#sect9">CAESAR_OVERFLOW_IGNORE_STACK_1</A></LI>
<LI><A NAME="toc10" HREF="#sect10">CAESAR_INIT_STACK_1</A></LI>
<LI><A NAME="toc11" HREF="#sect11">CAESAR_CREATE_STACK_1</A></LI>
<LI><A NAME="toc12" HREF="#sect12">CAESAR_DELETE_STACK_1</A></LI>
<LI><A NAME="toc13" HREF="#sect13">CAESAR_PURGE_STACK_1</A></LI>
<LI><A NAME="toc14" HREF="#sect14">CAESAR_COPY_STACK_1</A></LI>
<LI><A NAME="toc15" HREF="#sect15">CAESAR_DEPTH_STACK_1</A></LI>
<LI><A NAME="toc16" HREF="#sect16">CAESAR_BREADTH_STACK_1</A></LI>
<LI><A NAME="toc17" HREF="#sect17">CAESAR_TOP_STATE_STACK_1</A></LI>
<LI><A NAME="toc18" HREF="#sect18">CAESAR_TOP_LABEL_STACK_1</A></LI>
<LI><A NAME="toc19" HREF="#sect19">CAESAR_TOP_EDGE_STACK_1</A></LI>
<LI><A NAME="toc20" HREF="#sect20">CAESAR_EMPTY_STACK_1</A></LI>
<LI><A NAME="toc21" HREF="#sect21">CAESAR_EXPLORED_STACK_1</A></LI>
<LI><A NAME="toc22" HREF="#sect22">CAESAR_CREATE_TOP_EDGE_STACK_1</A></LI>
<LI><A NAME="toc23" HREF="#sect23">CAESAR_DELETE_TOP_EDGE_STACK_1</A></LI>
<LI><A NAME="toc24" HREF="#sect24">CAESAR_PUSH_STACK_1</A></LI>
<LI><A NAME="toc25" HREF="#sect25">CAESAR_POP_STACK_1</A></LI>
<LI><A NAME="toc26" HREF="#sect26">CAESAR_SWAP_STACK_1</A></LI>
<LI><A NAME="toc27" HREF="#sect27">CAESAR_REJECT_STACK_1</A></LI>
<LI><A NAME="toc28" HREF="#sect28">CAESAR_FORMAT_STACK_1</A></LI>
<LI><A NAME="toc29" HREF="#sect29">CAESAR_MAX_FORMAT_STACK_1</A></LI>
<LI><A NAME="toc30" HREF="#sect30">CAESAR_PRINT_STACK_1</A></LI>
</UL>
<LI><A NAME="toc31" HREF="#sect31">Example</A></LI>
<LI><A NAME="toc32" HREF="#sect32">Author(s)</A></LI>
<LI><A NAME="toc33" HREF="#sect33">Files</A></LI>
<LI><A NAME="toc34" HREF="#sect34">See Also</A></LI>
<LI><A NAME="toc35" HREF="#sect35">Bugs</A></LI>
</UL>
</BODY></HTML>
