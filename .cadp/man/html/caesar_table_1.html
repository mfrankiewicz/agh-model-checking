  <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>caesar_table_1 manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
caesar_table_1 - the ``table_1'' library of OPEN/CAESAR 
<H2><A NAME="sect1" HREF="#sect1">Purpose</A></H2>
The ``table_1''
library provides primitives for managing a ``state space''. It can be used either
for breadth-first or depth-first search in the state graph. <P>
<P>

<H2><A NAME="sect2" HREF="#sect2">Usage</A></H2>
The ``table_1''
library consists of: 
<UL>
<LI type=disc>a predefined header file <CODE>caesar_table_1.h</CODE>; </LI><P><LI type=disc>the precompiled
library file <CODE>libcaesar.a</CODE>, which implements the features described in <CODE>caesar_table_1.h</CODE>.
</LI><P>
</UL>
<P>
Note: The ``table_1'' library is a software layer built above the primitives
offered by the ``standard'', ``area_1'', and ``hash'' libraries, and by the <I>OPEN/CAESAR</I>
graph module. <P>
<P>

<H2><A NAME="sect3" HREF="#sect3">Description</A></H2>
A ``table'' is basically a set of items. <P>
Each item in
the table is basically a byte string of fixed size. All items in a given
table have the same size. An item can be considered as a tuple with two
fields, whose size and contents are freely determined by the user: 
<UL>
<LI type=disc>(1)
a ``base'' field, that is a byte string of fixed size. In a given table, all
base fields have the same size. This size must be greater than zero. <P>
More
often than not, the base field contains a state (as defined in the graph
module). However, this is not mandatory, and base fields can contain other
information than states. </LI><P><LI type=disc>(2) a ``mark'' field, that is a byte string whose size
and contents are freely determined by the user. In a given table, all mark
fields have the same size, which must be greater or equal to zero. Pointers
to mark fields will be considered as values of type <CODE>CAESAR_TYPE_POINTER</CODE>;
``mark'' fields are always aligned on appropriate boundaries so that the user
can put any information in these fields without alignment problem. </LI><P>
</UL>
<P>
The user
also determines the nature of the data stored in these fields, which is
not meaningful to the ``table_1'' library. <P>
Invariant property 1: the table is
organized in such a way that all items have different base fields. Said
differently, two items in a given table cannot have identical base fields
(but they can have identical mark fields). <P>
Invariant property 2: the number
of items in a given table never decreases. New items can be inserted in
the table, existing items can be replaced by new ones, but no item can
be removed if it is not replaced by another one. Exception to this rule:
it is possible to purge the table, i.e., to remove simultaneously all its
items. <P>
Invariant property 3: it is not allowed to modify the base field
of any item in the table (except if this item is to be replaced by another
one that has exactly the same hash value, which is unlikely). But it is
possible to modify the mark field of any item. <P>
Each item in a table is given
a unique identification number (``index'') which is a natural number. A table
can contain no more than a maximum of M items, with indexes between 0 and
M - 1. Currently, M = 2^{29} = 536,870,912 on 32-bit machines and M = 2^{34}
= 17,179,869,184 on 64-bit machines. But, for each table, the user can also
limit the maximal number of items to a lesser bound N &lt;= M. <P>
When the table
overflows (either because the maximum number of items is reached or because
there is no enough memory to store new items), an action chosen by the
user (e.g., abort, recovery, etc.) is performed. <P>
Each item in the table can
be accessed in three different ways: 
<UL>
<LI type=disc>(1) by using its address (i.e., a pointer
to the memory location where it is stored in the table), </LI><P><LI type=disc>(2) by using its
index, </LI><P><LI type=disc>(3) by using its base field. </LI><P>
</UL>
<P>
The table data structure establishes
a correspondence between these three data. Indeed: 
<UL>
<LI type=disc>given an address, one
can retrieve the index, the base field, and the mark field of the corresponding
item; </LI><P><LI type=disc>given an index, one can retrieve the address, the base field, and
the mark field of the corresponding item; </LI><P><LI type=disc>given a base field, one can retrieve
the address, the index, and the mark field of the corresponding item. </LI><P>
</UL>
<P>
Retrieving
the address and the index of an item from its base field involves some
associative search. To allow fast retrievals, an hash-table is associated
to each table. This is quite transparent from the user's point of view. Only
the base field is taken into account when computing the hash-value and comparing
items; the mark field is not meaningful for the search. <P>
Two special variables
are associated to a given table: 
<UL>
<LI type=disc>the ``put index'' corresponds to the last
item inserted in the table. Initialized to zero, the put index is incremented
each time a new item is inserted. Therefore, the first item is numbered
0, the second one is numbered 1, etc. <P>
The ``put index'' is always useful, whatever
the way the graph is explored: breadth-first, depth-first, etc. </LI><P><LI type=disc>the ``get index''
is associated to the last item consulted in the table. Initialized to zero,
the get index is incremented each time a new item is consulted. Since only
the items previously inserted in the table can be consulted, the get index
is always less or equal to the put index. <P>
The ``get index'' can be used to consult
sequentially all the items, in the same order as they have been inserted
in the table. Therefore it can be used for (pseudo) breadth-first exploration,
but not for depth-first exploration. </LI><P>
</UL>
<P>
Additionally, statistics are attached
to each table. These statistics consist of a ``success counter'' and a ``failure
counter'', which respectively count how many retrievals (given the base field)
have succeeded and failed. <P>
<P>

<H2><A NAME="sect4" HREF="#sect4">Features</A></H2>
<P>
 <HR><BR>
 
<H3><A NAME="sect5" HREF="#sect5"><CODE>CAESAR_TYPE_TABLE_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_ABSTRACT (...) CAESAR_TYPE_TABLE_1;

</PRE>This type denotes a pointer to the concrete representation of a table. The
table representation is supposed to be ``opaque''. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect6" HREF="#sect6"><CODE>CAESAR_TYPE_INDEX_TABLE_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_NATURAL CAESAR_TYPE_INDEX_TABLE_1;

</PRE>This type denotes an index, which is a natural number. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect7" HREF="#sect7"><CODE>CAESAR_NULL_INDEX_TABLE_1</CODE></A></H3>
<PRE>#define CAESAR_NULL_INDEX_TABLE_1 ((CAESAR_TYPE_INDEX_TABLE_1) -1L)

</PRE>This constant denotes a special index value corresponding to the largest
unsigned integer. Since item indexes are always in the range 0..M-1, no item
index can be equal to <CODE>CAESAR_NULL_INDEX_TABLE_1</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect8" HREF="#sect8"><CODE>CAESAR_MAX_INDEX_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INDEX_TABLE_1 CAESAR_MAX_INDEX_TABLE_1 ()
   { ... }

</PRE>This function returns the value of M, i.e., the maximal number of items that
can be stored in a table. Since item indexes are always in the range 0..M-1,
no item index can be equal to <CODE>CAESAR_MAX_INDEX_TABLE_1()</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect9" HREF="#sect9"><CODE>CAESAR_TYPE_OVERFLOW_FUNCTION_TABLE_1</CODE></A></H3>
<PRE>typedef void (*CAESAR_TYPE_OVERFLOW_FUNCTION_TABLE_1) (CAESAR_TYPE_TABLE_1);

</PRE></CODE><CODE>CAESAR_TYPE_OVERFLOW_FUNCTION_TABLE_1</CODE> is the ``pointer to an overflow procedure''
type used in the ``table_1'' library. An overflow procedure takes one parameter
of type <CODE>CAESAR_TYPE_TABLE_1</CODE>. Examples of overflow procedures are <CODE>CAESAR_OVERFLOW_SIGNAL_TABLE_1()</CODE>,
<CODE>CAESAR_OVERFLOW_ABORT_TABLE_1()</CODE>, and <CODE>CAESAR_OVERFLOW_IGNORE_TABLE_1()</CODE> defined
below. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect10" HREF="#sect10"><CODE>CAESAR_OVERFLOW_SIGNAL_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_OVERFLOW_SIGNAL_TABLE_1 (CAESAR_T)
    CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This procedure is a possible action that can be performed in case the table
pointed to by <CODE>CAESAR_T</CODE> overflows (either because the maximum number of
items for <CODE>CAESAR_T</CODE> is reached or because there is no enough memory to store
new items). <P>
It first prints an error message to the standard output, and
also various statistics about the table. Then, it returns. Practically, if
the table is used for state space exploration, this means that some portions
of the graph will not be explored, but an error message will be issued.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect11" HREF="#sect11"><CODE>CAESAR_OVERFLOW_ABORT_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_OVERFLOW_ABORT_TABLE_1 (CAESAR_T)
    CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This procedure is a possible action that can be performed in case the table
pointed to by <CODE>CAESAR_T</CODE> overflows (either because the maximum number of
items for <CODE>CAESAR_T</CODE> is reached or because there is no enough memory to store
new items). <P>
It first prints an error message to the standard output, and
also various statistics about the table. Then, it aborts the program using
the C function <CODE>exit(3)</CODE>. The error code 1 is returned. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect12" HREF="#sect12"><CODE>CAESAR_OVERFLOW_IGNORE_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_OVERFLOW_IGNORE_TABLE_1 (CAESAR_T)
    CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This procedure is a possible action that can be performed in case the table
pointed to by <CODE>CAESAR_T</CODE> overflows (either because the maximum number of
items for <CODE>CAESAR_T</CODE> is reached or because there is no enough memory to store
new items). <P>
It does nothing and returns. Practically, if the table is used
for state space exploration, this means that some portions of the graph
will not be explored; they are silently ignored. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect13" HREF="#sect13"><CODE>CAESAR_CREATE_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_CREATE_TABLE_1 (CAESAR_T, CAESAR_BASE_AREA, CAESAR_MARK_AREA,
                            CAESAR_LIMIT_SIZE, CAESAR_HASH_SIZE,
                            CAESAR_PRIME, CAESAR_COMPARE, CAESAR_HASH,
                            CAESAR_PRINT, CAESAR_OVERFLOW)
   CAESAR_TYPE_TABLE_1 *CAESAR_T;
   CAESAR_TYPE_AREA_1 CAESAR_BASE_AREA;
   CAESAR_TYPE_AREA_1 CAESAR_MARK_AREA;
   CAESAR_TYPE_NATURAL CAESAR_LIMIT_SIZE;
   CAESAR_TYPE_NATURAL CAESAR_HASH_SIZE;
   CAESAR_TYPE_BOOLEAN CAESAR_PRIME;
   CAESAR_TYPE_COMPARE_FUNCTION CAESAR_COMPARE;
   CAESAR_TYPE_HASH_FUNCTION CAESAR_HASH;
   CAESAR_TYPE_PRINT_FUNCTION CAESAR_PRINT;
   CAESAR_TYPE_OVERFLOW_FUNCTION_TABLE_1 CAESAR_OVERFLOW;
   { ... }

</PRE>This procedure allocates a table using <CODE>CAESAR_CREATE()</CODE> and assigns its
address to <CODE>*CAESAR_T</CODE>. If the allocation fails, the <CODE>NULL</CODE> value is assigned
to <CODE>*CAESAR_T</CODE>. <P>
Note: when it is called, this procedure does not allocate
at once all the memory needed to represent the table: the table will grow
progressively as new items are inserted. Consequently, if <CODE>CAESAR_CREATE_TABLE_1()</CODE>
returns a value different from <CODE>NULL</CODE>, this does not mean that no overflow
will occur in the future. <P>
Note: because <CODE>CAESAR_TYPE_TABLE_1</CODE> is a pointer
type, any variable <CODE>CAESAR_T</CODE> of type <CODE>CAESAR_TYPE_TABLE_1</CODE> must be allocated
before used, for instance using: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_CREATE_TABLE_1 (&amp;CAESAR_T, ...);</CODE>
</TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
The value of <CODE>CAESAR_BASE_AREA</CODE> determines the (constant) size and (constant)
alignment factor of the base field in the table. In the particular case
where base fields are used to store states (resp. labels, strings), one
must give the value <CODE>CAESAR_STATE_AREA_1()</CODE> (resp. <CODE>CAESAR_LABEL_AREA_1()</CODE>,
<CODE>CAESAR_STRING_AREA_1()</CODE>) to the formal parameter <CODE>CAESAR_BASE_AREA</CODE>. <P>
Note:
For backward compatibility reasons, if <CODE>CAESAR_BASE_AREA</CODE> is equal to <CODE>CAESAR_EMPTY_AREA_1()</CODE>,
it will be treated exactly like <CODE>CAESAR_STATE_AREA_1()</CODE>, i.e., specifying an
empty area for the base field is equivalent to specifying a state area.
However, relying on this feature is not recommended and this case will
no longer be considered in the sequel of this manual. <P>
The value of <CODE>CAESAR_MARK_AREA</CODE>
determines the (constant) size and (constant) alignment factor of the mark
field according to the specifications of the ``area_1'' library. In particular,
if <CODE>CAESAR_MARK_AREA</CODE> is equal to <CODE>CAESAR_EMPTY_AREA_1()</CODE>, there will be no
mark field in the table. <P>
Each item in the table will be represented as a
byte string of fixed size <CODE>caesar_item_size</CODE>, such that <CODE>caesar_item_size</CODE>
is strictly greater than <CODE>caesar_base_size + caesar_mark_size</CODE>, where <CODE>caesar_base_size</CODE>
denotes the size (in bytes) of the base field (i.e., <CODE>CAESAR_SIZE_AREA_1 (CAESAR_BASE_AREA)</CODE>)
and where <CODE>caesar_mark_size</CODE> denotes the size (in bytes) of the mark field,
if any (i.e., <CODE>CAESAR_SIZE_AREA_1 (CAESAR_MARK_AREA)</CODE>). <P>
An item in the table
contains not only the base field and the mark field, but also additional
information needed for internal management. Also, ``padding'' bytes may be inserted
around the base and mark fields to ensure that these fields are correctly
aligned according to <CODE>CAESAR_ALIGNMENT_AREA_1 (CAESAR_BASE_AREA)</CODE> and <CODE>CAESAR_ALIGNMENT_AREA_1
(CAESAR_MARK_AREA)</CODE>. <P>
The value of <CODE>CAESAR_LIMIT_SIZE</CODE> determines the maximal
number of items that can be stored in the table; all indexes will consequently
be in the range 0..<CODE>CAESAR_LIMIT_SIZE</CODE> - 1. It must be less or equal to M. If
it is equal to zero, it is replaced by the default value M. <P>
Note: in order
to spare memory, the value of <CODE>CAESAR_LIMIT_SIZE</CODE> (which is an upper bound
on the number of items to be inserted in the table) should be as small
as possible. This can only be done if the user has some knowledge about
the way the table will be used. The value of <CODE>CAESAR_LIMIT_SIZE</CODE> (or its default
value if <CODE>CAESAR_LIMIT_SIZE</CODE> is equal to zero) might be reduced automatically
if it exceeds the number of all possible different base fields or if it
exceeds the amount of physical memory available (which is either specified
by the environment variable <CODE>$CADP_MEMORY</CODE> or determined automatically by
the <CODE>cadp_memory</CODE> program). <P>
The value of <CODE>CAESAR_HASH_SIZE</CODE> determines the number
of entries in the hash-table associated to the table. If <CODE>CAESAR_HASH_SIZE</CODE>
is different from zero, it remains constant during the entire existence
of the table (static hashing scheme). If <CODE>CAESAR_HASH_SIZE</CODE> is equal to zero,
it is replaced with a default value greater than zero that might increase
automatically when a sufficiently large number of items have been inserted
into the table (dynamic hashing scheme). <P>
Note: in order to spare memory,
the value of <CODE>CAESAR_HASH_SIZE</CODE> (or its default value if <CODE>CAESAR_HASH_SIZE</CODE>
is equal to zero) might be reduced automatically if it exceeds the value
of <CODE>CAESAR_LIMIT_SIZE</CODE>, i.e., the maximal number of items that can be stored
in the table, or if it exceeds the maximal number of different hash values
that can be obtained taking into account the ``hashable'' size of <CODE>CAESAR_BASE_AREA</CODE>.
<P>
If the value of <CODE>CAESAR_PRIME</CODE> is equal to <CODE>CAESAR_TRUE</CODE> and if the value of
<CODE>CAESAR_HASH_SIZE</CODE> is not a prime number, this value will be replaced by
the nearest smaller prime number (since some hash functions require prime
modulus). Otherwise, the value of <CODE>CAESAR_HASH_SIZE</CODE> will be kept unchanged.
<P>
The actual value of the formal parameter <CODE>CAESAR_COMPARE</CODE> will be stored
and associated to the table pointed to by <CODE>*CAESAR_T</CODE>. It will be used as
a comparison function when it is necessary to decide whether two base fields
are equal or not. <P>
Precisely, the actual value of <CODE>CAESAR_COMPARE</CODE> should be
a pointer to a comparison function with two parameters <CODE>caesar_base_1</CODE> and
<CODE>caesar_base_2</CODE> that returns <CODE>CAESAR_TRUE</CODE> if the two base fields pointed to
by <CODE>caesar_base_1</CODE> and <CODE>caesar_base_2</CODE> are equal. <P>
If the actual value of the
formal parameter <CODE>CAESAR_COMPARE</CODE> is <CODE>NULL</CODE>, it is replaced by a pointer to
a default comparison function that depends on the value of <CODE>CAESAR_BASE_AREA</CODE>
and is determined according to the rules specified for function <CODE>CAESAR_USE_COMPARE_FUNCTION_AREA_1()</CODE>
of the ``area_1'' library. <P>
The actual value of the formal parameter <CODE>CAESAR_HASH</CODE>
will be stored and associated to the table pointed to by <CODE>*CAESAR_T</CODE>. It will
be used as a hash-function when it is necessary to compute a hash-value for
searching or inserting an item in the table. <P>
Precisely, the actual value
of <CODE>CAESAR_HASH</CODE> should be a pointer to a hash function with two parameters
<CODE>caesar_pointer</CODE> and <CODE>caesar_modulus</CODE> that returns a natural number in the
range 0..<CODE>caesar_modulus</CODE>-1. <P>
If the actual value of the formal parameter <CODE>CAESAR_HASH</CODE>
is <CODE>NULL</CODE>, it is replaced by a pointer to a default hash function that depends
on the value of <CODE>CAESAR_BASE_AREA</CODE> and is determined according to the rules
specified for function <CODE>CAESAR_USE_HASH_FUNCTION_AREA_1()</CODE> of the ``area_1''
library. <P>
Note: for backward compatibility reasons, the current implementation
of <CODE>CAESAR_CREATE_TABLE_1()</CODE> tries to handle the case where <CODE>CAESAR_HASH</CODE> points
to an hash function with three parameters (such as the <CODE>CAESAR_0_HASH()</CODE>,
<CODE>CAESAR_1_HASH()</CODE>, ... functions provided by the ``hash'' library) instead of two.
However, this support for hash functions with three parameters only occurs
under very specific circumstances (e.g., if <CODE>CAESAR_BASE_AREA</CODE> has a null exponent
field and a non-null length field). Relying on this feature is not recommended
and this case will no longer be considered in the sequel of this manual.
<P>
The actual value of the formal parameter <CODE>CAESAR_PRINT</CODE> will be stored and
associated to the table pointed to by <CODE>*CAESAR_T</CODE>. It will be used subsequently
to print the items of this table. <P>
Precisely, the actual value of <CODE>CAESAR_PRINT</CODE>
should be a pointer to a printing procedure with two parameters <CODE>caesar_file</CODE>
and <CODE>caesar_item</CODE> that prints to file <CODE>caesar_file</CODE> information about the contents
(base field and/or mark field, if any) of the item pointed to by <CODE>caesar_item</CODE>.
<P>
If the actual value of the formal parameter <CODE>CAESAR_PRINT</CODE> is <CODE>NULL</CODE>, it is
replaced by a pointer to a default procedure that prints the base field
and the mark field, if any. The printing procedure used for the base field
(respectively, the mark field) depends on the value of <CODE>CAESAR_BASE_AREA</CODE>
(resp. <CODE>CAESAR_MARK_AREA</CODE>) and is determined according to the rules specified
for function <CODE>CAESAR_USE_PRINT_FUNCTION_AREA_1()</CODE> of the ``area_1'' library. The
actual value of the formal parameter <CODE>CAESAR_OVERFLOW</CODE> will be stored and
associated to the table pointed to by <CODE>*CAESAR_T</CODE>. It will be used subsequently
to determine the action to take if the table pointed to by <CODE>*CAESAR_T</CODE> overflows:
in this case, the procedure pointed to by <CODE>CAESAR_OVERFLOW</CODE> will be called
with the overflowing table <CODE>*CAESAR_T</CODE> passed as actual parameter. <P>
The above
procedures <CODE>CAESAR_OVERFLOW_SIGNAL_TABLE_1()</CODE>, <CODE>CAESAR_OVERFLOW_ABORT_TABLE_1()</CODE>,
and <CODE>CAESAR_OVERFLOW_IGNORE_TABLE_1()</CODE>, can be used as actual values for
the formal parameter <CODE>CAESAR_OVERFLOW</CODE>. If the actual value of the formal
parameter <CODE>CAESAR_OVERFLOW</CODE> is <CODE>NULL</CODE>, it is replaced by the default value
<CODE>CAESAR_OVERFLOW_SIGNAL_TABLE_1</CODE>. <P>
The table is initially empty. The success
and failure counters attached to the table are both initialized to 0. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect14" HREF="#sect14"><CODE>CAESAR_DELETE_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_DELETE_TABLE_1 (CAESAR_T)
   CAESAR_TYPE_TABLE_1 *CAESAR_T;
   { ... }

</PRE>This procedure frees the memory space corresponding to the table pointed
to by <CODE>*CAESAR_T</CODE> using <CODE>CAESAR_DELETE()</CODE>. The items contained in the table
and its associated hash-table are also freed. Afterwards, the <CODE>NULL</CODE> value
is assigned to <CODE>*CAESAR_T</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect15" HREF="#sect15"><CODE>CAESAR_PURGE_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_PURGE_TABLE_1 (CAESAR_T)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This procedure empties the table pointed to by <CODE>CAESAR_T</CODE> without deleting
it. Each item contained in the table is freed using <CODE>CAESAR_DELETE()</CODE>. Afterwards,
this table is exactly in the same state as after its creation using <CODE>CAESAR_CREATE_TABLE_1()</CODE>.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect16" HREF="#sect16"><CODE>CAESAR_PUT_INDEX_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INDEX_TABLE_1 CAESAR_PUT_INDEX_TABLE_1 (CAESAR_T)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This function returns the number of items that have been put in the table
pointed to by <CODE>CAESAR_T</CODE>, which is also equal to the index of the next item
to be put in the table. This number is initialized to 0 and it is incremented
every time the <CODE>CAESAR_PUT_TABLE_1()</CODE> function (see below) is called. <P>
Note:
This number is always less or equal to N, where N is the maximal number
of items that can be stored in the table; the value of N depends on the
actual value given to the formal parameter <CODE>CAESAR_LIMIT_SIZE</CODE> when the table
was created using <CODE>CAESAR_CREATE_TABLE_1()</CODE>. <P>
Note: When the table is empty,
the result returned by this function is equal to zero. When the table is
full, the result returned by this function is equal to N. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect17" HREF="#sect17"><CODE>CAESAR_PUT_BASE_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_POINTER CAESAR_PUT_BASE_TABLE_1 (CAESAR_T)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>If the table pointed to by <CODE>CAESAR_T</CODE> is not full, this function returns
a pointer to the base field of the next item to be put in the table. This
base field is initially undefined and must be assigned before calling some
other functions of the ``table_1'' library (see below). <P>
If the table pointed
to by <CODE>CAESAR_T</CODE> is full, this function returns a pointer to the base field
of a special item located beyond the table. It is permitted to modify (and
subsequently consult) the contents of this base field, but invoking the
<CODE>CAESAR_PUT_TABLE_1()</CODE> function (see below) will cause an overflow. <P>
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect18" HREF="#sect18"><CODE>CAESAR_PUT_MARK_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_POINTER CAESAR_PUT_MARK_TABLE_1 (CAESAR_T)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>If there are no mark fields in the table (due to the initialization parameters
supplied to <CODE>CAESAR_CREATE_TABLE_1()</CODE>), the result returned by <CODE>CAESAR_PUT_MARK_TABLE_1()</CODE>
is always undefined. <P>
If the table pointed to by <CODE>CAESAR_T</CODE> is not full, this
function returns a pointer to the mark field of the next item to be put
in the table. This mark field is always initialized to a bit string of 0's.
It can be consulted and modified. <P>
If the table pointed to by <CODE>CAESAR_T</CODE> is
full, this function returns a pointer to the mark field of a special item
located beyond the table. It is permitted to modify and consult the contents
of this mark field, but invoking the <CODE>CAESAR_PUT_TABLE_1()</CODE> function (see
below) will cause an overflow. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect19" HREF="#sect19"><CODE>CAESAR_PUT_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_PUT_TABLE_1 (CAESAR_T)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This procedure puts into the table pointed to by <CODE>CAESAR_T</CODE> the item whose
base field is pointed to by <CODE>CAESAR_PUT_BASE_TABLE_1 (CAESAR_T)</CODE> and whose
mark field (if any) is pointed to by <CODE>CAESAR_PUT_MARK_TABLE_1 (CAESAR_T)</CODE>.
<P>
The base field must have been assigned before this procedure is called.
<P>
This procedure assumes that no other item in the table has the same base
field. There is no attempt to check the validity of this assumption. It is
therefore of the user's responsibility to ensure that this assumption is
true. See also function <CODE>CAESAR_SEARCH_AND_PUT_TABLE_1()</CODE> below. <P>
The hash-table
associated to the table is updated to take into account the new item. To
compute the hash-value for the base field, the hash-function associated with
the table is used. <P>
If the maximum number of items in the table was already
reached when the procedure <CODE>CAESAR_PUT_TABLE_1()</CODE> was called, or in case
of memory shortage, the overflow procedure associated with <CODE>CAESAR_T</CODE> is
called with the actual parameter <CODE>CAESAR_T</CODE>. <P>
Finally, <CODE>CAESAR_PUT_INDEX_TABLE_1
(CAESAR_T)</CODE> is incremented; <CODE>CAESAR_PUT_BASE_TABLE_1 (CAESAR_T)</CODE> and <CODE>CAESAR_PUT_MARK_TABLE_1
(CAESAR_T)</CODE> are advanced, respectively, to the base field and the mark field
(if any) of the next free item. <P>
Note: the table is implemented in such a
way that <CODE>CAESAR_PUT_BASE_TABLE_1()</CODE> and <CODE>CAESAR_PUT_MARK_TABLE_1()</CODE> always
return a valid pointer, even if the table is already full. Overflow can
only occur when <CODE>CAESAR_PUT_TABLE_1()</CODE> is called, but not when <CODE>CAESAR_PUT_BASE_TABLE_1()</CODE>
or <CODE>CAESAR_PUT_MARK_TABLE_1()</CODE> are called. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect20" HREF="#sect20"><CODE>CAESAR_SEARCH_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_SEARCH_TABLE_1 (CAESAR_T, CAESAR_B, CAESAR_I,
CAESAR_P)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   CAESAR_TYPE_POINTER CAESAR_B;
   CAESAR_TYPE_INDEX_TABLE_1 *CAESAR_I;
   CAESAR_TYPE_POINTER *CAESAR_P;
   { ... }

</PRE>This function determines if there exists, in the table pointed to by <CODE>CAESAR_T</CODE>,
an item whose base field is equal to the byte string pointed to by <CODE>CAESAR_B</CODE>.
Byte string comparisons are performed using the comparison function associated
to the table. The search is done using the hash-function and hash-table associated
to the table. <P>
If so, this function returns <CODE>CAESAR_TRUE</CODE>. In this case, the
index and the address of the item are respectively assigned to <CODE>*CAESAR_I</CODE>
and <CODE>*CAESAR_P</CODE>. The success counter attached to the table is incremented.
If not, this function returns <CODE>CAESAR_FALSE</CODE>. In this case, both variables
<CODE>*CAESAR_I</CODE> and <CODE>*CAESAR_P</CODE> are left unchanged. The failure counter attached
to the table is incremented. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect21" HREF="#sect21"><CODE>CAESAR_SEARCH_AND_PUT_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_SEARCH_AND_PUT_TABLE_1 (CAESAR_T, CAESAR_I,
CAESAR_P)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   CAESAR_TYPE_INDEX_TABLE_1 *CAESAR_I;
   CAESAR_TYPE_POINTER *CAESAR_P;
    { ... }

</PRE>This function is a combination of the function <CODE>CAESAR_SEARCH_TABLE_1()</CODE>
and the procedure <CODE>CAESAR_PUT_TABLE_1()</CODE> defined above. The base field pointed
to by <CODE>CAESAR_PUT_BASE_TABLE_1 (CAESAR_T)</CODE> must have been assigned before
this function is called. <P>
It first determines if there exists, in the table
pointed by <CODE>CAESAR_T</CODE>, an item whose base field is equal to the base field
of the item pointed to by <CODE>CAESAR_PUT_BASE_TABLE_1 (CAESAR_T)</CODE>. Byte string
comparisons are performed using the comparison function associated to the
table. The search is done using the hash-function and hash-table associated
to the table. <P>
If so, this function returns <CODE>CAESAR_TRUE</CODE>. In this case, the
index and the address of the existing item are respectively assigned to
<CODE>*CAESAR_I</CODE> and <CODE>*CAESAR_P</CODE>. The success counter attached to the table is incremented.
If not, this function returns <CODE>CAESAR_FALSE</CODE>. In this case, it puts into the
table pointed to by <CODE>CAESAR_T</CODE> the item whose base field is pointed to by
<CODE>CAESAR_PUT_BASE_TABLE_1 (CAESAR_T)</CODE> and whose mark field (if any) is pointed
to by <CODE>CAESAR_PUT_MARK_TABLE_1 (CAESAR_T)</CODE>. The hash-table associated to the
table is updated to take into account the new item. The overflow procedure
associated with the table is called if overflow occurs. <P>
<CODE>CAESAR_PUT_INDEX_TABLE_1
(CAESAR_T)</CODE> is copied into <CODE>*CAESAR_I</CODE> and then incremented. <CODE>CAESAR_PUT_BASE_TABLE_1
(CAESAR_T)</CODE> is copied into <CODE>*CAESAR_P</CODE> and then advanced to the base field
of the next free item. The failure counter attached to the table is incremented.
<P>
Note: formally the body of function <CODE>CAESAR_SEARCH_AND_PUT_TABLE_1()</CODE> could
be defined as follows: <PRE>        {
        CAESAR_TYPE_BOOLEAN caesar_found;
        caesar_found = CAESAR_SEARCH_TABLE_1 (CAESAR_T,
                CAESAR_PUT_BASE_TABLE_1 (CAESAR_T), CAESAR_I, CAESAR_P);
        if (! caesar_found)
                {
                *CAESAR_I = CAESAR_PUT_INDEX_TABLE_1 (CAESAR_T);
                *CAESAR_P = CAESAR_PUT_BASE_TABLE_1 (CAESAR_T);
                CAESAR_PUT_TABLE_1 (CAESAR_T);
                }
        }

</PRE>Practically, it is implemented differently, for efficiency reasons (the
computation of the hash-value and the access through the hash-table are performed
only once, not twice). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect22" HREF="#sect22"><CODE>CAESAR_GET_INDEX_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INDEX_TABLE_1 CAESAR_GET_INDEX_TABLE_1 (CAESAR_T)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This function returns the number of items that have been got from the table
pointed to by <CODE>CAESAR_T</CODE>, which is also the index of the next item to be
got from the table. This number is initialized to 0 and it is incremented
every time the <CODE>CAESAR_GET_TABLE_1()</CODE> function (see below) is called. <P>
Note:
This number is always less or equal to the value returned by <CODE>CAESAR_PUT_INDEX_TABLE_1()</CODE>.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect23" HREF="#sect23"><CODE>CAESAR_GET_BASE_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_POINTER CAESAR_GET_BASE_TABLE_1 (CAESAR_T)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This function returns a pointer to the base field of the next item to be
got in the table pointed to by <CODE>CAESAR_T</CODE>. <P>
This pointer can only be used if
<CODE>CAESAR_GET_INDEX_TABLE_1 (CAESAR_T)</CODE> is strictly less than <CODE>CAESAR_PUT_INDEX_TABLE_1
(CAESAR_T)</CODE>. In the opposite case, the result of this function is undefined
(since it is not possible to get items that have not been put yet). <P>
The
base field pointed to by the result of <CODE>CAESAR_GET_BASE_TABLE_1()</CODE> can be
consulted, but not modified. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect24" HREF="#sect24"><CODE>CAESAR_GET_MARK_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_POINTER CAESAR_GET_MARK_TABLE_1 (CAESAR_T)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This function returns a pointer to the mark field of the next item to be
got in the table pointed to by <CODE>CAESAR_T</CODE>. If there are no mark fields in
the table (due to the initialization parameters supplied to <CODE>CAESAR_CREATE_TABLE_1()</CODE>)
the result is undefined. <P>
This pointer can only be used if <CODE>CAESAR_GET_INDEX_TABLE_1
(CAESAR_T)</CODE> is strictly less than <CODE>CAESAR_PUT_INDEX_TABLE_1 (CAESAR_T)</CODE>. In
the opposite case, the result of this function is undefined (since it is
not possible to get items that have not been put yet). <P>
The mark field pointed
to by the result of <CODE>CAESAR_GET_MARK_TABLE_1()</CODE> can be either consulted or
modified. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect25" HREF="#sect25"><CODE>CAESAR_GET_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_GET_TABLE_1 (CAESAR_T)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This procedure increments <CODE>CAESAR_GET_INDEX_TABLE_1 (CAESAR_T)</CODE>; it advances,
respectively, <CODE>CAESAR_GET_BASE_TABLE_1 (CAESAR_T)</CODE> and <CODE>CAESAR_GET_MARK_TABLE_1
(CAESAR_T)</CODE> to the base field and the mark field (if any) of the next free
item. <P>
If <CODE>CAESAR_GET_INDEX_TABLE_1 (CAESAR_T)</CODE> is equal to <CODE>CAESAR_PUT_INDEX_TABLE_1
(CAESAR_T)</CODE> when the procedure <CODE>CAESAR_GET_TABLE_1()</CODE> is called, the result
is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect26" HREF="#sect26"><CODE>CAESAR_EMPTY_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_EMPTY_TABLE_1 (CAESAR_T)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This function returns a value different from 0 if the table pointed to
by <CODE>CAESAR_T</CODE> is empty, and 0 otherwise. <CODE>CAESAR_EMPTY_TABLE_1 (CAESAR_T)</CODE> is
always equivalent to: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_PUT_INDEX_TABLE_1 (CAESAR_T) == 0</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
<P>
 <HR><BR>
 
<H3><A NAME="sect27" HREF="#sect27"><CODE>CAESAR_FULL_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_FULL_TABLE_1 (CAESAR_T)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This function returns a value different from 0 if the table pointed to
by <CODE>CAESAR_T</CODE> is full, and 0 otherwise. <CODE>CAESAR_FULL_TABLE_1 (CAESAR_T)</CODE> is
always equivalent to: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_PUT_INDEX_TABLE_1 (CAESAR_T) == $N$</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>where
N denotes the maximum number of items that the table can contain; the value
of N depends on the actual value given to the formal parameter <CODE>CAESAR_LIMIT_SIZE</CODE>
when the table was created using <CODE>CAESAR_CREATE_TABLE_1()</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect28" HREF="#sect28"><CODE>CAESAR_EXPLORED_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_EXPLORED_TABLE_1 (CAESAR_T)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This function returns a value different from 0 if the get index and the
put index are identical, or 0 otherwise. <CODE>CAESAR_EXPLORED_TABLE_1 (CAESAR_T)</CODE>
is always equivalent to: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_GET_INDEX_TABLE_1 (CAESAR_T) == CAESAR_PUT_INDEX_TABLE_1
(CAESAR_T)</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
<P>
 <HR><BR>
 
<H3><A NAME="sect29" HREF="#sect29"><CODE>CAESAR_RETRIEVE_I_B_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_RETRIEVE_I_B_TABLE_1 (CAESAR_T, CAESAR_I, CAESAR_B)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   CAESAR_TYPE_INDEX_TABLE_1 CAESAR_I;
   CAESAR_TYPE_POINTER *CAESAR_B;
   { ... }

</PRE>This procedure computes the address of the base field of the item with
index <CODE>CAESAR_I</CODE> in the table pointed to by <CODE>CAESAR_T</CODE>. This address is assigned
to <CODE>*CAESAR_B</CODE>. <P>
If <CODE>CAESAR_I</CODE> is greater or equal to the value returned by <CODE>CAESAR_PUT_INDEX_TABLE_1()</CODE>,
a <CODE>NULL</CODE> pointer is assigned to <CODE>*CAESAR_B</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect30" HREF="#sect30"><CODE>CAESAR_RETRIEVE_I_M_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_RETRIEVE_I_M_TABLE_1 (CAESAR_T, CAESAR_I, CAESAR_M)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   CAESAR_TYPE_INDEX_TABLE_1 CAESAR_I;
   CAESAR_TYPE_POINTER *CAESAR_M;
   { ... }

</PRE>This procedure computes the address of the mark field of the item with
index <CODE>CAESAR_I</CODE> in the table pointed to by <CODE>CAESAR_T</CODE>. This address is assigned
to <CODE>*CAESAR_M</CODE>. <P>
If <CODE>CAESAR_I</CODE> is greater or equal to the value returned by <CODE>CAESAR_PUT_INDEX_TABLE_1()</CODE>,
a <CODE>NULL</CODE> pointer is assigned to <CODE>*CAESAR_M</CODE>. <P>
If there are no mark fields in
the table (due to the initialization parameters supplied to <CODE>CAESAR_CREATE_TABLE_1()</CODE>)
the effect of this procedure is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect31" HREF="#sect31"><CODE>CAESAR_RETRIEVE_I_BM_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_RETRIEVE_I_BM_TABLE_1 (CAESAR_T, CAESAR_I, CAESAR_B, CAESAR_M)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   CAESAR_TYPE_INDEX_TABLE_1 CAESAR_I;
   CAESAR_TYPE_POINTER *CAESAR_B;
   CAESAR_TYPE_POINTER *CAESAR_M;
   { ... }

</PRE>This procedure computes the address of the base field of the item with
index <CODE>CAESAR_I</CODE> in the table pointed to by <CODE>CAESAR_T</CODE>. This address is assigned
to <CODE>*CAESAR_B</CODE>. <P>
It also computes the address of the mark field of the item
with index <CODE>CAESAR_I</CODE> in the table pointed to by <CODE>CAESAR_T</CODE>. This address is
assigned to <CODE>*CAESAR_M</CODE>. <P>
If <CODE>CAESAR_I</CODE> is greater or equal to the value returned
by <CODE>CAESAR_PUT_INDEX_TABLE_1()</CODE>, a <CODE>NULL</CODE> pointer is assigned to <CODE>*CAESAR_B</CODE>
and <CODE>*CAESAR_M</CODE>. <P>
If there are no mark fields in the table (due to the initialization
parameters supplied to <CODE>CAESAR_CREATE_TABLE_1()</CODE>) the effect of this procedure
is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect32" HREF="#sect32"><CODE>CAESAR_RETRIEVE_B_I_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_RETRIEVE_B_I_TABLE_1 (CAESAR_T, CAESAR_B, CAESAR_I)
CAESAR_TYPE_TABLE_1 CAESAR_T;
CAESAR_TYPE_POINTER CAESAR_B;
CAESAR_TYPE_INDEX_TABLE_1 *CAESAR_I;
   { ... }

</PRE>This procedure computes the index of the item whose base field, in the
table pointed to by <CODE>CAESAR_T</CODE>, is pointed to by <CODE>CAESAR_B</CODE>. This index is assigned
to <CODE>*CAESAR_I</CODE>. <P>
If no item stored in the table has a base field at address
<CODE>CAESAR_B</CODE>, the <CODE>CAESAR_NULL_INDEX_TABLE_1</CODE> value is assigned to <CODE>*CAESAR_I</CODE>.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect33" HREF="#sect33"><CODE>CAESAR_RETRIEVE_M_I_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_RETRIEVE_M_I_TABLE_1 (CAESAR_T, CAESAR_M, CAESAR_I)
CAESAR_TYPE_TABLE_1 CAESAR_T;
CAESAR_TYPE_POINTER CAESAR_M;
CAESAR_TYPE_INDEX_TABLE_1 *CAESAR_I;
   { ... }

</PRE>This procedure computes the index of the item whose mark field, in the
table pointed to by <CODE>CAESAR_T</CODE>, is pointed to by <CODE>CAESAR_M</CODE>. This index is assigned
to <CODE>*CAESAR_I</CODE>. <P>
If no item stored in the table has a mark field at address
<CODE>CAESAR_M</CODE>, the <CODE>CAESAR_NULL_INDEX_TABLE_1</CODE> value is assigned to <CODE>*CAESAR_I</CODE>.
<P>
If there are no mark fields in the table (due to the initialization parameters
supplied to <CODE>CAESAR_CREATE_TABLE_1()</CODE>) the effect of this procedure is undefined.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect34" HREF="#sect34"><CODE>CAESAR_RETRIEVE_B_M_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_RETRIEVE_B_M_TABLE_1 (CAESAR_T, CAESAR_B, CAESAR_M)
CAESAR_TYPE_TABLE_1 CAESAR_T;
CAESAR_TYPE_POINTER CAESAR_B;
CAESAR_TYPE_POINTER *CAESAR_M;
   { ... }

</PRE>This procedure computes, for the table pointed to by <CODE>CAESAR_T</CODE>, the address
of the mark field of the item whose base field is pointed to by <CODE>CAESAR_B</CODE>.
This address is assigned to <CODE>*CAESAR_M</CODE>. <P>
If no item stored in the table has
a base field at address <CODE>CAESAR_B</CODE>, the effect of this procedure is undefined.
<P>
If there are no mark fields in the table (due to the initialization parameters
supplied to <CODE>CAESAR_CREATE_TABLE_1()</CODE>) the effect of this procedure is undefined.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect35" HREF="#sect35"><CODE>CAESAR_RETRIEVE_M_B_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_RETRIEVE_M_B_TABLE_1 (CAESAR_T, CAESAR_M, CAESAR_B)
CAESAR_TYPE_TABLE_1 CAESAR_T;
CAESAR_TYPE_POINTER CAESAR_M;
CAESAR_TYPE_POINTER *CAESAR_B;
   { ... }

</PRE>This procedure computes, for the table pointed to by <CODE>CAESAR_T</CODE>, the address
of the base field of the item whose mark field is pointed to by <CODE>CAESAR_M</CODE>.
This address is assigned to <CODE>*CAESAR_B</CODE>. <P>
If no item stored in the table has
a mark field at address <CODE>CAESAR_M</CODE>, the effect of this procedure is undefined.
<P>
If there are no mark fields in the table (due to the initialization parameters
supplied to <CODE>CAESAR_CREATE_TABLE_1()</CODE>) the effect of this procedure is undefined.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect36" HREF="#sect36"><CODE>CAESAR_FAILURE_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_FAILURE_TABLE_1 (CAESAR_T)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This function returns the value of the failure counter of the table pointed
to by <CODE>CAESAR_T</CODE>, i.e., the number of searches that failed. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect37" HREF="#sect37"><CODE>CAESAR_SUCCESS_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_SUCCESS_TABLE_1 (CAESAR_T)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This function returns the value of the success counter of the table pointed
to by <CODE>CAESAR_T</CODE>, i.e., the number of searches that succeeded. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect38" HREF="#sect38"><CODE>CAESAR_FORMAT_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_FORMAT_TABLE_1 (CAESAR_T, CAESAR_FORMAT)
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   CAESAR_TYPE_FORMAT CAESAR_FORMAT;
   { ... }

</PRE>This function allows to control the format under which the table pointed
to by <CODE>CAESAR_T</CODE> will be printed by the procedure <CODE>CAESAR_PRINT_TABLE_1()</CODE>
(see below). <P>
Currently, the following formats are available: 
<UL>
<LI type=disc>With format
0, statistical information about the table is displayed such as: the number
of items put, the number of items got, the size in bytes, the success counter,
the failure counter, etc. </LI><P><LI type=disc>With format 1, all items in the table are printed,
sorted by increasing indexes. For each item, the corresponding index is
displayed; the base field and the mark field (if any) are also displayed
using the printing procedure associated to the table. </LI><P><LI type=disc>With format 2, all
items in the table are printed, sorted by increasing indexes. For each item,
the index, the address, and the corresponding hash-value are displayed;
the base field and the mark field (if any) are also displayed using the
printing procedure associated to the table. Informations concerning the
associated hash-table are also displayed. This format is mainly intended
for debugging purpose. </LI><P><LI type=disc>(no other format available yet) </LI><P>
</UL>
<P>
By default, the current
format of each table is initialized to 0. <P>
When called with <CODE>CAESAR_FORMAT</CODE>
between 0 and 2, this fonction sets the current format of <CODE>CAESAR_T</CODE> to <CODE>CAESAR_FORMAT</CODE>
and returns an undefined result. <P>
When called with another value of <CODE>CAESAR_FORMAT</CODE>,
this function does not modify the current format of <CODE>CAESAR_T</CODE> but returns
a result defined as follows. If <CODE>CAESAR_FORMAT</CODE> is equal to the constant <CODE>CAESAR_CURRENT_FORMAT</CODE>,
the result is the value of the current format of <CODE>CAESAR_T</CODE>. If <CODE>CAESAR_FORMAT</CODE>
is equal to the constant <CODE>CAESAR_MAXIMAL_FORMAT</CODE>, the result is the maximal
format value (i.e., 2). In all other cases, the effect of this function is
undefined. <P>
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect39" HREF="#sect39"><CODE>CAESAR_MAX_FORMAT_TABLE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_MAX_FORMAT_TABLE_1 ()
   { ... }

</PRE>Caution! This function is deprecated. It should no longer be used, as it
might be removed from future versions of the <I>OPEN/CAESAR</I>. Use function <CODE>CAESAR_FORMAT_TABLE_1()</CODE>
instead, called with argument <CODE>CAESAR_MAXIMAL_FORMAT</CODE>. <P>
This function returns
the maximal format value available for printing tables. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect40" HREF="#sect40"><CODE>CAESAR_PRINT_TABLE_1</CODE></A></H3>
<PRE>void CAESAR_PRINT_TABLE_1 (CAESAR_FILE, CAESAR_T)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_TABLE_1 CAESAR_T;
   { ... }

</PRE>This procedure prints to file <CODE>CAESAR_FILE</CODE> a text containing information
about the table pointed to by <CODE>CAESAR_T</CODE>. The nature of the information is
determined by the current format of the table pointed to by <CODE>CAESAR_T</CODE>. <P>
Before
this procedure is called, <CODE>CAESAR_FILE</CODE> must have been properly opened, for
instance using <CODE>fopen(3)</CODE>. <P>
 <HR><BR>
 
<H2><A NAME="sect41" HREF="#sect41">Author(s)</A></H2>
Hubert Garavel 
<H2><A NAME="sect42" HREF="#sect42">Files</A></H2>
 
<DL><DD><DL COMPACT>

<DT><B>$CADP/incl/caesar_graph.h</B> </DT>
<DD>interface of the
graph module </DD><P>

<DT><B>$CADP/incl/caesar_*.h</B> </DT>
<DD>interfaces of the storage module </DD><P>

<DT><B>$CADP/bin.`arch`/libcaesar.a</B>
</DT>
<DD>object code of the storage module </DD><P>

<DT><B>$CADP/src/open_caesar/*.c</B> </DT>
<DD>source code
of various exploration modules </DD><P>

<DT><B>$CADP/com/lotos.open</B> </DT>
<DD>shell script to run
OPEN/CAESAR  </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect43" HREF="#sect43">See Also</A></H2>
Reference Manuals of OPEN/CAESAR, CAESAR, and CAESAR.ADT,
<A HREF="lotos.open.html"><B>lotos.open</B></A>
, <A HREF="caesar.html"><B>caesar</B></A>
, <A HREF="caesar.adt.html"><B>caesar.adt</B></A>
 <P>
Additional information
is available from the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives
for installation are given in files <B>$CADP/INSTALLATION_*.</B> <P>
Recent changes
and improvements to this software are reported and commented in file <B>$CADP/HISTORY.</B>

<H2><A NAME="sect44" HREF="#sect44">Bugs</A></H2>
Known bugs are described in the Reference Manual of OPEN/CAESAR. Please
report new bugs to <A HREF="mailto:cadp@inria.fr?Subject=CADP-Bug-Report">cadp@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Purpose</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Usage</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Description</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Features</A></LI>
<UL>
<LI><A NAME="toc5" HREF="#sect5">CAESAR_TYPE_TABLE_1</A></LI>
<LI><A NAME="toc6" HREF="#sect6">CAESAR_TYPE_INDEX_TABLE_1</A></LI>
<LI><A NAME="toc7" HREF="#sect7">CAESAR_NULL_INDEX_TABLE_1</A></LI>
<LI><A NAME="toc8" HREF="#sect8">CAESAR_MAX_INDEX_TABLE_1</A></LI>
<LI><A NAME="toc9" HREF="#sect9">CAESAR_TYPE_OVERFLOW_FUNCTION_TABLE_1</A></LI>
<LI><A NAME="toc10" HREF="#sect10">CAESAR_OVERFLOW_SIGNAL_TABLE_1</A></LI>
<LI><A NAME="toc11" HREF="#sect11">CAESAR_OVERFLOW_ABORT_TABLE_1</A></LI>
<LI><A NAME="toc12" HREF="#sect12">CAESAR_OVERFLOW_IGNORE_TABLE_1</A></LI>
<LI><A NAME="toc13" HREF="#sect13">CAESAR_CREATE_TABLE_1</A></LI>
<LI><A NAME="toc14" HREF="#sect14">CAESAR_DELETE_TABLE_1</A></LI>
<LI><A NAME="toc15" HREF="#sect15">CAESAR_PURGE_TABLE_1</A></LI>
<LI><A NAME="toc16" HREF="#sect16">CAESAR_PUT_INDEX_TABLE_1</A></LI>
<LI><A NAME="toc17" HREF="#sect17">CAESAR_PUT_BASE_TABLE_1</A></LI>
<LI><A NAME="toc18" HREF="#sect18">CAESAR_PUT_MARK_TABLE_1</A></LI>
<LI><A NAME="toc19" HREF="#sect19">CAESAR_PUT_TABLE_1</A></LI>
<LI><A NAME="toc20" HREF="#sect20">CAESAR_SEARCH_TABLE_1</A></LI>
<LI><A NAME="toc21" HREF="#sect21">CAESAR_SEARCH_AND_PUT_TABLE_1</A></LI>
<LI><A NAME="toc22" HREF="#sect22">CAESAR_GET_INDEX_TABLE_1</A></LI>
<LI><A NAME="toc23" HREF="#sect23">CAESAR_GET_BASE_TABLE_1</A></LI>
<LI><A NAME="toc24" HREF="#sect24">CAESAR_GET_MARK_TABLE_1</A></LI>
<LI><A NAME="toc25" HREF="#sect25">CAESAR_GET_TABLE_1</A></LI>
<LI><A NAME="toc26" HREF="#sect26">CAESAR_EMPTY_TABLE_1</A></LI>
<LI><A NAME="toc27" HREF="#sect27">CAESAR_FULL_TABLE_1</A></LI>
<LI><A NAME="toc28" HREF="#sect28">CAESAR_EXPLORED_TABLE_1</A></LI>
<LI><A NAME="toc29" HREF="#sect29">CAESAR_RETRIEVE_I_B_TABLE_1</A></LI>
<LI><A NAME="toc30" HREF="#sect30">CAESAR_RETRIEVE_I_M_TABLE_1</A></LI>
<LI><A NAME="toc31" HREF="#sect31">CAESAR_RETRIEVE_I_BM_TABLE_1</A></LI>
<LI><A NAME="toc32" HREF="#sect32">CAESAR_RETRIEVE_B_I_TABLE_1</A></LI>
<LI><A NAME="toc33" HREF="#sect33">CAESAR_RETRIEVE_M_I_TABLE_1</A></LI>
<LI><A NAME="toc34" HREF="#sect34">CAESAR_RETRIEVE_B_M_TABLE_1</A></LI>
<LI><A NAME="toc35" HREF="#sect35">CAESAR_RETRIEVE_M_B_TABLE_1</A></LI>
<LI><A NAME="toc36" HREF="#sect36">CAESAR_FAILURE_TABLE_1</A></LI>
<LI><A NAME="toc37" HREF="#sect37">CAESAR_SUCCESS_TABLE_1</A></LI>
<LI><A NAME="toc38" HREF="#sect38">CAESAR_FORMAT_TABLE_1</A></LI>
<LI><A NAME="toc39" HREF="#sect39">CAESAR_MAX_FORMAT_TABLE_1</A></LI>
<LI><A NAME="toc40" HREF="#sect40">CAESAR_PRINT_TABLE_1</A></LI>
</UL>
<LI><A NAME="toc41" HREF="#sect41">Author(s)</A></LI>
<LI><A NAME="toc42" HREF="#sect42">Files</A></LI>
<LI><A NAME="toc43" HREF="#sect43">See Also</A></LI>
<LI><A NAME="toc44" HREF="#sect44">Bugs</A></LI>
</UL>
</BODY></HTML>
