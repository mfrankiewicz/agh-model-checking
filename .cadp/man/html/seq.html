 <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>SEQ manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
seq, SEQ - CADP common format for execution sequences (i.e., traces)

<H2><A NAME="sect1" HREF="#sect1">Description</A></H2>
<P>
The SEQ format (where <I>SEQ</I> stands for <I>SEQuence</I>) is used to specify
a finite set (possibly empty) of execution sequences belonging to a Labelled
Transition System (LTS). Each of these sequences is finite and starts from
the initial state of the LTS. Thus, a SEQ file specifies a subgraph of the
LTS; in this subgraph, only the initial state may have more than one successor
state (namely, if there are several sequences). <P>
The SEQ format has been
carefully designed so as to be easily readable and writable by both humans
and computer programs. For this reason, it is a character-based format. Files
in the SEQ format are expected to have a <B>.seq</B> extension. <P>
There are two versions
of the SEQ format: 
<UL>
<LI type=disc>In the <I>simple format</I>, execution sequences are merely
specified as lists of transition labels; labels are specified as character
strings. </LI><P><LI type=disc>In the <I>full format</I>, execution sequences are specified in a more
sophisticated way, using regular expressions; labels are represented either
as character strings or regular expressions. </LI><P>
</UL>
<P>
Both versions of the SEQ format
are compatible in the sense that the simple format is a subset of the full
format. Therefore, the simple format can be used at every place where the
full format is allowed. 
<H2><A NAME="sect2" HREF="#sect2">BNF-like Notation</A></H2>
<P>
The syntax of the SEQ format is
described below using a notation similar to the BNF (Backus-Naur Form) notation.
However, as the angle brackets <CODE>&lt;</CODE> and <CODE>&gt;</CODE> used in BNF are also meaningful in
the SEQ format, there are some differences with respect to the standard
BNF notation: 
<UL>
<LI type=disc>Terminal symbols are enclosed in simple quotes, whether they
are one or several characters long (for instance: <CODE>'+'</CODE>, <CODE>'"'</CODE>, <CODE>'&lt;while&gt;'</CODE>, etc.). In
particular, <CODE>'\n'</CODE> and <CODE>'\t'</CODE> denote the newline and tabulation characters. </LI><P><LI type=disc>Non-terminal
symbols are written as alphabetic identifiers (for instance, <CODE>sequence</CODE>,
<CODE>sequence_list</CODE>, etc.). Contrary to the standard BNF notation, non-terminal
symbols are not enclosed within angle brackets. </LI><P><LI type=disc>The following meta symbols
are used, with their usual meaning: parentheses for grouping, star (<CODE>*</CODE>)
for zero or more repeated occurrences, and vertical bar (<CODE>|</CODE>) for alternates.
</LI><P>
</UL>
<P>
Note: it should be understood that <CODE>*</CODE> and <CODE>'*'</CODE> do not have the same meaning:
the former is the meta-symbol denoting repeated occurrences, whereas the
latter denotes the terminal character "star". 
<H2><A NAME="sect3" HREF="#sect3">Lexical Definitions</A></H2>

<H3><A NAME="sect4" HREF="#sect4">Strings</A></H3>
A
<CODE>string</CODE> is a sequence of characters, enclosed between double quotes characters
<CODE>'"'</CODE>, that denotes a label of the LTS:  <PRE> string ::= '"' valid_character* '"'
</PRE>where <CODE>valid_character</CODE> denotes any character different from double quote
(<CODE>'"'</CODE>) and from end-of-line (<CODE>'\n'</CODE>). Consequently, a <CODE>string</CODE> cannot encompass several
lines; however, there can be several <CODE>string</CODE>s on the same line (see, e.g.,
<CODE>label</CODE> and <CODE>label_group</CODE> below). <P>
The <CODE>string</CODE>s can be used in both the simple
and full SEQ format, with the same lexical conventions. 
<H3><A NAME="sect5" HREF="#sect5">Regular Expressions</A></H3>
A
<CODE>regular_expression</CODE> is a notation for a set of labels. The <CODE>regular_expression</CODE>s
of the SEQ format are based upon UNIX basic regular expressions (see the
<B>regexp</B>(5) and <A HREF="regexp.html"><B>regexp</B></A>
 manual page for a detailed description of UNIX
basic regular expressions). Syntactically, a <CODE>regular_expression</CODE> of the SEQ
format is a UNIX basic regular expression enclosed between square brackets
<CODE>'['</CODE> and <CODE>']'</CODE>: <PRE> regular_expression ::= '[' UNIX_basic_regular_expression ']'
</PRE>Unlike standard UNIX basic regular expressions, each <CODE>regular_expression</CODE>
must satisfy two additional restrictions: 
<UL>
<LI type=disc>First, it should not be empty
(otherwise, the <CODE>regular_expression</CODE> would be confused with another meaningful
token <CODE>'[]'</CODE>). </LI><P><LI type=disc>Second, there should be exactly the same numbers of <CODE>'['</CODE> and <CODE>']'</CODE> characters
in <CODE>UNIX_basic_regular_expression</CODE>. This precludes the use of very particular
regular expressions such as <CODE>'a[^]]b'</CODE> or <CODE>'a[]bc]d'</CODE>. This restriction should not
be a problem for OPEN/CAESAR users. </LI><P>
</UL>
<P>
Like <CODE>string</CODE>s, <CODE>regular_expression</CODE>s cannot
encompass several lines; however, there can be several <CODE>regular_expression</CODE>s
on the same line (see, e.g., <CODE>label</CODE> and <CODE>label_group</CODE> below). <P>
Note: the choice
operator <CODE>'|'</CODE> is not supported in UNIX basic regular expressions. For instance,
 <PRE>      [PUT.*|GET.*]
</PRE>will search for a label of the form <CODE>"PUT.*|GET.*"</CODE> rather than for either <CODE>"PUT.*"</CODE>
or <CODE>"GET.*"</CODE>. However, the intended meaning can be obtained using the choice
operator available in the syntax of <CODE>label</CODE>s (see below): <PRE>      [PUT.*] | [GET.*]
</PRE><P>
The <CODE>regular expression</CODE>s can only be used in the full SEQ format. 
<H3><A NAME="sect6" HREF="#sect6">Blanks</A></H3>
A
<CODE>blank</CODE> is a (possibly empty) sequence of space characters <CODE>'&nbsp;'</CODE> and/or tab <CODE>'\t'</CODE>
characters: <PRE>  blank ::= ( ' ' | '\t' )*
</PRE><CODE>Blank</CODE>s can appear anywhere, at the beginning of a line, at the end of a
line, or between two tokens. They are ignored (except, of course, in <CODE>string</CODE>s
and <CODE>regular expression</CODE>s). <P>
Note: end-of-line characters (<CODE>'\n'</CODE>) are not part of
<CODE>blank</CODE>s. On the contrary, they are meaningful in the SEQ format as they are
used in the definition of many non-terminal symbols. <P>
Both versions of the
SEQ format share the same lexical conventions for <CODE>blank</CODE>s. 
<H3><A NAME="sect7" HREF="#sect7">Comments</A></H3>
A <CODE>comment</CODE>
is a sequence of characters that is meaningless and ignored. There are two
kinds of <CODE>comment</CODE>s: 
<UL>
<LI type=disc>Any sequence of characters that begins with the special
character <CODE>'\001'</CODE> (control-A) and that ends with the special character <CODE>'\002'</CODE> (control-B)
is a <CODE>comment</CODE>. A <CODE>comment</CODE> of this form may encompass several lines of text.
 The characters <CODE>'\001'</CODE> and <CODE>'\002'</CODE> have been selected because they are not visible
by the user. </LI><P><LI type=disc>Any line whose first non-blank character does not belong to
the following list of reserved characters: <CODE>'['</CODE>, <CODE>'('</CODE>, <CODE>'&lt;'</CODE>, <CODE>'"'</CODE>, <CODE>'~'</CODE>, <CODE>'\001'</CODE> is a <CODE>comment</CODE>.
This <CODE>comment</CODE> extends up to the end-of-line. This definition includes the case
of lines that contain nothing but <CODE>blanks</CODE>. </LI><P>
</UL>
<P>
Both versions of the SEQ format
share the same lexical conventions for <CODE>comment</CODE>s. 
<H2><A NAME="sect8" HREF="#sect8">Syntax of the Simple Format</A></H2>
The
following BNF-like grammar defines the syntax of the simple SEQ format. The
axiom of the grammar is <CODE>sequence_list</CODE>. <PRE>sequence_list     ::= ''
                   |  sequence
                   |  sequence '[]' '\n' sequence_list
sequence          ::= string '\n'
                   |  string '\n' sequence
                   |  '&lt;deadlock&gt;' '\n'
</PRE><P>
Note: this grammar defines a regular language. 
<H2><A NAME="sect9" HREF="#sect9">Syntax of the Full Format</A></H2>
The
following BNF-like grammar defines the syntax of the full SEQ format. The
axiom of the grammar is <CODE>sequence_list</CODE>. <PRE>sequence_list     ::= ''
                   |  sequence
                   |  sequence '[]' '\n' sequence_list

sequence          ::= label_group '\n'
                   |  label_group '\n' sequence
                   |  '&lt;deadlock&gt;' '\n'

label_group       ::= label
                   |  label '*'
                   |  label '+'
                   |  '&lt;while&gt;' label
                   |  '&lt;until&gt;' label
                   |  '&lt;while&gt;' label '&lt;until&gt;' label

label             ::= simple_label
                   |  label '&amp;' simple_label
                   |  label '|' simple_label
                   |  label '^' simple_label

simple_label      ::= '&lt;any&gt;'
                   |  string
                   |  regular_expression
                   |  '~' simple_label
                   |  '(' label ')'
</PRE> Note: each <CODE>label_group</CODE> (and consequently each <CODE>label</CODE> and <CODE>simple_label</CODE>)
appears on a single line of text. <P>
Note: from the grammar, the postfix operators
<CODE>'+'</CODE> and <CODE>'*'</CODE>, and the <CODE>'&lt;while&gt;'</CODE> and <CODE>'&lt;until&gt;'</CODE> operators have the lowest priority. Then,
the binary operators <CODE>'&amp;'</CODE>, <CODE>'|'</CODE>, and <CODE>'^'</CODE> have the same, intermediate priority.  Finally,
the prefix operator <CODE>'~'</CODE> has the highest priority. <P>
Note: the simple SEQ format
is the subset of the full SEQ format in which each <CODE>label_group</CODE> is constrained
to be simply a <CODE>string</CODE>. 
<H2><A NAME="sect10" HREF="#sect10">Semantics of the Full Format</A></H2>
The semantics of the
full format is defined by induction on its syntax; the semantics of the
simple format can be derived as a special case. <P>
Let (S0 T1 ... Tn Sn) be an
execution sequence that starts from some state S0 (not necessarily the
initial state of the LTS) and that reaches some state Sn by applying n
successive transitions T1, ..., Tn. The number n of transitions can be null.
<P>
A SEQ file contains a finite list of execution <CODE>sequence</CODE>s, separated by
the <CODE>'[]'</CODE> keyword. This list can be empty, as specified by the <CODE>''</CODE> token in the
BNF-like grammar. The semantics of the full format is only defined for a
given <CODE>sequence</CODE>: 
<UL>
<LI type=disc>If this list is empty, then the SEQ file only matches the
empty execution sequence (S0), where S0 is equal to the initial state of
the LTS. </LI><P><LI type=disc>If this list contains more than one element, then a particular
<CODE>sequence</CODE> must be selected; for instance, the <B>-seqno</B> of the <A HREF="exhibitor.html"><B>exhibitor</B></A>

tool enables the user to indicate which <CODE>sequence</CODE> is to be  considered. In
such case, the semantics of the full format is the set of all execution
sequences (S0 T1 ... Tn Sn) such that S0 is equal to the initial state of
the LTS and such that the sequence-matching  relation "(S0 T1 ... Tn Sn) |====
<CODE>sequence</CODE>" defined hereafter is satisfied. </LI><P>
</UL>

<H3><A NAME="sect11" HREF="#sect11">Definition of Simple Label Matching</A></H3>
<P>
For
any transition T of the LTS, let L(T) denote the character string generated
from the label of transition T. <P>
Let "T |= <CODE>simple_label</CODE>" be a relation expressing
that the transition T "matches" <CODE>simple_label</CODE>. This relation is defined by
induction on the syntax of <CODE>simple_label</CODE> and it is mutually recursive with
the relation "T |== <CODE>label</CODE>" defined in the next subsection. 
<DL><DD><DL COMPACT>

<DT>T |= <CODE>'&lt;any&gt;'</CODE> </DT>
<DD>is always
true <P>
</DD><P>

<DT>T |= <CODE>string</CODE> </DT>
<DD>iff L(T) is equal to <CODE>string</CODE> <P>
</DD><P>

<DT>T |= <CODE>regular_expression</CODE> </DT>
<DD>iff
L(T) matches <CODE>regular_expression</CODE> <P>
</DD><P>

<DT>T |= <CODE>'~' simple_label</CODE> </DT>
<DD>iff not T |= <CODE>simple_label</CODE>
<P>
</DD><P>

<DT>T |= <CODE>'(' label ')'</CODE> </DT>
<DD>iff T |== <CODE>label</CODE> </DD><P>
</DL></DD><P></DL>

<H3><A NAME="sect12" HREF="#sect12">Definition of Label Matching</A></H3>
<P>
Let "T |== <CODE>label</CODE>"
be a relation expressing that the transition  T "matches" <CODE>label</CODE>. This relation
is defined by induction on the syntax of <CODE>label</CODE>. 
<DL><DD><DL COMPACT>

<DT>T |== <CODE>simple_label</CODE> </DT>
<DD>iff T
|= <CODE>simple_label</CODE> <P>
</DD><P>

<DT>T |== <CODE>label</CODE> <CODE>'&amp;' simple_label</CODE> </DT>
<DD>iff T |== <CODE>label</CODE> and T |= <CODE>simple_label</CODE>
<P>
</DD><P>

<DT>T |== <CODE>label</CODE> <CODE>'|' simple_label</CODE> </DT>
<DD>iff T |== <CODE>label</CODE> or T |= <CODE>simple_label</CODE> <P>
</DD><P>

<DT>T |== <CODE>label</CODE>
<CODE>'^' simple_label</CODE> </DT>
<DD>iff T |== <CODE>label</CODE> exclusive-or T |= <CODE>simple_label</CODE> </DD><P>
</DL></DD><P></DL>
<P>
Note: <CODE>regular_expression</CODE>s
apply to <I>entire</I> <CODE>label</CODE> strings, from the first character to the last one,
and not to substrings. For instance, the <CODE>label</CODE> <CODE>'PUT !0'</CODE> will match the regular
expression <CODE>'PUT.*'</CODE>, but not <CODE>'PUT'</CODE>. Consequently, the special characters <CODE>'^'</CODE> and
<CODE>'$'</CODE> of UNIX basic regular expressions are useless in the SEQ format, and
should not be used. 
<H3><A NAME="sect13" HREF="#sect13">Definition of Label Group Matching</A></H3>
<P>
Let "(S0 T1 ... Tn Sn)
|=== <CODE>label_group</CODE>" be a relation expressing that the execution sequence (S0
T1 ... Tn Sn) matches <CODE>label_group</CODE>. This relation is defined by induction on
the syntax of <CODE>label_group</CODE>. 
<DL><DD><DL COMPACT>

<DT>(S0 T1 ... Tn Sn) |=== <CODE>label</CODE> </DT>
<DD>iff n = 1 and T1 |==
<CODE>label</CODE> <P>
</DD><P>

<DT>(S0 T1 ... Tn Sn) |=== <CODE>label '*'</CODE> </DT>
<DD>iff for all i in {1 ... n} Ti |== <CODE>label</CODE> </DD><P>
</DL></DD><P></DL>
<P>
The
remaining constructs <CODE>'+'</CODE>, <CODE>'&lt;while&gt;'</CODE>, and <CODE>'&lt;until&gt;'</CODE> used in  the syntactic definition
of <CODE>label_group</CODE> are merely shorthand notations introduced for user convenience.
They are defined as follows: 
<UL>
<LI type=disc>The construct: <PRE>      label '+'
</PRE>is equivalent to: <PRE>      label '\n'
      label '*'
</PRE>It denotes a sequence of one or more transitions matching <CODE>label</CODE>. </LI><P><LI type=disc>The construct:
<PRE>      '&lt;while&gt;' label
</PRE>is equivalent to: <PRE>      label '*'
</PRE>It denotes a sequence of zero or more transitions matching <CODE>label</CODE>. </LI><P><LI type=disc>The construct:
<PRE>      '&lt;until&gt;' label
</PRE>is equivalent to: <PRE>      '(~' label ')*' '\n'
      label
</PRE>It denotes a sequence of zero or more transitions that do not match <CODE>label</CODE>,
followed by a transition matching <CODE>label</CODE>. </LI><P><LI type=disc>The construct: <PRE>      '&lt;while&gt;' label1 '&lt;until&gt;' label2
</PRE>is equivalent to: <PRE>      '(' label1 '&amp; ~' label2 ')*' '\n'
      label2
</PRE>It denotes a sequence of zero or more transitions that match <CODE>label1</CODE> and
do not match <CODE>label2</CODE>, followed by a transition matching <CODE>label2</CODE>. </LI><P>
</UL>

<H3><A NAME="sect14" HREF="#sect14">Definition
of Sequence Matching</A></H3>
<P>
Let "(S0 T1 ... Tn Sn) |==== <CODE>sequence</CODE>" be a relation expressing
that the execution sequence (S0 T1 ... Tn Sn) matches <CODE>sequence</CODE>. This relation
is defined by induction on the syntax of <CODE>sequence</CODE>. 
<DL><DD><DL COMPACT>

<DT>(S0 T1 ... Tn Sn) |==== <CODE>label_group
'\n'</CODE> </DT>
<DD>iff (S0 T1 ... Tn Sn) |=== <CODE>label_group</CODE> <P>
</DD><P>

<DT>(S0 T1 ... Tn Sn) |==== <CODE>label_group '\n'
sequence</CODE> </DT>
<DD>iff there exists some state Sm in the sequence (S0 T1 ... Tn Sn)
such that: <BR>
(S0 T1 ... Tm Sm) |=== <CODE>label_group</CODE> and <BR>
(Sm Tm+1 ... Tn Sn) |==== <CODE>sequence</CODE> <P>
</DD><P>

<DT>(S0 T1 ... Tn Sn) |==== <CODE>'&lt;deadlock&gt;' '\n'</CODE> </DT>
<DD>iff n = 0
(the sequence is reduced to a single state) and <BR>
S0 is a sink state (no transition goes out from S0) </DD><P>
</DL></DD><P></DL>
<P>

<H2><A NAME="sect15" HREF="#sect15">Exhibitor's Semantic
Conventions</A></H2>
The current version of  <A HREF="exhibitor.html"><B>exhibitor</B></A>
 interprets the full
SEQ format in particular ways, described hereafter. 
<H3><A NAME="sect16" HREF="#sect16">Transition Labels</A></H3>
Since
<A HREF="exhibitor.html"><B>exhibitor</B></A>
 operates on the fly and is based on the OPEN/CAESAR's graph
module, it implements the aforementioned T(L) notation by invoking the
<CODE>CAESAR_STRING_LABEL()</CODE> function (see the <A HREF="caesar_graph.html"><B>caesar_graph</B></A>
 manual page).

<H3><A NAME="sect17" HREF="#sect17">Case Insensitivity</A></H3>
In order to be compatible with the conventions used by
<A HREF="caesar.html"><B>caesar</B></A>
 when printing labels as character strings, all lower-case
letters contained in <CODE>string</CODE>s and <CODE>regular_expression</CODE>s are turned  to upper
case. However, the <CODE>string</CODE>s and <CODE>regular_expression</CODE>s (case-insensitively) equal
to <CODE>"i"</CODE> or <CODE>"exit"</CODE> are recognized  as special values (denoting the internal
gate and the termination gate) and turned to lower case. <P>
This is the default
option, but it can be overriden using the <B>-case</B> option of <A HREF="exhibitor.html"><B>exhibitor</B></A>

if case sensitivity needs to be preserved. 
<H3><A NAME="sect18" HREF="#sect18">Determinization Strategy</A></H3>
<P>
Given
a <CODE>sequence</CODE>, <B>exhibitor</B> will search for execution sequences (S0 T1 ... Tn Sn)
such that S0 is equal to the initial state of the LTS and such that (S0
T1 ... Tn Sn) |==== <CODE>sequence</CODE>.  <P>
In the above second semantic rule defining sequence
matching (namely,  "(S0 T1 ... Tn Sn) |==== <CODE>label_group '\n' sequence</CODE>"), if there
exist several states Sm, the one with the greatest index m is selected.
By doing so, <B>exhibitor</B> reduces potentially non-deterministic sequences into
deterministic ones.  Intuitively, every time that <B>exhibitor</B> has the choice
between remaining in a '*'-group or leaving it, it will remain in the '*'-group.
For instance, if the label <CODE>"B"</CODE> has to be matched against the sequence:
<PRE>      (~ "A") *
      "B"
</PRE>there is a conflict, since <CODE>"B"</CODE> matches both lines of the sequence. In such
case, the sequence will not be recognized successfully, since the label
<CODE>"B"</CODE> will be used to match the first line of the sequence instead of the
second line. Therefore, the determinization strategy gives priority to the
longest match. <P>
The <B>-conflict</B> option of <B>exhibitor</B> (see the <A HREF="exhibitor.html"><B>exhibitor</B></A>

manual page for a detailed decription of this option) can be used to display
the list of all conflicts which have been solved using this determinization
strategy. <P>
The solution to this problem consists in avoiding the conflict
by making the sequence more precise: <PRE>      (~ "A" &amp; ~ "B") *
      "B"
</PRE>Similarly, the sequence: <PRE>      &lt;any&gt;*
      "A"
</PRE>will never be recognized, because of the conflict between <CODE>&lt;any&gt;</CODE> and <CODE>"A"</CODE>. 
It should be written instead: <PRE>      (~ "A") *
      "A"
</PRE>Note: translating the <CODE>label_group</CODE> construct: <PRE>      label '+'
</PRE>to: <PRE>      label '*' '\n'
      label
</PRE>would not be correct because, due to the determinization strategy, this
sequence is never recognized (one always remains in the '*'-group). 
<H3><A NAME="sect19" HREF="#sect19">Sequence
Reduction</A></H3>
<B>exhibitor</B> removes all trailing '*'-groups at the end of the sequence
to be searched, because these groups are meaningless. For instance, the
following sequence: <PRE>      "A"
      "B"*
      "C"*
</PRE>is reduced to: <PRE>      "A"
</PRE>If the sequence becomes empty due to this reduction, <B>exhibitor</B> emits a
warning and stops. 
<H2><A NAME="sect20" HREF="#sect20">Examples of Patterns</A></H2>
The following sequence: <BR>
<PRE>     "i" *
     "PUT"
     "i" *
     "GET"
</PRE>searches for an action <CODE>"PUT"</CODE>, followed by an action <CODE>"GET"</CODE>, with any number
of invisible actions <CODE>"i"</CODE> before and between. <P>
The following sequence: <PRE>     &lt;until&gt; [PUT !TRUE !.*]
     &lt;until&gt; [GET !FALSE !.*]
</PRE>searches for an action of the form <CODE>"PUT !TRUE !.*"</CODE>, followed by an action
of the form <CODE>"GET !FALSE !.*"</CODE>, with any number of visible or invisible actions
before and between. <P>
The following sequence: <PRE>        &lt;until&gt; ([SEND !.*] &amp; ~ "SEND !NULL")
</PRE>searches for an action of the form <CODE>"SEND !.*"</CODE> such that the offer associated
with gate <CODE>"SEND"</CODE> is different from <CODE>"NULL"</CODE>. <P>
The following sequence: <PRE>     &lt;until&gt; "OPEN !1"
     &lt;while&gt; ~ "CLOSE !1" &lt;until&gt; "OPEN !2"
</PRE>searches for an action <CODE>"OPEN !1"</CODE>, followed by an action <CODE>"OPEN !2"</CODE> without
any <CODE>"CLOSE !1"</CODE> action between them. <P>
The following sequence: <PRE>      &lt;any&gt;*
      &lt;deadlock&gt;
</PRE>searches for deadlocks. Thus, <B>exhibitor</B> can be used as an alternative to
<A HREF="terminator.html"><B>terminator</B></A>
, although it implements totally different algorithms.

<H2><A NAME="sect21" HREF="#sect21">How to Create a SEQ File</A></H2>
<P>
It is easy to create a SEQ file manually, using
a text editor.  It is also possible to produce a SEQ file automatically,
using the <A HREF="bcg_io.html"><B>bcg_io</B></A>
 tool, which converts to the simple SEQ format a
graph (encoded in various other formats) consisting of a set of sequences
all starting from the initial state. Finally, many CADP tools for simulation,
model checking, equivalence checking, etc. generate their output in SEQ
format when such output denotes an execution sequence or a set of execution
sequences (as opposed to more general labelled transition systems). 
<H2><A NAME="sect22" HREF="#sect22">How
to Read a SEQ File</A></H2>
<P>
The tool <A HREF="seq.open.html"><B>seq.open</B></A>
 reads a SEQ file in the simple
SEQ format. <P>
The tool <A HREF="exhibitor.html"><B>exhibitor</B></A>
 reads a SEQ file in the full SEQ format.
<P>
SEQ files can be converted to many other graph formats using the <A HREF="bcg_io.html"><B>bcg_io</B></A>

tool. 
<H2><A NAME="sect23" HREF="#sect23">Authors</A></H2>
The SEQ format was developed by Hubert Garavel (INRIA Rhone-Alpes).

<H2><A NAME="sect24" HREF="#sect24">See Also</A></H2>
<P>
<A HREF="bcg_io.html"><B>bcg_io</B></A>
, <A HREF="exhibitor.html"><B>exhibitor</B></A>
, <A HREF="seq.open.html"><B>seq.open</B></A>
 <P>
Additional information
is available from the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives
for installation are given in files <B>$CADP/INSTALLATION_*.</B> <P>
Recent changes
and improvements to this software are reported and commented in file <B>$CADP/HISTORY.</B>

<H2><A NAME="sect25" HREF="#sect25">Bugs</A></H2>
Please report any bug to <A HREF="mailto:cadp@inria.fr?Subject=CADP-Bug-Report">cadp@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Description</A></LI>
<LI><A NAME="toc2" HREF="#sect2">BNF-like Notation</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Lexical Definitions</A></LI>
<UL>
<LI><A NAME="toc4" HREF="#sect4">Strings</A></LI>
<LI><A NAME="toc5" HREF="#sect5">Regular Expressions</A></LI>
<LI><A NAME="toc6" HREF="#sect6">Blanks</A></LI>
<LI><A NAME="toc7" HREF="#sect7">Comments</A></LI>
</UL>
<LI><A NAME="toc8" HREF="#sect8">Syntax of the Simple Format</A></LI>
<LI><A NAME="toc9" HREF="#sect9">Syntax of the Full Format</A></LI>
<LI><A NAME="toc10" HREF="#sect10">Semantics of the Full Format</A></LI>
<UL>
<LI><A NAME="toc11" HREF="#sect11">Definition of Simple Label Matching</A></LI>
<LI><A NAME="toc12" HREF="#sect12">Definition of Label Matching</A></LI>
<LI><A NAME="toc13" HREF="#sect13">Definition of Label Group Matching</A></LI>
<LI><A NAME="toc14" HREF="#sect14">Definition of Sequence Matching</A></LI>
</UL>
<LI><A NAME="toc15" HREF="#sect15">Exhibitor's Semantic Conventions</A></LI>
<UL>
<LI><A NAME="toc16" HREF="#sect16">Transition Labels</A></LI>
<LI><A NAME="toc17" HREF="#sect17">Case Insensitivity</A></LI>
<LI><A NAME="toc18" HREF="#sect18">Determinization Strategy</A></LI>
<LI><A NAME="toc19" HREF="#sect19">Sequence Reduction</A></LI>
</UL>
<LI><A NAME="toc20" HREF="#sect20">Examples of Patterns</A></LI>
<LI><A NAME="toc21" HREF="#sect21">How to Create a SEQ File</A></LI>
<LI><A NAME="toc22" HREF="#sect22">How to Read a SEQ File</A></LI>
<LI><A NAME="toc23" HREF="#sect23">Authors</A></LI>
<LI><A NAME="toc24" HREF="#sect24">See Also</A></LI>
<LI><A NAME="toc25" HREF="#sect25">Bugs</A></LI>
</UL>
</BODY></HTML>
