  <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>caesar_cache_1 manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
caesar_cache_1 - the ``cache_1'' library of OPEN/CAESAR 
<H2><A NAME="sect1" HREF="#sect1">Purpose</A></H2>
The ``cache_1''
library provides primitives for storing arbitrary data items in caches,
which can be organized hierarchically. It can be used to speed up the execution
of applications that involve costly search operations (by storing data
items in caches for fast retrievals), and also to reduce the memory consumption
of state space exploration algorithms (by storing a certain amount of states
in caches). <P>
<P>

<H2><A NAME="sect2" HREF="#sect2">Usage</A></H2>
The ``cache_1'' library consists of: 
<UL>
<LI type=disc>a predefined header file
<CODE>caesar_cache_1.h</CODE>; </LI><P><LI type=disc>the precompiled library file <CODE>libcaesar.a</CODE>, which implements
the features described in <CODE>caesar_cache_1.h</CODE>. </LI><P>
</UL>
<P>
Note: The ``cache_1'' library is
a software layer built above the primitives offered by the ``standard'', ``area_1'',
and ``hash'' libraries, and by the <I>OPEN/CAESAR</I> graph module. It follows as close
as possible the principles and features of the ``table_1'' library. <P>
<P>

<H2><A NAME="sect3" HREF="#sect3">Description</A></H2>
A
``cache'' is basically a set containing a fixed number of items. <P>
Each item in
the cache is basically a byte string of fixed size. All items in a given
cache have the same size. An item can be considered as a tuple with two
fields, whose size and contents are freely determined by the user: 
<UL>
<LI type=disc>(1)
a ``base'' field, that is a byte string of fixed size. In a given cache, all
base fields have the same size. This size must be greater than zero. <P>
Sometimes,
the base field contains a state (as defined in the graph module). However,
this is not mandatory, and base fields can contain other information than
states. </LI><P><LI type=disc>(2) a ``mark'' field, that is a byte string whose size and contents
are freely determined by the user. In a given cache, all mark fields have
the same size, which must be greater or equal to zero. Pointers to mark
fields will be considered as values of type <CODE>CAESAR_TYPE_POINTER</CODE>; mark fields
are always aligned on appropriate boundaries so that the user can put any
information in these fields without alignment problem. </LI><P>
</UL>
<P>
The user also determines
the nature of the data stored in these fields, which is not meaningful
to the ``cache_1'' library. <P>
A cache is organized as a collection of ``subcaches'',
each one containing a fixed number of items. A cache can contain no more
than a maximum of P subcaches, where currently P = 256. In a cache containing
N subcaches, each subcache is assigned an unique index in the range 0..N-1.
The subcaches are linked hierarchically by a parent relation, which links
a subcache to its ``children'' subcaches. The parent relation is an acyclic
relation having as root element the subcache of index 0, denoted ``root subcache''
in the sequel. All the other subcaches are assumed to be descendants of
the root subcache, i.e., they should be reachable from the root subcache
via the parent relation. A subcache without children subcaches is called
a ``leaf'' subcache. The parent relation linking the subcaches of a cache is
not necessarily static, but can dynamically change during the usage of
the cache. <P>
A cache can contain no more than a maximum of M items. Currently,
M = 2^{29} = 536,870,912 on 32-bit machines and M = 2^{34} = 17,179,869,184
on 64-bit machines. But, for each cache, the user can also limit the maximal
number of items to a lesser bound K &lt; M. <P>
To each cache is associated its
current global date, which is the number of modifying operations performed
on the cache since it was created. The operations modifying the status of
a cache are the following: putting an item into the cache, ``hitting'' an item
(i.e., searching and finding the item) in the cache, deleting an item from
the cache, and updating an item present in the cache. In the sequel, whenever
this is understood from the context, we will use the term ``date'' to designate
the current global date of a cache. To each subcache of a cache is associated
its current local date, i.e., the date when the last modifying operation
was performed on an item present in the subcache. <P>
To each item present in
a cache are associated the following fields: 
<UL>
<LI type=disc>the date when the item was
put into the cache; </LI><P><LI type=disc>the date of the last access to the item by a put, a
hit, or an update operation; </LI><P><LI type=disc>the number of hits at the item since it was
put into the cache. </LI><P>
</UL>
<P>
All these fields can be accessed from the address of
the item (i.e., a pointer to the memory location where the item is stored
in the cache). <P>
Invariant property 1: all items present in a cache have different
dates when they were put into the cache. Therefore, the date when an item
was put into the cache can serve as unique identification number for the
item. <P>
Invariant property 2: all items present in a cache have different
last access dates (but several items may have the same number of hits).
<P>
Invariant property 3: it is not allowed to modify the base field of any
item in the cache. But it is possible to modify the mark field of any item.
<P>
Each item of a cache can be accessed by using its address or its base field.
The cache data structure establishes a correspondence between these two
data. Indeed: 
<UL>
<LI type=disc>given an address, one can retrieve the base field and the
mark field of the corresponding item; </LI><P><LI type=disc>given a base field, one can retrieve
the address and the mark field of the corresponding item. </LI><P>
</UL>
<P>
Retrieving the
address of an item from its base field involves some associative search.
To allow fast retrievals, a hash-table is associated to each cache. This
is quite transparent from the user's point of view. Only the base field is
taken into account when computing the hash-value and comparing items; the
mark field is not meaningful for the search. <P>
To each cache are associated
two counters recording the number of search and hit operations performed
on the cache, respectively. To each subcache of a cache is associated a
counter recording the number of hit operations at (items of) that subcache.
<P>
The operation of putting an item E into a cache proceeds as follows. The
item is always put into the root subcache (of index 0). When this subcache
becomes full, the item E replaces the smallest item E1 contained in this
subcache according to the order relation underlying the replacement strategy
associated to this subcache. The item E1 is put into one of the child subcaches
(of index I1) of the root subcache, determined by the parent relation between
subcaches and by the contents of the item E1. If the subcache of index I1
is also full, then the item E1 replaces the smallest item E2 contained
in this subcache, and the item E2 will be in turn put into a child subcache
(of index I2) of the subcache of index I1, and so on. This process continues
along a sequence of subcaches in the hierarchy until either it reaches
a subcache of index Ij that is not full (and can therefore accept the current
item Ej to be put into it), or it reaches a leaf subcache of index Ik that
is full. In the latter case, the item Ek+1 replaced in the leaf subcache
is stored temporarily in a field associated to the cache until the next
put operation on the cache causes another item El+1 to be replaced in some
leaf subcache of index Il that is already full; the item Ek+1 is then deleted
and replaced by El+1. <P>
The parent relation between the subcaches of a cache
is assumed to be acyclic (in order to ensure the termination of put operations),
but this condition cannot be checked at the creation of the cache because
the parent relation may change dynamically during execution. Instead, this
condition is checked at each put operation, and if a cycle between subcaches
is detected, then the operation is stopped and an appropriate error code
is set. <P>
The ``cache_1'' library supports applications involving dynamic creation
of caches. When a put operation performed on a cache C1 causes a replacement
to take place, another cache C2 can be created and the last item replaced
in C1 (which can be inspected using the <CODE>CAESAR_LAST_ITEM_REPLACED_CACHE_1()</CODE>
procedure below) can be put into C2. This enables to build hierarchies of
caches similar to the hierarchies of subcaches present in individual caches.
It is the user's responsibility to ensure that a put operation performed
on a cache of a hierarchy does not cause a cycle of put operations on the
other caches of the hierarchy. <P>
<P>

<H2><A NAME="sect4" HREF="#sect4">Features</A></H2>
<P>
 <HR><BR>
 
<H3><A NAME="sect5" HREF="#sect5"><CODE>CAESAR_TYPE_CACHE_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_ABSTRACT (...) CAESAR_TYPE_CACHE_1;

</PRE>This type denotes a pointer to the concrete representation of a cache. This
representation is supposed to be ``opaque''. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect6" HREF="#sect6"><CODE>CAESAR_TYPE_NATURAL_FUNCTION_CACHE_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_NATURAL
   (*CAESAR_TYPE_NATURAL_FUNCTION_CACHE_1) (CAESAR_TYPE_NATURAL);

</PRE>This type denotes a pointer to a function which takes as parameter a natural
number (index of a subcache) and returns a natural number (size or percentage
of the subcache). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect7" HREF="#sect7"><CODE>CAESAR_TYPE_ORDER_FUNCTION_CACHE_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_INTEGER
   (*CAESAR_TYPE_ORDER_FUNCTION_CACHE_1) (CAESAR_TYPE_CACHE_1,
      CAESAR_TYPE_POINTER, CAESAR_TYPE_POINTER);

</PRE>This type denotes a pointer to a function which takes as parameters a cache
and two pointers to items (supposed to be contained in the cache), and
returns an integer number indicating whether the first item is smaller
than, equal to, or greater than the second one modulo an order relation.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect8" HREF="#sect8"><CODE>CAESAR_TYPE_SUBCACHE_FUNCTION_CACHE_1</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_NATURAL
   (*CAESAR_TYPE_SUBCACHE_FUNCTION_CACHE_1) (CAESAR_TYPE_CACHE_1,
      CAESAR_TYPE_NATURAL, CAESAR_TYPE_POINTER);

</PRE>This type denotes a pointer to a function which takes as parameters a cache,
a natural number (index of a subcache) and a pointer to an item (the last
item replaced in the subcache), and returns a natural number (index of
the child subcache in which the replaced item will be put). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect9" HREF="#sect9"><CODE>CAESAR_TYPE_CLEANUP_FUNCTION_CACHE_1</CODE></A></H3>
<PRE>typedef void
   (*CAESAR_TYPE_CLEANUP_FUNCTION_CACHE_1) (CAESAR_TYPE_POINTER);

</PRE>This type denotes a pointer to a procedure which takes as parameter a pointer
to an item and cleans up the contents of the item (see the procedure <CODE>CAESAR_CREATE_CACHE_1()</CODE>
below). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect10" HREF="#sect10"><CODE>CAESAR_TYPE_ERROR_CACHE_1</CODE></A></H3>
<PRE>typedef enum {
     CAESAR_NONE_CACHE_1,
     CAESAR_CYCLIC_CACHE_1
}    CAESAR_TYPE_ERROR_CACHE_1;

</PRE>This enumerated type defines the error codes produced as a side effect
by calls to the procedure <CODE>CAESAR_PUT_CACHE_1()</CODE> or to the function <CODE>CAESAR_SEARCH_AND_PUT_CACHE_1()</CODE>
(see below), which put an item into a cache. The error codes have the following
meaning: 
<UL>
<LI type=disc><CODE>CAESAR_NONE_CACHE_1</CODE> indicates that the put operation was performed
successfully. </LI><P><LI type=disc><CODE>CAESAR_CYCLIC_CACHE_1</CODE> indicates the existence of a cycle in
the parent relation between subcaches, which would cause the put operation
to loop indefinitely when the subcaches present on that cycle are full.
</LI><P>
</UL>
<P>
Note: The error code produced by a call to the procedure <CODE>CAESAR_PUT_CACHE_1()</CODE>
or to the function <CODE>CAESAR_SEARCH_AND_PUT_CACHE_1()</CODE> can be obtained by using
the function <CODE>CAESAR_STATUS_PUT_CACHE_1()</CODE> (see below). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect11" HREF="#sect11"><CODE>CAESAR_LRU_ORDER_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INTEGER CAESAR_LRU_ORDER_CACHE_1 (CAESAR_C, CAESAR_B1, CAESAR_B2)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B1;
   CAESAR_TYPE_POINTER CAESAR_B2;
   { ... }

</PRE>This function returns an integer number which is smaller than, equal to,
or greater than 0 depending whether the item pointed to by <CODE>CAESAR_B1</CODE> is
smaller than, equal to, or greater than the item pointed to by <CODE>CAESAR_B2</CODE>
according to the order relation underlying the ``least recently used'' (LRU)
replacement strategy. <P>
According to this order relation, an item is smaller
than, equal to, or greater than another item if the date of the last access
to the first item is smaller than, equal to, or greater than the date of
the last access to the second item, respectively. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect12" HREF="#sect12"><CODE>CAESAR_MRU_ORDER_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INTEGER CAESAR_MRU_ORDER_CACHE_1 (CAESAR_C, CAESAR_B1, CAESAR_B2)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B1;
   CAESAR_TYPE_POINTER CAESAR_B2;
   { ... }

</PRE>This function returns an integer number which is smaller than, equal to,
or greater than 0 depending whether the item pointed to by <CODE>CAESAR_B1</CODE> is
smaller than, equal to, or greater than the item pointed to by <CODE>CAESAR_B2</CODE>
according to the order relation underlying the ``most recently used'' (MRU)
replacement strategy. <P>
According to this order relation, an item is smaller
than, equal to, or greater than another item if the date of the last access
to the first item is greater than, equal to, or smaller than the date of
the last access to the second item, respectively. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect13" HREF="#sect13"><CODE>CAESAR_LRP_ORDER_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INTEGER CAESAR_LRP_ORDER_CACHE_1 (CAESAR_C, CAESAR_B1, CAESAR_B2)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B1;
   CAESAR_TYPE_POINTER CAESAR_B2;
   { ... }

</PRE>This function returns an integer number which is smaller than, equal to,
or greater than 0 depending whether the item pointed to by <CODE>CAESAR_B1</CODE> is
smaller than, equal to, or greater than the item pointed to by <CODE>CAESAR_B2</CODE>
according to the order relation underlying the ``least recently put'' (LRP)
replacement strategy. <P>
According to this order relation, an item is smaller
than, equal to, or greater than another item if the date when the first
item was put into the cache is smaller than, equal to, or greater than
the date when the second item was put into the cache, respectively. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect14" HREF="#sect14"><CODE>CAESAR_MRP_ORDER_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INTEGER CAESAR_MRP_ORDER_CACHE_1 (CAESAR_C, CAESAR_B1, CAESAR_B2)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B1;
   CAESAR_TYPE_POINTER CAESAR_B2;
   { ... }

</PRE>This function returns an integer number which is smaller than, equal to,
or greater than 0 depending whether the item pointed to by <CODE>CAESAR_B1</CODE> is
smaller than, equal to, or greater than the item pointed to by <CODE>CAESAR_B2</CODE>
according to the order relation underlying the ``most recently put'' (MRP)
replacement strategy. <P>
According to this order relation, an item is smaller
than, equal to, or greater than another item if the date when the first
item was put into the cache is greater than, equal to, or smaller than
the date when the second item was put into the cache, respectively. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect15" HREF="#sect15"><CODE>CAESAR_LFU_ORDER_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INTEGER CAESAR_LFU_ORDER_CACHE_1 (CAESAR_C, CAESAR_B1, CAESAR_B2)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B1;
   CAESAR_TYPE_POINTER CAESAR_B2;
   { ... }

</PRE>This function returns an integer number which is smaller than, equal to,
or greater than 0 depending whether the item pointed to by <CODE>CAESAR_B1</CODE> is
smaller than, equal to, or greater than the item pointed to by <CODE>CAESAR_B2</CODE>
according to the order relation underlying the ``least frequently used'' (LFU)
replacement strategy. <P>
According to this order relation, an item is smaller
than, equal to, or greater than another item if the number of hits at the
first item is smaller than, equal to, or greater than the number of hits
at the second item, respectively. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect16" HREF="#sect16"><CODE>CAESAR_MFU_ORDER_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INTEGER CAESAR_MFU_ORDER_CACHE_1 (CAESAR_C, CAESAR_B1, CAESAR_B2)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B1;
   CAESAR_TYPE_POINTER CAESAR_B2;
   { ... }

</PRE>This function returns an integer number which is smaller than, equal to,
or greater than 0 depending whether the item pointed to by <CODE>CAESAR_B1</CODE> is
smaller than, equal to, or greater than the item pointed to by <CODE>CAESAR_B2</CODE>
according to the order relation underlying the ``most frequently used'' (MFU)
replacement strategy. <P>
According to this order relation, an item is smaller
than, equal to, or greater than another item if the number of hits at the
first item is greater than, equal to, or smaller than the number of hits
at the second item, respectively. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect17" HREF="#sect17"><CODE>CAESAR_RND_ORDER_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INTEGER CAESAR_RND_ORDER_CACHE_1 (CAESAR_C, CAESAR_B1, CAESAR_B2)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B1;
   CAESAR_TYPE_POINTER CAESAR_B2;
   { ... }

</PRE>This function returns an integer number which is smaller than, equal to,
or greater than 0 depending whether the item pointed to by <CODE>CAESAR_B1</CODE> is
smaller than, equal to, or greater than the item pointed to by <CODE>CAESAR_B2</CODE>
according to the order relation underlying the ``random'' (RND) replacement
strategy. <P>
This order relation is implemented by computing for every item
a random cost, i.e., a natural number randomly generated by taking into account
the seed associated to the cache pointed to by <CODE>CAESAR_C</CODE> (see the procedure
<CODE>CAESAR_SEED_RND_CACHE_1()</CODE> below), the current global date of the cache,
and the base field of the item. According to this relation, an item is smaller
than, equal to, or greater than another item if the random cost of the
first item is smaller than, equal to, or greater than the random cost of
the second item, respectively. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect18" HREF="#sect18"><CODE>CAESAR_LFU_LRU_ORDER_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INTEGER CAESAR_LFU_LRU_ORDER_CACHE_1 (CAESAR_C, CAESAR_B1,
CAESAR_B2)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B1;
   CAESAR_TYPE_POINTER CAESAR_B2;
   { ... }

</PRE>This function returns an integer number which is smaller than, equal to,
or greater than 0 depending whether the item pointed to by <CODE>CAESAR_B1</CODE> is
smaller than, equal to, or greater than the item pointed to by <CODE>CAESAR_B2</CODE>
according to the order relation underlying the ``least frequently used, then
least recently used'' (LFU_LRU) replacement strategy. <P>
According to this order
relation: 
<UL>
<LI type=disc>an item is smaller than another item if the number of hits at
the first item is smaller than the number of hits at the second one, or
the number of hits is the same for both items but the date of the last
access to the first item is smaller than the date of the last access to
the second one; </LI><P><LI type=disc>an item is equal to another one if the number of hits and
the date of the last access are the same for both items; </LI><P><LI type=disc>an item is greater
than another item if the number of hits at the first item is greater than
the number of hits at the second one, or the number of hits is the same
for both items but the date of the last access to the first item is greater
than the date of the last access to the second one. </LI><P>
</UL>
<P>
In other words, the
LFU_LRU replacement strategy consists in applying first the LFU, then the
LRU replacement strategies. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect19" HREF="#sect19"><CODE>CAESAR_LFU_MRU_ORDER_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INTEGER CAESAR_LFU_MRU_ORDER_CACHE_1 (CAESAR_C, CAESAR_B1,
CAESAR_B2)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B1;
   CAESAR_TYPE_POINTER CAESAR_B2;
   { ... }

</PRE>This function returns an integer number which is smaller than, equal to,
or greater than 0 depending whether the item pointed to by <CODE>CAESAR_B1</CODE> is
smaller than, equal to, or greater than the item pointed to by <CODE>CAESAR_B2</CODE>
according to the order relation underlying the ``least frequently used, then
most recently used'' (LFU_MRU) replacement strategy. <P>
According to this order
relation: 
<UL>
<LI type=disc>an item is smaller than another item if the number of hits at
the first item is smaller than the number of hits at the second one, or
the number of hits is the same for both items but the date of the last
access to the first item is greater than the date of the last access to
the second one; </LI><P><LI type=disc>an item is equal to another one if the number of hits and
the date of the last access are the same for both items; </LI><P><LI type=disc>an item is greater
than another item if the number of hits at the first item is greater than
the number of hits at the second one, or the number of hits is the same
for both items but the date of the last access to the first item is smaller
than the date of the last access to the second one. </LI><P>
</UL>
<P>
In other words, the
LFU_MRU replacement strategy consists in applying first the LFU, then the
MRU replacement strategies. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect20" HREF="#sect20"><CODE>CAESAR_LFU_LRP_ORDER_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INTEGER CAESAR_LFU_LRP_ORDER_CACHE_1 (CAESAR_C, CAESAR_B1,
CAESAR_B2)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B1;
   CAESAR_TYPE_POINTER CAESAR_B2;
   { ... }

</PRE>This function returns an integer number which is smaller than, equal to,
or greater than 0 depending whether the item pointed to by <CODE>CAESAR_B1</CODE> is
smaller than, equal to, or greater than the item pointed to by <CODE>CAESAR_B2</CODE>
according to the order relation underlying the ``least frequently used, then
least recently put'' (LFU_LRP) replacement strategy. <P>
According to this order
relation: 
<UL>
<LI type=disc>an item is smaller than another item if the number of hits at
the first item is smaller than the number of hits at the second one, or
the number of hits is the same for both items but the date when the first
item was put into the cache is smaller than the date when the second one
was put into the cache; </LI><P><LI type=disc>an item is equal to another one if the number of
hits and the date when they were put into the cache are the same for both
items; </LI><P><LI type=disc>an item is greater than another item if the number of hits at the
first item is greater than the number of hits at the second one, or the
number of hits is the same for both items but the date when the first item
was put into the cache is greater than the date when the second one was
put into the cache. </LI><P>
</UL>
<P>
In other words, the LFU_LRP replacement strategy consists
in applying first the LFU, then the LRP replacement strategies. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect21" HREF="#sect21"><CODE>CAESAR_LFU_MRP_ORDER_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INTEGER CAESAR_LFU_MRP_ORDER_CACHE_1 (CAESAR_C, CAESAR_B1,
CAESAR_B2)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B1;
   CAESAR_TYPE_POINTER CAESAR_B2;
   { ... }

</PRE>This function returns an integer number which is smaller than, equal to,
or greater than 0 depending whether the item pointed to by <CODE>CAESAR_B1</CODE> is
smaller than, equal to, or greater than the item pointed to by <CODE>CAESAR_B2</CODE>
according to the order relation underlying the ``least frequently used, then
most recently put'' (LFU_MRP) replacement strategy. <P>
According to this order
relation: 
<UL>
<LI type=disc>an item is smaller than another item if the number of hits at
the first item is smaller than the number of hits at the second one, or
the number of hits is the same for both items but the date when the first
item was put into the cache is greater than the date when the second one
was put into the cache; </LI><P><LI type=disc>an item is equal to another one if the number of
hits and the date when they were put into the cache are the same for both
items; </LI><P><LI type=disc>an item is greater than another item if the number of hits at the
first item is greater than the number of hits at the second one, or the
number of hits is the same for both items but the date when the first item
was put into the cache is smaller than the date when the second one was
put into the cache. </LI><P>
</UL>
<P>
In other words, the LFU_MRP replacement strategy consists
in applying first the LFU, then the MRP replacement strategies. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect22" HREF="#sect22"><CODE>CAESAR_MFU_LRU_ORDER_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INTEGER CAESAR_MFU_LRU_ORDER_CACHE_1 (CAESAR_C, CAESAR_B1,
CAESAR_B2)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B1;
   CAESAR_TYPE_POINTER CAESAR_B2;
   { ... }

</PRE>This function returns an integer number which is smaller than, equal to,
or greater than 0 depending whether the item pointed to by <CODE>CAESAR_B1</CODE> is
smaller than, equal to, or greater than the item pointed to by <CODE>CAESAR_B2</CODE>
according to the order relation underlying the ``most frequently used, then
least recently used'' (MFU_LRU) replacement strategy. <P>
According to this order
relation: 
<UL>
<LI type=disc>an item is smaller than another item if the number of hits at
the first item is greater than the number of hits at the second one, or
the number of hits is the same for both items but the date of the last
access to the first item is smaller than the date of the last access to
the second one; </LI><P><LI type=disc>an item is equal to another one if the number of hits and
the date of the last access are the same for both items; </LI><P><LI type=disc>an item is greater
than another item if the number of hits at the first item is smaller than
the number of hits at the second one, or the number of hits is the same
for both items but the date of the last access to the first item is greater
than the date of the last access to the second one. </LI><P>
</UL>
<P>
In other words, the
MFU_LRU replacement strategy consists in applying first the MFU, then the
LRU replacement strategies. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect23" HREF="#sect23"><CODE>CAESAR_MFU_MRU_ORDER_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INTEGER CAESAR_MFU_MRU_ORDER_CACHE_1 (CAESAR_C, CAESAR_B1,
CAESAR_B2)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B1;
   CAESAR_TYPE_POINTER CAESAR_B2;
   { ... }

</PRE>This function returns an integer number which is smaller than, equal to,
or greater than 0 depending whether the item pointed to by <CODE>CAESAR_B1</CODE> is
smaller than, equal to, or greater than the item pointed to by <CODE>CAESAR_B2</CODE>
according to the order relation underlying the ``most frequently used, then
most recently used'' (MFU_MRU) replacement strategy. <P>
According to this order
relation: 
<UL>
<LI type=disc>an item is smaller than another item if the number of hits at
the first item is greater than the number of hits at the second one, or
the number of hits is the same for both items but the date of the last
access to the first item is greater than the date of the last access to
the second one; </LI><P><LI type=disc>an item is equal to another one if the number of hits and
the date of the last access are the same for both items; </LI><P><LI type=disc>an item is greater
than another item if the number of hits at the first item is smaller than
the number of hits at the second one, or the number of hits is the same
for both items but the date of the last access to the first item is smaller
than the date of the last access to the second one. </LI><P>
</UL>
<P>
In other words, the
MFU_MRU replacement strategy consists in applying first the MFU, then the
MRU replacement strategies. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect24" HREF="#sect24"><CODE>CAESAR_MFU_LRP_ORDER_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INTEGER CAESAR_MFU_LRP_ORDER_CACHE_1 (CAESAR_C, CAESAR_B1,
CAESAR_B2)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B1;
   CAESAR_TYPE_POINTER CAESAR_B2;
   { ... }

</PRE>This function returns an integer number which is smaller than, equal to,
or greater than 0 depending whether the item pointed to by <CODE>CAESAR_B1</CODE> is
smaller than, equal to, or greater than the item pointed to by <CODE>CAESAR_B2</CODE>
according to the order relation underlying the ``most frequently used, then
least recently put'' (MFU_LRP) replacement strategy. <P>
According to this order
relation: 
<UL>
<LI type=disc>an item is smaller than another item if the number of hits at
the first item is greater than the number of hits at the second one, or
the number of hits is the same for both items but the date when the first
item was put into the cache is smaller than the date when the second one
was put into the cache; </LI><P><LI type=disc>an item is equal to another one if the number of
hits and the date when they were put into the cache are the same for both
items; </LI><P><LI type=disc>an item is greater than another item if the number of hits at the
first item is smaller than the number of hits at the second one, or the
number of hits is the same for both items but the date when the first item
was put into the cache is greater than the date when the second one was
put into the cache. </LI><P>
</UL>
<P>
In other words, the MFU_LRP replacement strategy consists
in applying first the MFU, then the LRP replacement strategies. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect25" HREF="#sect25"><CODE>CAESAR_MFU_MRP_ORDER_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_INTEGER CAESAR_MFU_MRP_ORDER_CACHE_1 (CAESAR_C, CAESAR_B1,
CAESAR_B2)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B1;
   CAESAR_TYPE_POINTER CAESAR_B2;
   { ... }

</PRE>This function returns an integer number which is smaller than, equal to,
or greater than 0 depending whether the item pointed to by <CODE>CAESAR_B1</CODE> is
smaller than, equal to, or greater than the item pointed to by <CODE>CAESAR_B2</CODE>
according to the order relation underlying the ``most frequently used, then
most recently put'' (MFU_MRP) replacement strategy. <P>
According to this order
relation: 
<UL>
<LI type=disc>an item is smaller than another item if the number of hits at
the first item is greater than the number of hits at the second one, or
the number of hits is the same for both items but the date when the first
item was put into the cache is greater than the date when the second one
was put into the cache; </LI><P><LI type=disc>an item is equal to another one if the number of
hits and the date when they were put into the cache are the same for both
items; </LI><P><LI type=disc>an item is greater than another item if the number of hits at the
first item is smaller than the number of hits at the second one, or the
number of hits is the same for both items but the date when the first item
was put into the cache is smaller than the date when the second one was
put into the cache. </LI><P>
</UL>
<P>
In other words, the MFU_MRP replacement strategy consists
in applying first the MFU, then the MRP replacement strategies. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect26" HREF="#sect26"><CODE>CAESAR_SEED_RND_CACHE_1</CODE></A></H3>
<PRE>void CAESAR_SEED_RND_CACHE_1 (CAESAR_C, CAESAR_SEED)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_NATURAL CAESAR_SEED;
   { ... }

</PRE>This procedure initializes the seed for the random number generator associated
to the cache pointed to by <CODE>CAESAR_C</CODE> with the value of <CODE>CAESAR_SEED</CODE>. The seed
is used for computing the random costs associated to the items contained
in the subcaches of the cache that are equipped with the RND replacement
strategy. <P>
Note: The value of the seed associated to a cache is set by default
to 0 when the cache is created by invoking the procedure <CODE>CAESAR_CREATE_CACHE_1()</CODE>
(see below). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect27" HREF="#sect27"><CODE>CAESAR_CREATE_CACHE_1</CODE></A></H3>
<PRE>void CAESAR_CREATE_CACHE_1 (CAESAR_C,
                            CAESAR_NUMBER_OF_SUBCACHES,
                            CAESAR_LIMIT_SIZE,
                            CAESAR_SUBCACHE_SIZE,
                            CAESAR_SUBCACHE_PERCENTAGE,
                            CAESAR_SUBCACHE_ORDER,
                            CAESAR_SUBCACHE_CHILD,
                            CAESAR_BASE_AREA,
                            CAESAR_MARK_AREA,
                            CAESAR_HASH_SIZE,
                            CAESAR_PRIME,
                            CAESAR_COMPARE,
                            CAESAR_HASH,
                            CAESAR_PRINT,
                            CAESAR_CLEANUP,
                            CAESAR_INFO)
   CAESAR_TYPE_CACHE_1 *CAESAR_C;
   CAESAR_TYPE_NATURAL CAESAR_NUMBER_OF_SUBCACHES;
   CAESAR_TYPE_NATURAL CAESAR_LIMIT_SIZE;
   CAESAR_TYPE_NATURAL_FUNCTION_CACHE_1 CAESAR_SUBCACHE_SIZE;
   CAESAR_TYPE_NATURAL_FUNCTION_CACHE_1 CAESAR_SUBCACHE_PERCENTAGE;
   CAESAR_TYPE_ORDER_FUNCTION_CACHE_1 (*CAESAR_SUBCACHE_ORDER)
      (CAESAR_TYPE_NATURAL);
   CAESAR_TYPE_SUBCACHE_FUNCTION_CACHE_1 (*CAESAR_SUBCACHE_CHILD)
      (CAESAR_TYPE_NATURAL);
   CAESAR_TYPE_AREA_1 CAESAR_BASE_AREA;
   CAESAR_TYPE_AREA_1 CAESAR_MARK_AREA;
   CAESAR_TYPE_NATURAL CAESAR_HASH_SIZE;
   CAESAR_PROMOTE_TO_INT (CAESAR_TYPE_BOOLEAN) CAESAR_PRIME;
   CAESAR_TYPE_COMPARE_FUNCTION CAESAR_COMPARE;
   CAESAR_TYPE_HASH_FUNCTION CAESAR_HASH;
   CAESAR_TYPE_PRINT_FUNCTION CAESAR_PRINT;
   CAESAR_TYPE_CLEANUP_FUNCTION_CACHE_1 CAESAR_CLEANUP;
   CAESAR_TYPE_POINTER CAESAR_INFO;
   { ... }

</PRE>This procedure allocates a cache using <CODE>CAESAR_CREATE()</CODE> and assigns its
address to <CODE>*CAESAR_C</CODE>. If the allocation fails, the <CODE>NULL</CODE> value is assigned
to <CODE>*CAESAR_C</CODE>. <P>
Note: Because <CODE>CAESAR_TYPE_CACHE_1</CODE> is a pointer type, any variable
<CODE>CAESAR_C</CODE> of type <CODE>CAESAR_TYPE_CACHE_1</CODE> must be allocated before used, for
instance using: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_CREATE_CACHE_1 (&amp;CAESAR_C, ...);</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
The value of <CODE>CAESAR_NUMBER_OF_SUBCACHES</CODE>
determines the number of subcaches contained in the cache. Each subcache
will be assigned an unique index in the range 0..<CODE>CAESAR_NUMBER_OF_SUBCACHES</CODE>
- 1. If the value of <CODE>CAESAR_NUMBER_OF_SUBCACHES</CODE> is zero or greater than P,
the effect is undefined. <P>
The value of <CODE>CAESAR_LIMIT_SIZE</CODE> determines the maximal
number of items that can be stored in the cache. It must be less or equal
to M. If it is equal to zero, it is replaced by the default value M. <P>
Note:
in order to spare memory, the value of <CODE>CAESAR_LIMIT_SIZE</CODE> (which is an upper
bound on the number of items to be inserted in the cache) should be as
small as possible. This can only be done if the user has some knowledge
about the way the cache will be used. <P>
The actual value of the formal parameter
<CODE>CAESAR_SUBCACHE_SIZE</CODE> will be stored and associated to the cache pointed
to by <CODE>*CAESAR_C</CODE>. It will be used to assign to each subcache its corresponding
size, i.e., the maximal number of items the subcache can contain. <P>
Precisely,
the actual value of <CODE>CAESAR_SUBCACHE_SIZE</CODE> should be a pointer to a function
with a parameter <CODE>caesar_index</CODE> that returns the size of the subcache of
index <CODE>caesar_index</CODE>, where <CODE>caesar_index</CODE> is in the range 0..<CODE>CAESAR_NUMBER_OF_SUBCACHES</CODE>
- 1. If the value returned by <CODE>CAESAR_SUBCACHE_SIZE</CODE> for some index <CODE>caesar_index</CODE>
is greater than zero, then the size of the subcache of index <CODE>caesar_index</CODE>
is set to this value. If the value returned is zero, the size of the subcache
of index <CODE>caesar_index</CODE> is unspecified and will be determined by the percentage
returned by the <CODE>CAESAR_SUBCACHE_PERCENTAGE</CODE> parameter (see below). The sum
of the sizes returned by <CODE>CAESAR_SUBCACHE_SIZE</CODE> for all subcaches, noted
L, must be less or equal to <CODE>CAESAR_LIMIT_SIZE</CODE>. <P>
The actual value of the formal
parameter <CODE>CAESAR_SUBCACHE_PERCENTAGE</CODE> will be stored and associated to the
cache pointed to by <CODE>*CAESAR_C</CODE>. It will be used to assign to each subcache
its corresponding percentage, i.e., a natural number in the range 0..100 determining
the size of the subcache with respect to the size of the other subcaches.
<P>
Precisely, the actual value of <CODE>CAESAR_SUBCACHE_PERCENTAGE</CODE> should be a pointer
to a function with a parameter <CODE>caesar_index</CODE> that returns the percentage
of the subcache of index <CODE>caesar_index</CODE>, where <CODE>caesar_index</CODE> is in the range
0..<CODE>CAESAR_NUMBER_OF_SUBCACHES</CODE> - 1. Several configurations are possible, enabling
the setup of subcache sizes in a flexible manner: 
<UL>
<LI type=disc>If the value returned
by <CODE>CAESAR_SUBCACHE_SIZE</CODE> is greater than zero for all subcaches, then the
values returned by <CODE>CAESAR_SUBCACHE_PERCENTAGE</CODE> are ignored because all subcache
sizes are determined by <CODE>CAESAR_SUBCACHE_SIZE</CODE>. </LI><P><LI type=disc>If there is some subcache
with unspecified size (i.e., for which <CODE>CAESAR_SUBCACHE_SIZE</CODE> returns zero),
then the size of the cache pointed to by <CODE>*CAESAR_C</CODE> is set to <CODE>CAESAR_LIMIT_SIZE</CODE>.
Let R be the number of subcaches with unspecified size. The sizes of these
subcaches are determined based on the percentages returned by <CODE>CAESAR_SUBCACHE_PERCENTAGE</CODE>.
Two situations are possible: <P>
(1) If the value returned by <CODE>CAESAR_SUBCACHE_PERCENTAGE</CODE>
is zero for all subcaches with unspecified size, then the size of each
of these subcaches is set to (<CODE>CAESAR_LIMIT_SIZE</CODE> - L) / R. <P>
(2) If there is
some cache with unspecified size for which the value returned by <CODE>CAESAR_SUBCACHE_PERCENTAGE</CODE>
is greater than zero, then the size of a subcache with percentage F is
set to (<CODE>CAESAR_LIMIT_SIZE</CODE> - L) * F / 100. All the percentages returned by
<CODE>CAESAR_SUBCACHE_PERCENTAGE</CODE> for the subcaches with unspecified size must
be greater than zero, and the sum of all these percentages must be equal
to 100. </LI><P>
</UL>
<P>
The actual value of the formal parameter <CODE>CAESAR_SUBCACHE_ORDER</CODE> will
be stored and associated to the cache pointed to by <CODE>*CAESAR_C</CODE>. It will be
used to assign to each subcache a function implementing the order relation
underlying the replacement strategy associated to the subcache. <P>
Precisely,
the actual value of <CODE>CAESAR_SUBCACHE_ORDER</CODE> should be a pointer to a function
with a parameter <CODE>caesar_index</CODE> that returns a function implementing an order
relation, where <CODE>caesar_index</CODE> is in the range 0..<CODE>CAESAR_NUMBER_OF_SUBCACHES</CODE>
- 1. The value returned by <CODE>CAESAR_SUBCACHE_ORDER</CODE> should be a pointer to a
function with three parameters <CODE>caesar_cache</CODE>, <CODE>caesar_base_1</CODE>, <CODE>caesar_base_2</CODE>.
This function returns a value smaller than, equal to, or greater than 0
if the base field pointed to by <CODE>caesar_base_1</CODE> is smaller than, equal to,
or greater than the base field pointed to by <CODE>caesar_base_2</CODE>. The items whose
base fields are pointed to by <CODE>caesar_base_1</CODE> and <CODE>caesar_base_2</CODE> are supposed
to be contained in the cache pointed to by <CODE>caesar_cache</CODE>, which is always
set to the value of <CODE>*CAESAR_C</CODE>, i.e., a pointer to the cache currently created.
Examples of functions that can be returned by <CODE>CAESAR_SUBCACHE_ORDER</CODE> are
those implementing the order relations underlying the predefined replacement
strategies, namely <CODE>CAESAR_LRU_ORDER_CACHE_1()</CODE>, <CODE>CAESAR_MRU_ORDER_CACHE_1()</CODE>,
etc. <P>
The actual value of the formal parameter <CODE>CAESAR_SUBCACHE_CHILD</CODE> will
be stored and associated to the cache pointed to by <CODE>*CAESAR_C</CODE>. It will be
used to assign to each subcache a function implementing the parent relation
that defines the child subcaches of that subcache. <P>
Precisely, the actual
value of <CODE>CAESAR_SUBCACHE_CHILD</CODE> should be a pointer to a function with a
parameter <CODE>caesar_index</CODE> that returns a function implementing a parent relation,
where <CODE>caesar_index</CODE> is in the range 0..<CODE>CAESAR_NUMBER_OF_SUBCACHES</CODE> - 1. The value
returned by <CODE>CAESAR_SUBCACHE_CHILD</CODE> should be a pointer to a function with
three parameters <CODE>caesar_cache</CODE>, <CODE>caesar_index</CODE>, <CODE>caesar_base</CODE>. The parameter
<CODE>caesar_cache</CODE> is always set to the value of <CODE>*CAESAR_C</CODE>, i.e., a pointer to
the cache currently created. The parameter <CODE>caesar_base</CODE> is a pointer to the
last item replaced in the subcache of index <CODE>caesar_index</CODE> when the current
put operation performed on the cache pointed to by <CODE>caesar_cache</CODE> entailed
a put operation on the subcache of index <CODE>caesar_index</CODE>, which was already
full. This function returns, for the subcache of index <CODE>caesar_index</CODE>, the
index of its child subcache in which the item pointed to by <CODE>caesar_base</CODE>
will be put. If the index returned by this function is greater or equal
to <CODE>CAESAR_NUMBER_OF_SUBCACHES</CODE>, then the subcache of index <CODE>caesar_index</CODE>
is considered to be a leaf subcache, and the last item replaced pointed
to by <CODE>caesar_base</CODE> will be temporarily stored in a field of the cache until
the next replacement takes place in the cache (see the <CODE>CAESAR_LAST_ITEM_REPLACED_CACHE_1()</CODE>
procedure below). <P>
For example, the following function implements a parent
relation corresponding to a stream of subcaches, i.e., a hierarchy in which
each subcache of index I has a single child subcache of index I+1: <PRE>   CAESAR_TYPE_NATURAL caesar_child (caesar_cache, caesar_index, caesar_base)
   CAESAR_TYPE_CACHE_1 caesar_cache;
   CAESAR_TYPE_NATURAL caesar_index;
   CAESAR_TYPE_POINTER caesar_base;
   {
      return (caesar_index + 1);
   }

</PRE>This function does not use the <CODE>caesar_cache</CODE> and the <CODE>caesar_base</CODE> parameters.
However, general user-defined functions can implement parent relations that
may change dynamically depending on the current status of the cache pointed
to by <CODE>caesar_cache</CODE>, the current status of its subcache of index <CODE>caesar_index</CODE>
and/or the contents of the item pointed to by <CODE>caesar_base</CODE>. <P>
The value of
<CODE>CAESAR_BASE_AREA</CODE> determines the (constant) size and (constant) alignment
factor of the base field in the cache. In the particular case where base
fields are used to store states (resp. labels, strings), one must give the
value <CODE>CAESAR_STATE_AREA_1()</CODE> (resp. <CODE>CAESAR_LABEL_AREA_1()</CODE>, <CODE>CAESAR_STRING_AREA_1()</CODE>)
to the formal parameter <CODE>CAESAR_BASE_AREA</CODE>. <P>
The value of <CODE>CAESAR_MARK_AREA</CODE>
determines the (constant) size and (constant) alignment factor of the mark
field according to the specifications of the ``area_1'' library. In particular,
if <CODE>CAESAR_MARK_AREA</CODE> is equal to <CODE>CAESAR_EMPTY_AREA_1()</CODE>, there will be no
mark field in the cache. <P>
Each item in the cache will be represented as a
byte string of fixed size <CODE>caesar_item_size</CODE>, such that <CODE>caesar_item_size</CODE>
is greater or equal to <CODE>caesar_base_size</CODE> + <CODE>caesar_mark_size</CODE>, where <CODE>caesar_base_size</CODE>
denotes the size (in bytes) of the base field (i.e., <CODE>CAESAR_SIZE_AREA_1 (CAESAR_BASE_AREA)</CODE>)
and where <CODE>caesar_mark_size</CODE> denotes the size (in bytes) of the mark field,
if any (i.e., <CODE>CAESAR_SIZE_AREA_1 (CAESAR_MARK_AREA)</CODE>). <P>
An item in the cache
contains not only the base field and the mark field, but also ``padding'' bytes
that may be inserted between the base and mark fields to ensure that these
fields are correctly aligned according to <CODE>CAESAR_ALIGNMENT_AREA_1 (CAESAR_BASE_AREA)</CODE>
and <CODE>CAESAR_ALIGNMENT_AREA_1 (CAESAR_MARK_AREA)</CODE>. <P>
The value of <CODE>CAESAR_HASH_SIZE</CODE>
determines the number of entries in the hash-table associated to the cache.
If it is equal to zero, it is replaced with a default value greater than
zero. <P>
If the value of <CODE>CAESAR_PRIME</CODE> is equal to <CODE>CAESAR_TRUE</CODE> and if the value
of <CODE>CAESAR_HASH_SIZE</CODE> is not a prime number, this value will be replaced
by the nearest smaller prime number (since some hash functions require
prime modulus). Otherwise, the value of <CODE>CAESAR_HASH_SIZE</CODE> will be kept unchanged.
<P>
The actual value of the formal parameter <CODE>CAESAR_COMPARE</CODE> will be stored
and associated to the cache pointed to by <CODE>*CAESAR_C</CODE>. It will be used as
a comparison function when it is necessary to decide whether two base fields
are equal or not. <P>
Precisely, the actual value of <CODE>CAESAR_COMPARE</CODE> should be
a pointer to a comparison function with two parameters <CODE>caesar_base_1</CODE> and
<CODE>caesar_base_2</CODE> that returns <CODE>CAESAR_TRUE</CODE> if the two base fields pointed to
by <CODE>caesar_base_1</CODE> and <CODE>caesar_base_2</CODE> are equal. <P>
If the actual value of the
formal parameter <CODE>CAESAR_COMPARE</CODE> is <CODE>NULL</CODE>, it is replaced by a pointer to
a default comparison function that depends on the value of <CODE>CAESAR_BASE_AREA</CODE>
and is determined according to the rules specified for function <CODE>CAESAR_USE_COMPARE_FUNCTION_AREA_1()</CODE>
of the ``area_1'' library. <P>
The actual value of the formal parameter <CODE>CAESAR_HASH</CODE>
will be stored and associated to the cache pointed to by <CODE>*CAESAR_C</CODE>. It will
be used as a hash-function when it is necessary to compute a hash-value for
searching or inserting an item in the cache. <P>
Precisely, the actual value
of <CODE>CAESAR_HASH</CODE> should be a pointer to a hash function with two parameters
<CODE>caesar_pointer</CODE> and <CODE>caesar_modulus</CODE> that returns a natural number in the
range 0..<CODE>caesar_modulus</CODE> - 1. <P>
If the actual value of the formal parameter <CODE>CAESAR_HASH</CODE>
is <CODE>NULL</CODE>, it is replaced by a pointer to a default hash function that depends
on the value of <CODE>CAESAR_BASE_AREA</CODE> and is determined according to the rules
specified for function <CODE>CAESAR_USE_HASH_FUNCTION_AREA_1()</CODE> of the ``area_1''
library. <P>
The actual value of the formal parameter <CODE>CAESAR_PRINT</CODE> will be stored
and associated to the cache pointed to by <CODE>*CAESAR_C</CODE>. It will be used subsequently
to print the items of this cache. <P>
Precisely, the actual value of <CODE>CAESAR_PRINT</CODE>
should be a pointer to a printing procedure with two parameters <CODE>caesar_file</CODE>
and <CODE>caesar_item</CODE> that prints to file <CODE>caesar_file</CODE> information about the contents
(base field and/or mark field, if any) of the item pointed to by <CODE>caesar_item</CODE>.
<P>
If the actual value of the formal parameter <CODE>CAESAR_PRINT</CODE> is <CODE>NULL</CODE>, it is
replaced by a pointer to a default procedure that prints the base field
and the mark field, if any. The printing procedure used for the base field
(respectively, the mark field) depends on the value of <CODE>CAESAR_BASE_AREA</CODE>
(resp. <CODE>CAESAR_MARK_AREA</CODE>) and is determined according to the rules specified
for function <CODE>CAESAR_USE_PRINT_FUNCTION_AREA_1()</CODE> of the ``area_1'' library. <P>
The
actual value of the formal parameter <CODE>CAESAR_CLEANUP</CODE> will be stored and
associated to the cache pointed to by <CODE>*CAESAR_C</CODE>. It will be used subsequently
to clean up the contents of the items deleted from this cache. <P>
Precisely,
the actual value of <CODE>CAESAR_CLEANUP</CODE> should be a pointer to a procedure with
one parameter <CODE>caesar_item</CODE> that cleans up the contents (base field and mark
field, if any) of the item pointed to by <CODE>caesar_item</CODE>. This cleanup operation
is useful if the base and/or the mark fields (if any) of items contain
pointers to dynamic data structures (e.g., lists, sets, etc.) that must be
freed when those items are deleted from the cache. For example, if the base
field is a list of edges of type <CODE>CAESAR_TYPE_EDGE</CODE> that must not be kept
in memory when items are deleted from the cache, a good candidate for the
<CODE>CAESAR_CLEANUP</CODE> parameter is the <CODE>CAESAR_DELETE_EDGE_LIST()</CODE> procedure of
the ``edge'' library, which deletes the list pointed to by the base field of
the item pointed to by <CODE>caesar_item</CODE>, and then sets this base field to <CODE>NULL</CODE>.
<P>
If the actual value of the formal parameter <CODE>CAESAR_CLEANUP</CODE> is <CODE>NULL</CODE>, there
will be no cleanup operation performed on the contents of the items when
these items are deleted from the cache. <P>
The actual value of the formal parameter
<CODE>CAESAR_INFO</CODE> will be stored and associated to the cache pointed to by <CODE>*CAESAR_C</CODE>.
This value should be a pointer to some data structure containing user-defined
information that will be associated to this cache. The value of this pointer
remains unchanged during the lifetime of the cache and can be inspected
using the <CODE>CAESAR_INFO_CACHE_1()</CODE> function (see below). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect28" HREF="#sect28"><CODE>CAESAR_CURRENT_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_CACHE_1 CAESAR_CURRENT_CACHE_1 ()
   { ... }

</PRE>This function returns a pointer to the cache which is currently in use.
It should be called only within the functions and procedures given as actual
values for the formal parameters <CODE>CAESAR_SUBCACHE_SIZE</CODE>, <CODE>CAESAR_SUBCACHE_PERCENTAGE</CODE>,
<CODE>CAESAR_COMPARE</CODE>, <CODE>CAESAR_HASH</CODE>, <CODE>CAESAR_PRINT</CODE>, and <CODE>CAESAR_CLEANUP</CODE> of procedure
<CODE>CAESAR_CREATE_CACHE_1()</CODE> (see above); in this case, the result is a pointer
to the cache created by the call to <CODE>CAESAR_CREATE_CACHE_1()</CODE>. If this function
is called anywhere else in the application program, the result is undefined.
<P>
Note: This function allows to identify the cache to which the items passed
as arguments to the six aforementioned functions and procedures belong,
and thus to handle these items accordingly (the size and the contents of
items belonging to different caches may differ). It is especially useful
when the number of caches is unknown statically (e.g., when new caches are
created dynamically during the execution of the application program). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect29" HREF="#sect29"><CODE>CAESAR_CURRENT_SUBCACHE_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_CURRENT_SUBCACHE_CACHE_1 ()
   { ... }

</PRE>This function returns the index of the subcache which is currently in use;
this subcache is in turn contained in the cache which is currently in use,
pointed to by the result of function <CODE>CAESAR_CURRENT_CACHE_1()</CODE> (see above).
It should be called only within the functions and procedures given as actual
values for the formal parameters <CODE>CAESAR_SUBCACHE_ORDER</CODE>, <CODE>CAESAR_COMPARE</CODE>,
<CODE>CAESAR_HASH</CODE>, <CODE>CAESAR_PRINT</CODE>, and <CODE>CAESAR_CLEANUP</CODE> of procedure <CODE>CAESAR_CREATE_CACHE_1()</CODE>
(see above); in this case, the result is the index of the subcache, i.e.,
a natural number in the range 0..N-1, where N is the number of subcaches in
the cache created by the call to <CODE>CAESAR_CREATE_CACHE_1()</CODE>. If this function
is called anywhere else in the application program, the result is undefined.
<P>
Note: This function allows to identify the subcache to which the items
passed as arguments to the five aforementioned functions and procedures
belong, and thus to handle these items accordingly. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect30" HREF="#sect30"><CODE>CAESAR_DELETE_CACHE_1</CODE></A></H3>
<PRE>void CAESAR_DELETE_CACHE_1 (CAESAR_C)
   CAESAR_TYPE_CACHE_1 *CAESAR_C;
   { ... }

</PRE>This procedure frees the memory space corresponding to the cache pointed
to by <CODE>*CAESAR_C</CODE> using <CODE>CAESAR_DELETE()</CODE>. All the items currently present in
the cache are freed by invoking first the cleanup function (if any) associated
to the cache, and then <CODE>CAESAR_DELETE()</CODE>. Afterwards, the <CODE>NULL</CODE> value is assigned
to <CODE>*CAESAR_C</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect31" HREF="#sect31"><CODE>CAESAR_PURGE_SUBCACHE_CACHE_1</CODE></A></H3>
<PRE>void CAESAR_PURGE_SUBCACHE_CACHE_1 (CAESAR_C, CAESAR_N)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_NATURAL CAESAR_N;
   { ... }

</PRE>This procedure reinitializes the information associated to the subcache
of index <CODE>CAESAR_N</CODE> of the cache pointed to by <CODE>CAESAR_C</CODE>. All the items currently
present in the subcache are freed by invoking first the cleanup function
(if any) associated to the cache, and then <CODE>CAESAR_DELETE()</CODE>. Afterwards,
the subcache is exactly in the same state as after the creation of the
cache using <CODE>CAESAR_CREATE_CACHE_1()</CODE>. <P>
If the subcache index <CODE>CAESAR_N</CODE> is outside
the range 0..N-1 (where N is the number of subcaches in the cache), the effect
is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect32" HREF="#sect32"><CODE>CAESAR_PURGE_CACHE_1</CODE></A></H3>
<PRE>void CAESAR_PURGE_CACHE_1 (CAESAR_C)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   { ... }

</PRE>This procedure reinitializes the information associated to the cache pointed
to by <CODE>CAESAR_C</CODE>. All the items currently present in the cache are freed by
invoking first the cleanup function (if any) associated to the cache, and
then <CODE>CAESAR_DELETE()</CODE>. Afterwards, the cache is exactly in the same state
as after its creation using <CODE>CAESAR_CREATE_CACHE_1()</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect33" HREF="#sect33"><CODE>CAESAR_SEARCH_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_SEARCH_CACHE_1 (CAESAR_C, CAESAR_B, CAESAR_N,
CAESAR_P)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B;
   CAESAR_TYPE_NATURAL *CAESAR_N;
   CAESAR_TYPE_POINTER *CAESAR_P;
   { ... }

</PRE>This function determines if there exists, in the cache pointed to by <CODE>CAESAR_C</CODE>,
an item whose base field is equal to the byte string pointed to by <CODE>CAESAR_B</CODE>.
Byte string comparisons are performed using the comparison function associated
to the cache. The search is done using the hash-function and hash-table associated
to the cache. <P>
If so, this function returns <CODE>CAESAR_TRUE</CODE>. In this case, the
index of the subcache containing the existing item and the address of the
item are respectively assigned to <CODE>*CAESAR_N</CODE> and <CODE>*CAESAR_P</CODE>. The number of
searches and hits at the cache and the current global date of the cache
are incremented. The number of hits at the subcache is incremented and the
current local date of the subcache is set to the current global date of
the cache. The number of hits at the item is also incremented and the date
of the last access to the item is set to the current global date of the
cache (the item becomes the most recently accessed item in the cache). <P>
If
not, this function returns <CODE>CAESAR_FALSE</CODE>. In this case, both variables <CODE>*CAESAR_N</CODE>
and <CODE>*CAESAR_P</CODE> are left unchanged. The number of searches in the cache is
incremented. The number of hits at the cache and the current global date
of the cache are left unchanged. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect34" HREF="#sect34"><CODE>CAESAR_PUT_BASE_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_POINTER CAESAR_PUT_BASE_CACHE_1 (CAESAR_C)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   { ... }

</PRE>This function returns a pointer to the base field of the next item to be
put into the cache pointed to by <CODE>CAESAR_C</CODE>. <P>
The base field pointed to by
the result of <CODE>CAESAR_PUT_BASE_CACHE_1()</CODE> is initially undefined and must
be assigned before calling some other functions of the ``cache_1'' library
(see below). <P>
 <HR><BR>
 
<H3><A NAME="sect35" HREF="#sect35"><CODE>CAESAR_PUT_MARK_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_POINTER CAESAR_PUT_MARK_CACHE_1 (CAESAR_C)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   { ... }

</PRE>This function returns a pointer to the mark field of the next item to be
put into the cache pointed to by <CODE>CAESAR_C</CODE>. If there are no mark fields in
the cache (due to the initialization parameters supplied to <CODE>CAESAR_CREATE_CACHE_1()</CODE>)
the result is undefined. <P>
The mark field pointed to by the result of <CODE>CAESAR_PUT_MARK_CACHE_1()</CODE>
is always initialized to a bit string of 0's. It can be either consulted
or modified. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect36" HREF="#sect36"><CODE>CAESAR_PUT_CACHE_1</CODE></A></H3>
<PRE>void CAESAR_PUT_CACHE_1 (CAESAR_C)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   { ... }

</PRE>This procedure puts into the cache pointed to by <CODE>CAESAR_C</CODE> the item whose
base field is pointed to by <CODE>CAESAR_PUT_BASE_CACHE_1 (CAESAR_C)</CODE> and whose
mark field (if any) is pointed to by <CODE>CAESAR_PUT_MARK_CACHE_1 (CAESAR_C)</CODE>.
<P>
The base field must have been assigned before this procedure is called.
<P>
This procedure also sets a field of type <CODE>CAESAR_TYPE_ERROR_CACHE_1</CODE> associated
to the cache, indicating whether the put operation was carried out successfully
or not; this field can be inspected using the function <CODE>CAESAR_STATUS_PUT_CACHE_1()</CODE>
(see below). <P>
The hash-table associated to the cache is updated to take into
account the new item. To compute the hash-value for the base field, the hash-function
associated to the cache is used. <P>
If the put operation causes another item
E contained in (some leaf subcache of) the cache to be replaced, this item
is stored temporarily in a field associated to the cache until a future
call to <CODE>CAESAR_PUT_CACHE_1()</CODE> or <CODE>CAESAR_SEARCH_AND_PUT_CACHE_1()</CODE> will cause
another replacement to take place. Meanwhile, the item E can be inspected
by using the <CODE>CAESAR_LAST_ITEM_REPLACED_CACHE_1()</CODE> procedure (see below).
When the next replacement takes place, if the item E has not been inspected
meanwhile by a call to <CODE>CAESAR_LAST_ITEM_REPLACED_CACHE_1()</CODE>, it will be
first cleaned up using the cleanup function (if any) associated to the
cache, and then freed using <CODE>CAESAR_DELETE()</CODE>; otherwise, the item E will
not be cleaned up (because it is the user's responsibility to manage the
memory possibly referenced in the contents of this item), but freed using
<CODE>CAESAR_DELETE()</CODE> only. <P>
Note: the cache is implemented in such a way that
if a memory shortage occurs during a put operation when the cache is not
already full, all the subcaches are considered to become full and their
associated replacement strategies start to be used. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect37" HREF="#sect37"><CODE>CAESAR_SEARCH_AND_PUT_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_SEARCH_AND_PUT_CACHE_1 (CAESAR_C, CAESAR_N,
CAESAR_P)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_NATURAL *CAESAR_N;
   CAESAR_TYPE_POINTER *CAESAR_P;
   { ... }

</PRE>This function is a combination of the function <CODE>CAESAR_SEARCH_CACHE_1()</CODE>
and the procedure <CODE>CAESAR_PUT_CACHE_1()</CODE> defined above. <P>
The base field pointed
to by <CODE>CAESAR_PUT_BASE_CACHE_1 (CAESAR_C)</CODE> must have been assigned before
this function is called. <P>
It first determines if there exists, in the cache
pointed to by <CODE>CAESAR_C</CODE>, an item whose base field is equal to the base field
of the item pointed to by <CODE>CAESAR_PUT_BASE_CACHE_1 (CAESAR_C)</CODE>. Byte string
comparisons are performed using the comparison function associated to the
cache. The search is done using the hash-function and hash-table associated
to the cache. <P>
If so, this function returns <CODE>CAESAR_TRUE</CODE>. In this case, the
index of the subcache containing the existing item and the address of the
item are respectively assigned to <CODE>*CAESAR_N</CODE> and <CODE>*CAESAR_P</CODE>. The number of
searches and hits at the cache and the current global date of the cache
are incremented. The number of hits at the subcache is incremented and the
current local date of the subcache is set to the current global date of
the cache. The number of hits at the item is also incremented and the date
of the last access to the item is set to the current global date of the
cache (the item becomes the most recently accessed item in the cache). The
field of type <CODE>CAESAR_TYPE_ERROR_CACHE_1</CODE> associated to the cache is set
to <CODE>CAESAR_NONE_CACHE_1</CODE>. <P>
If not, this function returns <CODE>CAESAR_FALSE</CODE>. In this
case, it puts into the cache pointed to by <CODE>CAESAR_C</CODE> the item whose base
field is pointed to by <CODE>CAESAR_PUT_BASE_CACHE_1 (CAESAR_C)</CODE> and whose mark
field (if any) is pointed to by <CODE>CAESAR_PUT_MARK_CACHE_1 (CAESAR_C)</CODE>. The
hash-table associated to the cache is updated to take into account the new
item. The number of searches in the cache and the current global date of
the cache are incremented. <P>
The field of type <CODE>CAESAR_TYPE_ERROR_CACHE_1</CODE> associated
to the cache is set to indicate whether the put operation was carried out
successfully or not. If the put operation succeeded, variable <CODE>*CAESAR_N</CODE>
is assigned the value 0 (since the item was put into the root subcache,
of index 0) and variable <CODE>*CAESAR_P</CODE> is assigned the address of the item,
which is now contained in the cache. If the put operation failed (because
a cycle was detected in the parent relation between subcaches), the variables
<CODE>*CAESAR_N</CODE> and <CODE>*CAESAR_P</CODE> are left unchanged. <P>
If the put operation causes
another item E contained in (some leaf subcache of) the cache to be replaced,
this item is stored temporarily in a field associated to the cache until
a future call to <CODE>CAESAR_PUT_CACHE_1()</CODE> or <CODE>CAESAR_SEARCH_AND_PUT_CACHE_1()</CODE>
will cause another replacement to take place. Meanwhile, the item E can
be inspected by using the <CODE>CAESAR_LAST_ITEM_REPLACED_CACHE_1()</CODE> procedure
(see below). When the next replacement takes place, if the item E has not
been inspected meanwhile by a call to <CODE>CAESAR_LAST_ITEM_REPLACED_CACHE_1()</CODE>,
it will be first cleaned up using the cleanup function (if any) associated
to the cache, and then freed using <CODE>CAESAR_DELETE()</CODE>; otherwise, the item
E will not be cleaned up (because it is the user's responsibility to manage
the memory possibly referenced in the contents of this item), but freed
using <CODE>CAESAR_DELETE()</CODE> only. <P>
Note: the cache is implemented in such a way
that if a memory shortage occurs during a put operation when the cache
is not already full, all the subcaches are considered to become full and
their associated replacement strategies start to be used. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect38" HREF="#sect38"><CODE>CAESAR_STATUS_PUT_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_ERROR_CACHE_1 CAESAR_STATUS_PUT_CACHE_1 (CAESAR_C)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   { ... }

</PRE>This function returns the status of the last put operation performed by
a call to the procedure <CODE>CAESAR_PUT_CACHE_1()</CODE> or to the function <CODE>CAESAR_SEARCH_AND_PUT_CACHE_1()</CODE>
(see above) on the cache pointed to by <CODE>CAESAR_C</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect39" HREF="#sect39"><CODE>CAESAR_MINIMAL_ITEM_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_POINTER CAESAR_MINIMAL_ITEM_CACHE_1 (CAESAR_C, CAESAR_N)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_NATURAL CAESAR_N;
   { ... }

</PRE>This function returns the address of the smallest item contained in the
subcache of index <CODE>CAESAR_N</CODE> of the cache pointed to by <CODE>CAESAR_C</CODE>. The smallest
item is determined according to the order relation underlying the replacement
strategy of the subcache of index <CODE>CAESAR_N</CODE>. <P>
If the index <CODE>CAESAR_N</CODE> is outside
the range 0..N-1 (where N is the number of subcaches in the cache) or the
subcache of index <CODE>CAESAR_N</CODE> is empty, the result is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect40" HREF="#sect40"><CODE>CAESAR_DELETE_ITEM_CACHE_1</CODE></A></H3>
<PRE>void CAESAR_DELETE_ITEM_CACHE_1 (CAESAR_C, CAESAR_N, CAESAR_B)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_NATURAL CAESAR_N;
   CAESAR_TYPE_POINTER *CAESAR_B;
   { ... }

</PRE>This procedure deletes, for the subcache of index <CODE>CAESAR_N</CODE> of the cache
pointed to by <CODE>CAESAR_C</CODE>, the item whose base field is pointed to by <CODE>*CAESAR_B</CODE>.
The item is freed by invoking first the cleanup function (if any) associated
to the cache, and then <CODE>CAESAR_DELETE()</CODE>. Afterwards, the <CODE>NULL</CODE> value is assigned
to <CODE>*CAESAR_B</CODE>. <P>
The number of items in the subcache of index <CODE>CAESAR_N</CODE> and
in the cache is decremented. The current global date of the cache is incremented
and the current local date of the subcache of index <CODE>CAESAR_N</CODE> is set to
the current global date of the cache. <P>
If no item stored in the subcache
of index <CODE>CAESAR_N</CODE> of the cache has a base field at address <CODE>CAESAR_B</CODE>, the
effect is undefined. <P>
If the index <CODE>CAESAR_N</CODE> is outside the range 0..N-1 (where
N is the number of subcaches in the cache) or the subcache of index <CODE>CAESAR_N</CODE>
is empty, the effect is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect41" HREF="#sect41"><CODE>CAESAR_LAST_ITEM_REPLACED_CACHE_1</CODE></A></H3>
<PRE>void CAESAR_LAST_ITEM_REPLACED_CACHE_1 (CAESAR_C, CAESAR_N, CAESAR_B)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_NATURAL *CAESAR_N;
   CAESAR_TYPE_POINTER *CAESAR_B;
   { ... }

</PRE>This procedure respectively assigns to the variables <CODE>*CAESAR_N</CODE> and <CODE>*CAESAR_B</CODE>
the index of the subcache and the address of the item that was replaced
in that subcache when the last call to <CODE>CAESAR_PUT_CACHE_1()</CODE> or to <CODE>CAESAR_SEARCH_AND_PUT_CACHE_1()</CODE>
was performed on the cache pointed to by <CODE>CAESAR_C</CODE> and caused a replacement
to take place. <P>
This procedure also sets an internal field of the cache indicating
that the last item replaced was inspected, and from now on it is the user's
responsibility to manage the memory possibly referenced in the contents
of the item pointed to by <CODE>*CAESAR_B</CODE>. Thus, when some future call to <CODE>CAESAR_PUT_CACHE_1()</CODE>
or to <CODE>CAESAR_SEARCH_AND_PUT_CACHE_1()</CODE> on the cache will cause another item
to be replaced, the item pointed to by <CODE>*CAESAR_B</CODE> will not be cleaned up
by invoking the cleanup function (if any) associated to the cache, but
its contents will be freed by invoking <CODE>CAESAR_DELETE()</CODE> only. <P>
If none of
the previous calls to <CODE>CAESAR_PUT_CACHE_1()</CODE> or to <CODE>CAESAR_SEARCH_AND_PUT_CACHE_1()</CODE>
caused a replacement to take place, then the values N (where N is the number
of subcaches in the cache) and <CODE>NULL</CODE> are respectively assigned to the variables
<CODE>*CAESAR_N</CODE> and <CODE>*CAESAR_B</CODE>. <P>
Note: The item pointed to by <CODE>*CAESAR_B</CODE> can be handled
in the same way as an ordinary item present in the cache, e.g., the address
of its mark field can be retrieved using the <CODE>CAESAR_RETRIEVE_B_M_CACHE_1()</CODE>
procedure. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect42" HREF="#sect42"><CODE>CAESAR_UPDATE_CACHE_1</CODE></A></H3>
<PRE>void CAESAR_UPDATE_CACHE_1 (CAESAR_C, CAESAR_N, CAESAR_B)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_NATURAL CAESAR_N;
   CAESAR_TYPE_POINTER CAESAR_B;
   { ... }

</PRE>This procedure simulates, for the subcache of index <CODE>CAESAR_N</CODE> of the cache
pointed to by <CODE>CAESAR_C</CODE>, a hit at the item whose base field is pointed to
by <CODE>CAESAR_B</CODE>. <P>
The current global date of the cache is incremented and the
current local date of the subcache of index <CODE>CAESAR_N</CODE> is set to the current
global date of the cache. The date of the last access to the item pointed
to by <CODE>CAESAR_B</CODE> is set to the current global date of the cache (the item
becomes the most recently accessed item in the cache). The number of hits
at the item is incremented. Finally, the subcache is updated depending whether
the item has become smaller or greater according to the order relation
underlying the replacement strategy associated to the subcache. <P>
If no item
stored in the subcache of index <CODE>CAESAR_N</CODE> of the cache has a base field
at address <CODE>CAESAR_B</CODE>, the effect is undefined. <P>
If the subcache index <CODE>CAESAR_N</CODE>
is outside the range 0..N-1 (where N is the number of subcaches in the cache),
the effect is undefined. <P>
Note: If the items of the cache contain mark fields,
and if the subcache is equipped with a user-defined replacement strategy
whose underlying order relation depends on the contents of mark fields,
this procedure should be called after any modification of the mark field
of an item of the subcache in order to bring the subcache to a consistent
state. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect43" HREF="#sect43"><CODE>CAESAR_CURRENT_DATE_SUBCACHE_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_CURRENT_DATE_SUBCACHE_CACHE_1 (CAESAR_C, CAESAR_N)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_NATURAL CAESAR_N;
   { ... }

</PRE>This function returns the date of the last modifying operation performed
on an item present in the subcache of index <CODE>CAESAR_N</CODE> of the cache pointed
to by <CODE>CAESAR_C</CODE>. <P>
If the subcache index <CODE>CAESAR_N</CODE> is outside the range 0..N-1
(where N is the number of subcaches in the cache), the result is undefined.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect44" HREF="#sect44"><CODE>CAESAR_CURRENT_DATE_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_CURRENT_DATE_CACHE_1 (CAESAR_C)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   { ... }

</PRE>This function returns the current global date of the cache pointed to by
<CODE>CAESAR_C</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect45" HREF="#sect45"><CODE>CAESAR_NUMBER_OF_ITEMS_SUBCACHE_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_NUMBER_OF_ITEMS_SUBCACHE_CACHE_1 (CAESAR_C,
CAESAR_N)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_NATURAL CAESAR_N;
   { ... }

</PRE>This function returns the number of items currently contained in the subcache
of index <CODE>CAESAR_N</CODE> of the cache pointed to by <CODE>CAESAR_C</CODE>. <P>
If the subcache index
<CODE>CAESAR_N</CODE> is outside the range 0..N-1 (where N is the number of subcaches in
the cache), the result is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect46" HREF="#sect46"><CODE>CAESAR_NUMBER_OF_ITEMS_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_NUMBER_OF_ITEMS_CACHE_1 (CAESAR_C)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   { ... }

</PRE>This function returns the number of items currently contained in the cache
pointed to by <CODE>CAESAR_C</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect47" HREF="#sect47"><CODE>CAESAR_NUMBER_OF_SEARCHES_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_NUMBER_OF_SEARCHES_CACHE_1 (CAESAR_C)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   { ... }

</PRE>This function returns the number of search operations performed on the
cache pointed to by <CODE>CAESAR_C</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect48" HREF="#sect48"><CODE>CAESAR_NUMBER_OF_HITS_SUBCACHE_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_NUMBER_OF_HITS_SUBCACHE_CACHE_1 (CAESAR_C, CAESAR_N)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_NATURAL CAESAR_N;
   { ... }

</PRE>This function returns the number of hits at the subcache of index <CODE>CAESAR_N</CODE>
of the cache pointed to by <CODE>CAESAR_C</CODE>. <P>
If the subcache index <CODE>CAESAR_N</CODE> is outside
the range 0..N-1 (where N is the number of subcaches in the cache), the result
is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect49" HREF="#sect49"><CODE>CAESAR_NUMBER_OF_HITS_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_NUMBER_OF_HITS_CACHE_1 (CAESAR_C)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   { ... }

</PRE>This function returns the number of hits at the cache pointed to by <CODE>CAESAR_C</CODE>.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect50" HREF="#sect50"><CODE>CAESAR_ITEM_PUT_DATE_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_ITEM_PUT_DATE_CACHE_1 (CAESAR_C, CAESAR_B)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B;
   { ... }

</PRE>This function returns the date when the item whose base field is pointed
to by <CODE>CAESAR_B</CODE> was put into the cache pointed to by <CODE>CAESAR_C</CODE>. <P>
If no item
stored in (some subcache of) the cache has a base field at address <CODE>CAESAR_B</CODE>,
the result is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect51" HREF="#sect51"><CODE>CAESAR_ITEM_CURRENT_DATE_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_ITEM_CURRENT_DATE_CACHE_1 (CAESAR_C, CAESAR_B)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B;
   { ... }

</PRE>This function returns, for the cache pointed to by <CODE>CAESAR_C</CODE>, the date of
the last access to the item whose base field is pointed to by <CODE>CAESAR_B</CODE>.
<P>
If no item stored in (some subcache of) the cache has a base field at address
<CODE>CAESAR_B</CODE>, the result is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect52" HREF="#sect52"><CODE>CAESAR_ITEM_NUMBER_OF_HITS_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_ITEM_NUMBER_OF_HITS_CACHE_1 (CAESAR_C, CAESAR_B)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B;
   { ... }

</PRE>This function returns, for the cache pointed to by <CODE>CAESAR_C</CODE>, the number
of hits at the item whose base field is pointed to by <CODE>CAESAR_B</CODE>. <P>
If no item
stored in (some subcache of) the cache has a base field at address <CODE>CAESAR_B</CODE>,
the result is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect53" HREF="#sect53"><CODE>CAESAR_EMPTY_SUBCACHE_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_EMPTY_SUBCACHE_CACHE_1 (CAESAR_C, CAESAR_N)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_NATURAL CAESAR_N;
   { ... }

</PRE>This function returns a value different from 0 if the subcache of index
<CODE>CAESAR_N</CODE> of the cache pointed to by <CODE>CAESAR_C</CODE> is empty, and 0 otherwise.
<CODE>CAESAR_EMPTY_SUBCACHE_CACHE_1 (CAESAR_C, CAESAR_N)</CODE> is always equivalent
to: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_NUMBER_OF_ITEMS_SUBCACHE_CACHE_1 (CAESAR_C, CAESAR_N) == 0</CODE>
</TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
If the subcache index <CODE>CAESAR_N</CODE> is outside the range 0..N-1 (where N is the
number of subcaches in the cache), the result is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect54" HREF="#sect54"><CODE>CAESAR_EMPTY_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_EMPTY_CACHE_1 (CAESAR_C)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   { ... }

</PRE>This function returns a value different from 0 if the cache pointed to
by <CODE>CAESAR_C</CODE> is empty, and 0 otherwise. <CODE>CAESAR_EMPTY_CACHE_1 (CAESAR_C)</CODE> is
always equivalent to: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_NUMBER_OF_ITEMS_CACHE_1 (CAESAR_C) == 0</CODE>
</TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER><P>
<P>
 <HR><BR>
 
<H3><A NAME="sect55" HREF="#sect55"><CODE>CAESAR_FULL_SUBCACHE_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_FULL_SUBCACHE_CACHE_1 (CAESAR_C, CAESAR_N)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_NATURAL CAESAR_N;
   { ... }

</PRE>This function returns a value different from 0 if the subcache of index
<CODE>CAESAR_N</CODE> of the cache pointed to by <CODE>CAESAR_C</CODE> is full, and 0 otherwise. <CODE>CAESAR_FULL_SUBCACHE_CACHE_1
(CAESAR_C, CAESAR_N)</CODE> is always equivalent to: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_NUMBER_OF_ITEMS_SUBCACHE_CACHE_1
(CAESAR_C, CAESAR_N) == $K$</CODE> </TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>where K denotes the maximum number of items
that the subcache can contain. <P>
If the subcache index <CODE>CAESAR_N</CODE> is outside
the range 0..N-1 (where N is the number of subcaches in the cache), the result
is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect56" HREF="#sect56"><CODE>CAESAR_FULL_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_BOOLEAN CAESAR_FULL_CACHE_1 (CAESAR_C)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   { ... }

</PRE>This function returns a value different from 0 if the cache pointed to
by <CODE>CAESAR_C</CODE> is full, and 0 otherwise. <CODE>CAESAR_FULL_CACHE_1 (CAESAR_C)</CODE> is
always equivalent to: <CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT> </TD></TR>
<TR><TD ALIGN=LEFT> <CODE>CAESAR_NUMBER_OF_ITEMS_CACHE_1 (CAESAR_C) == $K$</CODE>
</TD></TR>
<TR><TD ALIGN=LEFT> </TD></TR>
</TABLE>
</CENTER>where K denotes the maximum number of items that the cache can contain.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect57" HREF="#sect57"><CODE>CAESAR_INFO_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_POINTER CAESAR_INFO_CACHE_1 (CAESAR_C)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   { ... }

</PRE>This function returns the pointer to the user information associated to
the cache pointed to by <CODE>CAESAR_C</CODE> when this cache was created using <CODE>CAESAR_CREATE_CACHE_1()</CODE>.
Precisely, the result returned by this function is the value of the formal
parameter <CODE>CAESAR_INFO</CODE> supplied at the call to <CODE>CAESAR_CREATE_CACHE_1()</CODE>. <P>
<P>

<HR><BR>
 
<H3><A NAME="sect58" HREF="#sect58"><CODE>CAESAR_RETRIEVE_B_M_CACHE_1</CODE></A></H3>
<PRE>void CAESAR_RETRIEVE_B_M_CACHE_1 (CAESAR_C, CAESAR_B, CAESAR_M)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_B;
   CAESAR_TYPE_POINTER *CAESAR_M;
   { ... }

</PRE>This procedure computes, for the cache pointed to by <CODE>CAESAR_C</CODE>, the address
of the mark field of the item whose base field is pointed to by <CODE>CAESAR_B</CODE>.
This address is assigned to <CODE>*CAESAR_M</CODE>. <P>
If no item stored in (some subcache
of) the cache has a base field at address <CODE>CAESAR_B</CODE>, the effect is undefined.
<P>
If there are no mark fields in the cache (due to the initialization parameters
supplied to <CODE>CAESAR_CREATE_CACHE_1()</CODE>), the effect is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect59" HREF="#sect59"><CODE>CAESAR_RETRIEVE_M_B_CACHE_1</CODE></A></H3>
<PRE>void CAESAR_RETRIEVE_M_B_CACHE_1 (CAESAR_C, CAESAR_M, CAESAR_B)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_POINTER CAESAR_M;
   CAESAR_TYPE_POINTER *CAESAR_B;
   { ... }

</PRE>This procedure computes, for the cache pointed to by <CODE>CAESAR_C</CODE>, the address
of the base field of the item whose mark field is pointed to by <CODE>CAESAR_M</CODE>.
This address is assigned to <CODE>*CAESAR_B</CODE>. <P>
If no item stored in (some subcache
of) the cache has a mark field at address <CODE>CAESAR_M</CODE>, the effect is undefined.
<P>
If there are no mark fields in the cache (due to the initialization parameters
supplied to <CODE>CAESAR_CREATE_CACHE_1()</CODE>), the effect is undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect60" HREF="#sect60"><CODE>CAESAR_FORMAT_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_FORMAT_CACHE_1 (CAESAR_C, CAESAR_FORMAT)
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   CAESAR_TYPE_FORMAT CAESAR_FORMAT;
   { ... }

</PRE>This function allows to control the format under which the cache pointed
to by <CODE>CAESAR_C</CODE> will be printed by the procedure <CODE>CAESAR_PRINT_CACHE_1()</CODE>
(see below). Currently, the following formats are available: <P>

<UL>
<LI type=disc>With format
0, statistical information concerning the cache is displayed such as: the
number of items, the replacement strategy and the number of hits for each
subcache of the cache, the total number of searches and hits for the whole
cache, etc. </LI><P><LI type=disc>(no other format available yet) </LI><P>
</UL>
<P>
By default, the current format
of each cache is initialized to 0. <P>
When called with <CODE>CAESAR_FORMAT</CODE> between
0 and 0, this fonction sets the current format of <CODE>CAESAR_C</CODE> to <CODE>CAESAR_FORMAT</CODE>
and returns an undefined result. <P>
When called with another value of <CODE>CAESAR_FORMAT</CODE>,
this function does not modify the current format of <CODE>CAESAR_C</CODE> but returns
a result defined as follows. If <CODE>CAESAR_FORMAT</CODE> is equal to the constant <CODE>CAESAR_CURRENT_FORMAT</CODE>,
the result is the value of the current format of <CODE>CAESAR_C</CODE>. If <CODE>CAESAR_FORMAT</CODE>
is equal to the constant <CODE>CAESAR_MAXIMAL_FORMAT</CODE>, the result is the maximal
format value (i.e., 0). In all other cases, the effect of this function is
undefined. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect61" HREF="#sect61"><CODE>CAESAR_MAX_FORMAT_CACHE_1</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_MAX_FORMAT_CACHE_1 ()
   { ... }

</PRE>Caution! This function is deprecated. It should no longer be used, as it
might be removed from future versions of the <I>OPEN/CAESAR</I>. Use function <CODE>CAESAR_FORMAT_CACHE_1()</CODE>
instead, called with argument <CODE>CAESAR_MAXIMAL_FORMAT</CODE>. <P>
This function returns
the maximal format value available for printing caches. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect62" HREF="#sect62"><CODE>CAESAR_PRINT_CACHE_1</CODE></A></H3>
<PRE>void CAESAR_PRINT_CACHE_1 (CAESAR_FILE, CAESAR_C)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_CACHE_1 CAESAR_C;
   { ... }

</PRE>This procedure prints on file <CODE>CAESAR_FILE</CODE> an ASCII text containing various
informations about the cache pointed to by <CODE>CAESAR_C</CODE>. The nature of these
informations is determined by the current format of the cache pointed to
by <CODE>CAESAR_C</CODE>. <P>
Before this procedure is called, <CODE>CAESAR_FILE</CODE> must have been
properly opened, for instance using <CODE>fopen(3)</CODE>. <P>
<P>
 <HR><BR>
 
<H2><A NAME="sect63" HREF="#sect63">Author(s)</A></H2>
Radu Mateescu 
<H2><A NAME="sect64" HREF="#sect64">Files</A></H2>
 
<DL><DD><DL COMPACT>

<DT><B>$CADP/incl/caesar_graph.h</B> </DT>
<DD>interface of the
graph module </DD><P>

<DT><B>$CADP/incl/caesar_*.h</B> </DT>
<DD>interfaces of the storage module </DD><P>

<DT><B>$CADP/bin.`arch`/libcaesar.a</B>
</DT>
<DD>object code of the storage module </DD><P>

<DT><B>$CADP/src/open_caesar/*.c</B> </DT>
<DD>source code
of various exploration modules </DD><P>

<DT><B>$CADP/com/lotos.open</B> </DT>
<DD>shell script to run
OPEN/CAESAR  </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect65" HREF="#sect65">See Also</A></H2>
Reference Manuals of OPEN/CAESAR, CAESAR, and CAESAR.ADT,
<A HREF="lotos.open.html"><B>lotos.open</B></A>
, <A HREF="caesar.html"><B>caesar</B></A>
, <A HREF="caesar.adt.html"><B>caesar.adt</B></A>
 <P>
Additional information
is available from the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives
for installation are given in files <B>$CADP/INSTALLATION_*.</B> <P>
Recent changes
and improvements to this software are reported and commented in file <B>$CADP/HISTORY.</B>

<H2><A NAME="sect66" HREF="#sect66">Bugs</A></H2>
Known bugs are described in the Reference Manual of OPEN/CAESAR. Please
report new bugs to <A HREF="mailto:cadp@inria.fr?Subject=CADP-Bug-Report">cadp@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Purpose</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Usage</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Description</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Features</A></LI>
<UL>
<LI><A NAME="toc5" HREF="#sect5">CAESAR_TYPE_CACHE_1</A></LI>
<LI><A NAME="toc6" HREF="#sect6">CAESAR_TYPE_NATURAL_FUNCTION_CACHE_1</A></LI>
<LI><A NAME="toc7" HREF="#sect7">CAESAR_TYPE_ORDER_FUNCTION_CACHE_1</A></LI>
<LI><A NAME="toc8" HREF="#sect8">CAESAR_TYPE_SUBCACHE_FUNCTION_CACHE_1</A></LI>
<LI><A NAME="toc9" HREF="#sect9">CAESAR_TYPE_CLEANUP_FUNCTION_CACHE_1</A></LI>
<LI><A NAME="toc10" HREF="#sect10">CAESAR_TYPE_ERROR_CACHE_1</A></LI>
<LI><A NAME="toc11" HREF="#sect11">CAESAR_LRU_ORDER_CACHE_1</A></LI>
<LI><A NAME="toc12" HREF="#sect12">CAESAR_MRU_ORDER_CACHE_1</A></LI>
<LI><A NAME="toc13" HREF="#sect13">CAESAR_LRP_ORDER_CACHE_1</A></LI>
<LI><A NAME="toc14" HREF="#sect14">CAESAR_MRP_ORDER_CACHE_1</A></LI>
<LI><A NAME="toc15" HREF="#sect15">CAESAR_LFU_ORDER_CACHE_1</A></LI>
<LI><A NAME="toc16" HREF="#sect16">CAESAR_MFU_ORDER_CACHE_1</A></LI>
<LI><A NAME="toc17" HREF="#sect17">CAESAR_RND_ORDER_CACHE_1</A></LI>
<LI><A NAME="toc18" HREF="#sect18">CAESAR_LFU_LRU_ORDER_CACHE_1</A></LI>
<LI><A NAME="toc19" HREF="#sect19">CAESAR_LFU_MRU_ORDER_CACHE_1</A></LI>
<LI><A NAME="toc20" HREF="#sect20">CAESAR_LFU_LRP_ORDER_CACHE_1</A></LI>
<LI><A NAME="toc21" HREF="#sect21">CAESAR_LFU_MRP_ORDER_CACHE_1</A></LI>
<LI><A NAME="toc22" HREF="#sect22">CAESAR_MFU_LRU_ORDER_CACHE_1</A></LI>
<LI><A NAME="toc23" HREF="#sect23">CAESAR_MFU_MRU_ORDER_CACHE_1</A></LI>
<LI><A NAME="toc24" HREF="#sect24">CAESAR_MFU_LRP_ORDER_CACHE_1</A></LI>
<LI><A NAME="toc25" HREF="#sect25">CAESAR_MFU_MRP_ORDER_CACHE_1</A></LI>
<LI><A NAME="toc26" HREF="#sect26">CAESAR_SEED_RND_CACHE_1</A></LI>
<LI><A NAME="toc27" HREF="#sect27">CAESAR_CREATE_CACHE_1</A></LI>
<LI><A NAME="toc28" HREF="#sect28">CAESAR_CURRENT_CACHE_1</A></LI>
<LI><A NAME="toc29" HREF="#sect29">CAESAR_CURRENT_SUBCACHE_CACHE_1</A></LI>
<LI><A NAME="toc30" HREF="#sect30">CAESAR_DELETE_CACHE_1</A></LI>
<LI><A NAME="toc31" HREF="#sect31">CAESAR_PURGE_SUBCACHE_CACHE_1</A></LI>
<LI><A NAME="toc32" HREF="#sect32">CAESAR_PURGE_CACHE_1</A></LI>
<LI><A NAME="toc33" HREF="#sect33">CAESAR_SEARCH_CACHE_1</A></LI>
<LI><A NAME="toc34" HREF="#sect34">CAESAR_PUT_BASE_CACHE_1</A></LI>
<LI><A NAME="toc35" HREF="#sect35">CAESAR_PUT_MARK_CACHE_1</A></LI>
<LI><A NAME="toc36" HREF="#sect36">CAESAR_PUT_CACHE_1</A></LI>
<LI><A NAME="toc37" HREF="#sect37">CAESAR_SEARCH_AND_PUT_CACHE_1</A></LI>
<LI><A NAME="toc38" HREF="#sect38">CAESAR_STATUS_PUT_CACHE_1</A></LI>
<LI><A NAME="toc39" HREF="#sect39">CAESAR_MINIMAL_ITEM_CACHE_1</A></LI>
<LI><A NAME="toc40" HREF="#sect40">CAESAR_DELETE_ITEM_CACHE_1</A></LI>
<LI><A NAME="toc41" HREF="#sect41">CAESAR_LAST_ITEM_REPLACED_CACHE_1</A></LI>
<LI><A NAME="toc42" HREF="#sect42">CAESAR_UPDATE_CACHE_1</A></LI>
<LI><A NAME="toc43" HREF="#sect43">CAESAR_CURRENT_DATE_SUBCACHE_CACHE_1</A></LI>
<LI><A NAME="toc44" HREF="#sect44">CAESAR_CURRENT_DATE_CACHE_1</A></LI>
<LI><A NAME="toc45" HREF="#sect45">CAESAR_NUMBER_OF_ITEMS_SUBCACHE_CACHE_1</A></LI>
<LI><A NAME="toc46" HREF="#sect46">CAESAR_NUMBER_OF_ITEMS_CACHE_1</A></LI>
<LI><A NAME="toc47" HREF="#sect47">CAESAR_NUMBER_OF_SEARCHES_CACHE_1</A></LI>
<LI><A NAME="toc48" HREF="#sect48">CAESAR_NUMBER_OF_HITS_SUBCACHE_CACHE_1</A></LI>
<LI><A NAME="toc49" HREF="#sect49">CAESAR_NUMBER_OF_HITS_CACHE_1</A></LI>
<LI><A NAME="toc50" HREF="#sect50">CAESAR_ITEM_PUT_DATE_CACHE_1</A></LI>
<LI><A NAME="toc51" HREF="#sect51">CAESAR_ITEM_CURRENT_DATE_CACHE_1</A></LI>
<LI><A NAME="toc52" HREF="#sect52">CAESAR_ITEM_NUMBER_OF_HITS_CACHE_1</A></LI>
<LI><A NAME="toc53" HREF="#sect53">CAESAR_EMPTY_SUBCACHE_CACHE_1</A></LI>
<LI><A NAME="toc54" HREF="#sect54">CAESAR_EMPTY_CACHE_1</A></LI>
<LI><A NAME="toc55" HREF="#sect55">CAESAR_FULL_SUBCACHE_CACHE_1</A></LI>
<LI><A NAME="toc56" HREF="#sect56">CAESAR_FULL_CACHE_1</A></LI>
<LI><A NAME="toc57" HREF="#sect57">CAESAR_INFO_CACHE_1</A></LI>
<LI><A NAME="toc58" HREF="#sect58">CAESAR_RETRIEVE_B_M_CACHE_1</A></LI>
<LI><A NAME="toc59" HREF="#sect59">CAESAR_RETRIEVE_M_B_CACHE_1</A></LI>
<LI><A NAME="toc60" HREF="#sect60">CAESAR_FORMAT_CACHE_1</A></LI>
<LI><A NAME="toc61" HREF="#sect61">CAESAR_MAX_FORMAT_CACHE_1</A></LI>
<LI><A NAME="toc62" HREF="#sect62">CAESAR_PRINT_CACHE_1</A></LI>
</UL>
<LI><A NAME="toc63" HREF="#sect63">Author(s)</A></LI>
<LI><A NAME="toc64" HREF="#sect64">Files</A></LI>
<LI><A NAME="toc65" HREF="#sect65">See Also</A></LI>
<LI><A NAME="toc66" HREF="#sect66">Bugs</A></LI>
</UL>
</BODY></HTML>
