 <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>MCL4 manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
mcl, MCL - Model Checking Language version 4 (value-passing modal
mu-calculus) 
<H2><A NAME="sect1" HREF="#sect1">Description</A></H2>
This manual page presents the version 4 of <I>MCL</I> (<I>Model
Checking Language</I>), which is the temporal logic accepted as input by <A HREF="evaluator4.html"><B>evaluator4</B></A>
.
In the remainder of this page, "<I>MCL</I>" denotes version 4 of <I>MCL</I>; see <A HREF="mcl.html"><B>mcl</B></A>

for other versions of <I>MCL</I>. <P>
A description of <I>MCL</I> can be found in article
[MT08], which also describes the verification method implemented in version
4.0 of EVALUATOR. <P>
The <I>MCL</I> language attempts to make a compromise between
expressiveness, user-friendliness, and efficiency of model checking for
temporal properties involving data. <I>MCL</I> is based on the alternation-free
fragment of the modal mu-calculus [Koz83, EL86], to which it brings two
kinds of extensions: 
<UL>
<LI type=disc>Action predicates equipped with data variables and
expressions, modalities containing extended regular expressions over action
sequences, parameterized fixed point operators, and data-handling constructs
inspired from the RICO temporal logic [Gar89] and from programming languages.
</LI><P><LI type=disc>An infinite looping operator (of alternation depth two [EL86]) similar
to the one present in <I>PDL-delta</I> (Propositional Dynamic Logic with Looping)
[Str82], which enables the expression of fairness properties by characterizing
complex unfair cycles of transitions in the LTS. </LI><P>
</UL>
<P>
An overview of the <I>MCL</I>
language is presented below. The abstract syntax of each language construct
is defined by a BNF grammar and the semantics is described informally. In
the grammar, terminal symbols are written between double quotes. Optional
constructs are enclosed between square brackets. The axiom of the grammar
is the <I>F</I> symbol. <P>
The following convention is adopted for the lists of symbols
occurring in the grammar rules: the index <I>n</I> of the last symbol in the list
is always greater or equal to 0, meaning that if the index of the first
symbol is 0 (e.g., <I>E0</I>, ..., <I>En</I>), then the list must contain at least one symbol,
and if the index of the first symbol is 1 (e.g., <I>E1</I>, ..., <I>En</I>), then the list
may be empty. <P>
When referring to a certain construct of the grammar, the
term "enclosing formula" denotes the (action, regular, or state) formula
immediately surrounding that construct. <P>
  <PRE>                  +--------+------------------------+
                  | Symbol |      Description       |
       +----------+--------+------------------------+
       |          |   E    | expression             |
       |          |   P    | pattern                |
       |          |   O    | offer                  |
       | Non-     |   AP   | action pattern         |
       | terminal |   A    | action formula         |
       |          |   R    | regular formula        |
       |          |   F    | state formula          |
       +----------+--------+------------------------+
       |          |   K    | constant               |
       |          |   X    | data variable          |
       | Terminal |   Y    | propositional variable |
       |          |   H    | function or operator   |
       |          |   T    | type                   |
       +----------+--------+------------------------+
</PRE>  <P>
The formulas <I>A</I>, <I>R</I>, F are interpreted over an LTS <I>&lt;S, A, T, s0&gt;</I>, where:
<I>S</I> is the set of <I>states</I>, <I>A</I> is the set of <I>actions</I> (transition labels), <I>T</I>
is the <I>transition relation</I> (a subset of <I>S * A * S</I>), and <I>s0</I> is the <I>initial
state</I>. A transition <I>(s1, a, s2)</I> of <I>T</I>, also written <I>s1-a-&gt;s2</I>, indicates that
the system can move from state <I>s1</I> to state <I>s2</I> by performing action <I>a</I>. An
action <I>a</I> has the following structure: <P>
  <PRE>    G v1 ... vn
</PRE>  <P>
where <I>G</I> is the name of a gate (communication channel) and <I>v1</I>, ..., <I>vn</I> are
the values exchanged on <I>G</I> when the rendezvous underlying action <I>a</I> was executed.
In the case that there are no values exchanged, the action is simply a
gate name. There is an invisible action (named <I>i</I> in LOTOS and <I>tau</I> in other
process algebras). <P>
Note: Actions are also represented as character strings,
which is useful for expressing certain action predicates (see ACTION FORMULAS
below). The character string representation of actions depends on the language
from which the LTS <I>spec</I> is generated. For example, if the input is given
as a LOTOS program <I>spec</I>[<B>.lotos</B>], an action having the structure shown above
will be represented as the character string "<I>G</I> !<I>v1</I> ... !<I>vn</I>". 
<H2><A NAME="sect2" HREF="#sect2">Lexical Elements</A></H2>
<P>
Identifiers
are built from letters, digits, and underscores (beginning with a letter
or an underscore). <B>evaluator4</B> is case-sensitive, except for the identifiers
of predefined types and functions (see TYPES, FUNCTIONS AND CONSTANTS below).
Keywords must be written in lowercase. Comments are enclosed between '<CODE>(*</CODE>'
and '<CODE>*)</CODE>'. Nested comments are not allowed. The keywords of <I>MCL</I> are listed below.
<P>
<CENTER><TABLE BORDER=0>
<TR><TD ALIGN=LEFT><CODE>among</CODE></TD><TD ALIGN=LEFT><CODE>equ</CODE></TD><TD ALIGN=LEFT><CODE>in</CODE></TD><TD ALIGN=LEFT><CODE>repeat</CODE></TD></TR>
<TR><TD ALIGN=LEFT><CODE>and</CODE></TD><TD ALIGN=LEFT><CODE>exists</CODE></TD><TD ALIGN=LEFT><CODE>let</CODE></TD><TD ALIGN=LEFT><CODE>step</CODE></TD></TR>
<TR><TD ALIGN=LEFT><CODE>any</CODE></TD><TD ALIGN=LEFT><CODE>exit</CODE></TD><TD ALIGN=LEFT><CODE>loop</CODE></TD><TD ALIGN=LEFT><CODE>tau</CODE></TD></TR>
<TR><TD ALIGN=LEFT><CODE>case</CODE></TD><TD ALIGN=LEFT><CODE>export</CODE></TD><TD ALIGN=LEFT><CODE>mu</CODE></TD><TD ALIGN=LEFT><CODE>then</CODE></TD></TR>
<TR><TD ALIGN=LEFT><CODE>choice</CODE></TD><TD ALIGN=LEFT><CODE>false</CODE></TD><TD ALIGN=LEFT><CODE>nil</CODE></TD><TD ALIGN=LEFT><CODE>to</CODE></TD></TR>
<TR><TD ALIGN=LEFT><CODE>continue</CODE></TD><TD ALIGN=LEFT><CODE>for</CODE></TD><TD ALIGN=LEFT><CODE>not</CODE></TD><TD ALIGN=LEFT><CODE>true</CODE></TD></TR>
<TR><TD ALIGN=LEFT><CODE>do</CODE></TD><TD ALIGN=LEFT><CODE>forall</CODE></TD><TD ALIGN=LEFT><CODE>nu</CODE></TD><TD ALIGN=LEFT><CODE>until</CODE></TD></TR>
<TR><TD ALIGN=LEFT><CODE>else</CODE></TD><TD ALIGN=LEFT><CODE>from</CODE></TD><TD ALIGN=LEFT><CODE>of</CODE></TD><TD ALIGN=LEFT><CODE>where</CODE></TD></TR>
<TR><TD ALIGN=LEFT><CODE>elsif</CODE></TD><TD ALIGN=LEFT><CODE>if</CODE></TD><TD ALIGN=LEFT><CODE>on</CODE></TD><TD ALIGN=LEFT><CODE>while</CODE></TD></TR>
<TR><TD ALIGN=LEFT><CODE>end</CODE></TD><TD ALIGN=LEFT><CODE>implies</CODE></TD><TD ALIGN=LEFT><CODE>or</CODE></TD><TD ALIGN=LEFT><CODE>xor</CODE></TD></TR>
</TABLE>
</CENTER>
<H2><A NAME="sect3" HREF="#sect3">Types,
Functions and Constants</A></H2>
<I>MCL</I> is a strongly-typed language: every variable
used in an <I>MCL</I> formula must have a unique type, which is statically determined.
In its current version, the language does not provide a mechanism for type
or function definition. <I>MCL</I> predefines the usual types encountered in programming
languages (<CODE>bool</CODE>, <CODE>nat</CODE>, <CODE>natset</CODE>, <CODE>int</CODE>, <CODE>real</CODE>, <CODE>char</CODE>, <CODE>string</CODE>), equipped with the
standard functions and operators listed below. <P>
 <PRE>+--------------------------------+--------------------------+
|                Operator        |         Meaning          |
+--------------------------------+--------------------------+
| false, true : -&gt; bool          | boolean constants        |
| not : bool -&gt; bool             | negation                 |
| or, and, implies, equ, xor :   | binary boolean operators |
|     bool, bool -&gt; bool         |                          |
| &lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt; :          | comparison operators     |
|     bool, bool -&gt; bool         |                          |
+--------------------------------+--------------------------+
| succ : nat -&gt; nat              | successor                |
| - : nat -&gt; int                 | unary minus              |
| +, - : nat, nat -&gt; nat         | addition, subtraction    |
| *, / : nat, nat -&gt; nat         | multiplication, division |
| % : nat, nat -&gt; nat            | modulo                   |
| ^ : nat, nat -&gt; nat            | power                    |
| string : nat -&gt; string         | convert to string        |
| &lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt; :          | comparison operators     |
|     nat, nat -&gt; bool           |                          |
+--------------------------------+--------------------------+
| empty : -&gt; natset              | empty set                |
| insert : nat, natset -&gt; natset | element insertion        |
| remove : nat, natset -&gt; natset | element deletion         |
| isin : nat, natset -&gt; bool     | membership               |
| union, inter, diff :           | binary set operators     |
|     natset, natset -&gt; natset   |                          |
| &lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt; :          | comparison operators     |
|     natset, natset -&gt; bool     |                          |
+--------------------------------+--------------------------+
| succ : int -&gt; int              | successor                |
| abs : int -&gt; nat               | absolute value           |
| sign : int -&gt; int              | returns -1, 0, 1 if arg. |
|                                |     is &lt; 0, = 0, &gt; 0     |
| - : int -&gt; int                 | unary minus              |
| +, - : int, int -&gt; int         | addition, subtraction    |
| *, / : int, int -&gt; int         | multiplication, division |
| % : int, int -&gt; int            | modulo                   |
| ^ : int, nat -&gt; int            | power                    |
| string : int -&gt; string         | convert to string        |
| &lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt; :          | comparison operators     |
|     int, int -&gt; bool           |                          |
+--------------------------------+--------------------------+
| - : real -&gt; real               | unary minus              |
| +, - : real, real -&gt; real      | addition, subtraction    |
| *, / : real, real -&gt; real      | multiplication, division |
| ^ : real, real -&gt; real         | power                    |
| string : real -&gt; string        | convert to string        |
| &lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt; :          | comparison operators     |
|     real, real -&gt; bool         |                          |
+--------------------------------+--------------------------+
| tolower, toupper :             | convert letter to lower- |
|     char -&gt; char               |     or upper-case        |
| islower, isupper :             | test if lower- or upper- |
|     char -&gt; bool               |     case letter          |
| isalpha, isdigit, isalnum :    | test if letter, digit,   |
|     char -&gt; bool               |     letter or digit      |
| isxdigit :                     | test if hexadecimal      |
|     char -&gt; bool               |     digit                |
| string : char -&gt; string        | convert to string        |
| &lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt; :          | comparison operators     |
|     char, char -&gt; bool         |                          |
+--------------------------------+--------------------------+
| length : string -&gt; nat         | length (number of chars) |
| empty : string -&gt; bool         | test if empty string     |
| concat :                       | concatenation            |
|     string, string -&gt; string   |                          |
| index, rindex :                | index of the first/last  |
|     string, string -&gt; nat      |     occurrence of the    |
|                                |     2nd arg. in the 1st  |
| prefix, suffix :               | prefix/suffix of given   |
|     string, nat -&gt; string      |     length               |
| nth : string, nat -&gt; char      | nth character            |
| substr :                       | substring starting at an |
|     string, nat, nat -&gt; string |     index and having a   |
|                                |     given length         |
| &lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt; :          | comparison operators     |
|     string, string -&gt; bool     |                          |
+--------------------------------+--------------------------+
</PRE> <P>
The numerical, character, and string constants have a C-like syntax (e.g.,
<CODE>13</CODE>, <CODE>-1</CODE>, <CODE>1.618</CODE>, <CODE>'a'</CODE>, <CODE>'\007'</CODE>, <CODE>'\n'</CODE>, <CODE>"hello world\n"</CODE>). In order to allow implicit type
conversions, numerical constants are overloaded as follows: a constant
of type <CODE>nat</CODE> can also be of type <CODE>int</CODE> or <CODE>real</CODE>, and a constant of type <CODE>int</CODE>
can also be of type <CODE>real</CODE>. <P>
The names of the operators of type <CODE>bool</CODE> (constants,
negation, and binary operators) that coincide with the keywords operating
on formulas must be written in lowercase. <P>
The binary boolean operators,
binary set and membership operators, the arithmetic operators (of types
<CODE>nat</CODE>, <CODE>int</CODE>, and <CODE>real</CODE>), and all comparison operators must be written in infixed
form (e.g., <CODE>1 + 2</CODE>,  <CODE>X inter Y</CODE>, <CODE>1.0 &lt; 2.0</CODE>, etc.). All the other operators must
be written in prefixed form (e.g., <CODE>insert (0, empty)</CODE>, <CODE>concat ("a", "b")</CODE>,
etc.). <P>
The operands of the binary operators of type <CODE>bool</CODE> ("<CODE>or</CODE>", "<CODE>and</CODE>", "<CODE>implies</CODE>",
"<CODE>equ</CODE>", "<CODE>xor</CODE>") are evaluated from left to right in a lazy way, i.e., the right
operand is not evaluated if the value of the left operand can determine
the value of the whole expression. <P>
All the binary operators of the predefined
types shown above are left-associative. Unary operators have the highest
precedence, followed by binary operators. In the current version of the
tool all binary operators are considered to be of equal precedence; parentheses
must be used for imposing a desired parsing/evaluation order. 
<H2><A NAME="sect4" HREF="#sect4">Expressions</A></H2>
The
syntax of <I>MCL</I> expressions is defined by the following grammar: <P>
  <PRE>E<tt> </tt>&nbsp;<tt> </tt>&nbsp;::=  K
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   X
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   H E
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   E1 H E2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   H "(" E1"," ..."," En ")"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   E "of" T
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "(" E ")"
</PRE>  <P>
The semantics of <I>MCL</I> expressions is described informally below. The evaluation
of an expression <I>E</I> in a context assigning values to all data variables
occurring in <I>E</I> yields a unique value. <P>
<PRE>K
</PRE>
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is a literal constant of a predefined type (see TYPES, FUNCTIONS AND CONSTANTS
above). </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>X
</PRE>
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is a data variable (see DECLARATIONS below). </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>H E
</PRE>
<DL><DD><DL COMPACT>

<DT></DT>
<DD>denotes a call of the unary prefixed operator <I>H</I> on the argument <I>E</I>. The
argument must be of the same type as the formal parameter of <I>H</I>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>E1 H E2
</PRE>
<DL><DD><DL COMPACT>

<DT></DT>
<DD>denotes a call of the binary infixed operator <I>H</I> on the arguments <I>E1</I> and
<I>E2</I>. The arguments must be of the same types as the corresponding formal
parameters of <I>H</I>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>H "(" E1"," ..."," En ")"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>denotes a call of the function <I>F</I> on the arguments <I>E1</I>, ..., <I>En</I>. The arguments
must be compatible (in number and type) with the formal parameters of <I>H</I>.
</DD><P>
</DL></DD><P></DL>
<P>
  <PRE>E "of" T
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>specifies that expression <I>E</I> has type <I>T</I>. This mechanism makes it possible
to solve ambiguities that may be caused by the overloading of operators
and constants (see TYPES, FUNCTIONS AND CONSTANTS above). </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"(" E ")"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>has the same meaning as the expression <I>E</I>. Parentheses are useful for
imposing an evaluation order of subexpressions different from the order
given by the associativity and precedence of operators. For example, <CODE>x +
(y / 2)</CODE> is different from <CODE>x + y / 2</CODE>, which is evaluated by default as <CODE>(x
+ y) / 2</CODE> since all binary operators have the same precedence. </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect5" HREF="#sect5">Declarations</A></H2>
Similarly
to classical functional programming languages, <I>MCL</I> provides mechanisms
for declaring and initializing data variables. Declarations (without initialization)
have the following general form: <PRE>    x01 "," ... "," x0m0 ":" T0
    "," ... ","
    xn1 "," ... "," xnmn ":" Tn
</PRE>which declares the data variables <I>xi1</I>, ..., <I>ximi</I> of type <I>Ti</I> for each 0 &lt;= <I>i</I>
&lt;= <I>n</I>. This general form of declaration is equivalent to the simplified form
below, which will be used in the remainder of this manual page: <PRE>    x01 ":" T0 "," ... "," x0m0 ":" T0
    "," ... ","
    xn1 ":" Tn "," ... "," xnmn ":" Tn
</PRE>In the same way, declarations with initialization have the following general
form: <PRE>    x01 "," ... "," x0m0 ":" T0 ":=" E0
    "," ... ","
    xn1 "," ... "," xnmn ":" Tn ":=" En
</PRE>which declares the data variables <I>xi1</I>, ..., <I>ximi</I> of type <I>Ti</I> and initializes
them with the value of the expression <I>Ei</I> for each 0 &lt;= <I>i</I> &lt;= <I>n</I>. This general
form of declaration with initialization is equivalent to the simplified
form below, which will be used in the remainder of this manual page: <PRE>    x01 ":" T0 ":=" E0 "," ... "," x0m0 ":" T0 ":=" E0
    "," ... ","
    xn1 ":" Tn ":=" En "," ... "," xnmn ":" Tn ":=" En
</PRE>
<H2><A NAME="sect6" HREF="#sect6">Patterns</A></H2>
<I>MCL</I> allows the manipulation of data values by matching them against
patterns and storing them in data variables. The syntax of <I>MCL</I> patterns
is defined by the following grammar: <P>
  <PRE>P<tt> </tt>&nbsp;<tt> </tt>&nbsp;::=  "any"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   K
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   X ":" T
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   P "of" T
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   P1 "|" P2
</PRE>  <P>
The semantics of <I>MCL</I> patterns is described informally below. <P>
  <PRE>"any"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the "wildcard" pattern, which matches any value of any type. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>K
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the constant pattern, which matches a value identical to <I>K</I>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>X ":" T
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>matches any value of type <I>T</I> and stores it in variable <I>X</I>, which is exported
to (i.e., made visible in) the enclosing formula. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>P "of" T
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>removes ambiguities (caused, e.g., by overloaded functions) by imposing
that a value can be matched by <I>P</I> only if it is of type <I>T</I>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>P1 "|" P2
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>matches a value if either <I>P1</I> or <I>P2</I> matches it. The patterns <I>P1</I> and <I>P2</I>
must declare the same data variables, all of which are exported to the
enclosing formula. </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect7" HREF="#sect7">Offers</A></H2>
Expressions and patterns can be used in offers,
which enable one to match a given value against an expression or to extract
and store it in a variable. The syntax of <I>MCL</I> offers is defined by the following
grammar: <P>
  <PRE>O<tt> </tt>&nbsp;<tt> </tt>&nbsp;::=  "?" P
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "!" E
</PRE>  <P>
The semantics of <I>MCL</I> offers is described informally below. <P>
  <PRE>"?" P
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is a pattern offer, which matches a value iff the pattern <I>P</I> matches
that value. All variables declared in <I>P</I> are exported to the enclosing formula.
</DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"!" E
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is an expression offer, which matches a value iff the evaluation of
the expression <I>E</I> yields that value, which also means that <I>E</I> and that value
must be of the same type. <P>
Note: Pattern and expression offers involving
constants have the same semantics, e.g., <CODE>? 3.1416</CODE> is equivalent to <CODE>! 3.1416</CODE>.
</DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect8" HREF="#sect8">Action Patterns</A></H2>
An action pattern <I>AP</I> specifies that a certain action (transition
label) of the LTS matches a list of offers. The syntax of <I>MCL</I> action patterns
is defined by the following grammar: <P>
  <PRE>AP<tt> </tt>&nbsp;<tt> </tt>&nbsp;::=  "{" O0 ... On [ "where" E ] "}"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "{" O1 ... On "..." O'1 ... O'm [ "where" E ] "}"
</PRE>  <P>
Action patterns inspect the structure of actions <I>G</I> <I>v1</I> ... <I>vn</I> by matching
values <I>vi</I> against expression offers or extracting them using pattern offers.
The optional clause "<CODE>where</CODE>" defines a boolean expression <I>E</I> (a guard) that
must evaluate to true for the action pattern to match the action. All variables
declared by the offers of an action pattern are visible in the guard <I>E</I>
(if present) and are also exported to the enclosing formula. <P>
The gate name
<I>G</I> can be matched by the first offer of an action pattern in three different
ways: 
<UL>
<LI type=disc>As a character string constant, using an expression offer (e.g., <CODE>!"Send"</CODE>);
</LI><P><LI type=disc>As a gate identifier, using a particular form of expression offer without
the "<CODE>!</CODE>" mark (e.g., <CODE>Send</CODE>). This form of matching can be applied only when
the gate name has a syntax compatible with the syntax of <I>MCL</I> identifiers;
</LI><P><LI type=disc>As a character string value, using a pattern offer (e.g., <CODE>?gate:string</CODE>). </LI><P>
</UL>
<P>
The
semantics of <I>MCL</I> action patterns is described informally below. <P>
  <PRE>"{" O0 ... Om [ "where" E ] "}"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>matches an action <I>G</I> <I>v1</I> ... <I>vn</I> iff <I>m</I> = <I>n</I>, the offer <I>O0</I> matches <I>G</I>,  each
offer <I>Oi</I> (for <I>i</I> = 1..<I>n</I>) matches its corresponding value <I>vi</I>, and the expression
<I>E</I> (if present) evaluates to true in a context in which all variables declared
in the offers <I>O0</I>, ..., <I>Om</I> are replaced with the corresponding values. <P>
This
is the basic action pattern, in which all values present in the action
are explicitly matched by offers. The matching of the gate name <I>G</I> by the
offer <I>O0</I> can be done in one of the three ways indicated above. </DD><P>
</DL></DD><P></DL>
<P>
  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>The simplest
action pattern of this form consists of a gate name (e.g., <CODE>{ Send }</CODE>). For
conciseness, the curly braces can be omitted in this case: one can write
simply <CODE>Send</CODE> in order to match an action consisting only of a gate name
<CODE>Send</CODE>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"{" O1 ... Om "..." O'1 ... O'p [ "where" E ] "}"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>matches an action <I>G</I> <I>v1</I> ... <I>vn</I> iff <I>m+p</I> &lt;= <I>n</I>, the offer <I>O1</I> (if present, i.e.,
if <I>m</I> &gt; 0) matches <I>G</I>, each offer <I>Oi</I> (for <I>i</I> = 1..<I>m</I>) matches its corresponding
value <I>vi</I>, each offer <I>O'j</I> (for <I>j</I> = 1..<I>p</I>) matches its corresponding value <I>vn-(p-j)</I>,
and the expression <I>E</I> (if present) evaluates to true in a context in which
all variables declared in the offers <I>O1</I>, ..., <I>Om</I>, <I>O'1</I>, ..., <I>O'p</I> are replaced with
the corresponding values. <P>
This is a form of action pattern that enables
matching only the first <I>m</I> and the last <I>p</I> values contained in an action,
and skipping the other values (if any) in the middle. The matching of the
gate name <I>G</I> by the offer <I>O1</I> can be done in one of the three ways indicated
above. Either one, or both groups of offers <I>O1</I> ... <I>Om</I> and <I>O'1</I> ... <I>O'p</I> can be absent
(i.e., <I>m</I> = 0 or/and <I>p</I> = 0). The simplest action pattern of this form (which
is always matched by any action) is <CODE>{ ... }</CODE>. </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect9" HREF="#sect9">Action Formulas</A></H2>
An <I>action formula</I>
is a logical formula built from action predicates (which can be action
patterns, character strings, regular expressions over character strings,
and the "<CODE>tau</CODE>" constant operator) and boolean operators. The syntax of <I>MCL</I>
action formulas is defined by the following grammar: <P>
  <PRE>A<tt> </tt>&nbsp;<tt> </tt>&nbsp;::=  AP
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   action_string
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   action_regexp
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "tau"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "true"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "false"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "not" A
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   A1 "or" A2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   A1 "xor" A2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   A1 "and" A2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   A1 "implies" A2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   A1 "equ" A2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "(" A ")"
</PRE>  <P>
Syntactically, all binary operators on action formulas are left-associative.
The "<CODE>not</CODE>" operator has the highest precedence, followed by "<CODE>and</CODE>", followed
by "<CODE>or</CODE>" and "<CODE>xor</CODE>", followed by "<CODE>implies</CODE>", followed by "<CODE>equ</CODE>". <P>
An action formula
defines a predicate over the actions of the LTS. The semantics of <I>MCL</I> action
formulas is described informally below. <P>
  <PRE>AP
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>an action (transition label) of the LTS satisfies an action pattern
<I>AP</I> if the content of the action matches the pattern. In this case, all variables
declared by the offers of <I>AP</I> are initialized with the corresponding values
extracted from the action and are also exported to the enclosing formula.
</DD><P>
</DL></DD><P></DL>
<P>
  <PRE>action_string
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>an <I>action_string</I> is a sequence of 0 or more characters, enclosed between
double quotes ('<CODE>"</CODE>'), which denotes an action of the LTS. A string may contain
any character but '<CODE>\n</CODE>' (end-of-line). Double quotes are also allowed, if preceded
by a backslash ('<CODE>\</CODE>'). Strings can be concatenated using the binary operator
'<CODE>#</CODE>' according to the grammar below: <P>
  <PRE>action_string ::= "(any char but end-of-line)*"
        |   action_string1 "#" action_string2
</PRE>  <P>
An action of the LTS satisfies an <I>action_string</I> iff its string representation
is identical to the corresponding character string (obtained after concatenation
whenever needed). </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>action_regexp
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>an <I>action_regexp</I> is a UNIX regular expression (see the <A HREF="regexp.html"><B>regexp</B></A>

manual page for a detailed description of UNIX regular expressions), enclosed
between single quotes ('<CODE>'</CODE>'), which denotes a predicate on the actions of the
LTS. Regexps can be concatenated using the binary operator '<CODE>#</CODE>' according to
the grammar below. Strings can be concatenated to regexps, in which case
they are implicitly converted into regexps. <P>
  <PRE>action_regexp ::= 'UNIX_regular_expression'
        |   action_regexp1 "#" action_regexp2
        |   action_string1 "#" action_regexp2
        |   action_regexp1 "#" action_string2
</PRE>  <P>
An action of the LTS satisfies an <I>action_regexp</I> iff its string representation
matches the corresponding <I>UNIX_regular_expression</I> (obtained after concatenation
whenever needed). </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"tau"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>an action of the LTS satisfies this action formula iff it is the invisible
action. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"true"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>an action of the LTS always satisfies this formula. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"false"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>an action of the LTS never satisfies this formula. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"not" A
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>an action of the LTS satisfies this formula iff it does not satisfy
<I>A</I>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>A1 "or" A2
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>an action of the LTS satisfies this formula iff it satisfies <I>A1</I> or it
satisfies <I>A2</I>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>A1 "xor" A2
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>an action of the LTS satisfies this formula iff it satisfies exactly
one of <I>A1</I> and <I>A2</I>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>A1 "and" A2
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>an action of the LTS satisfies this formula iff it satisfies both <I>A1</I>
and <I>A2</I>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>A1 "implies" A2
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>an action of the LTS satisfies this formula iff it does not satisfy
<I>A1</I> or it satisfies <I>A2</I>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>A1 "equ" A2
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>an action of the LTS satisfies this formula iff either it satisfies
both <I>A1</I> and <I>A2</I>, or neither of them. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"(" A ")"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>an action of the LTS satisfies this formula iff it satisfies <I>A</I>. Parentheses
are useful for imposing an evaluation order of subformulas different from
the order given by the associativity and precedence of operators. </DD><P>
</DL></DD><P></DL>
<P>
If an
action pattern <I>AP</I> occurs as operand of a unary or binary boolean operator,
none of the data variables declared by the pattern offers of <I>AP</I> is exported
to the enclosing formula (e.g., action formula <CODE>not { Send ?msg:nat }</CODE> does
not export variable <I>msg</I> to the enclosing formula). In other words, only
the action formulas consisting of action patterns can export data variables
to the enclosing formula (see also REGULAR FORMULAS and the description
of modalities in STATE FORMULAS below). 
<H2><A NAME="sect10" HREF="#sect10">Regular Formulas</A></H2>
A <I>regular formula</I>
is a logical formula built from action formulas, traditional and extended
regular expression operators, and data-handling constructs inspired from
functional programming languages. The syntax of <I>MCL</I> regular formulas is
defined by the following grammar: <P>
  <PRE>R<tt> </tt>&nbsp;<tt> </tt>&nbsp;::=  A
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "nil"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   R1 "." R2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   R1 "|" R2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   R "*"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   R "+"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   R "?"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   R "{" E "}"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   R "{" E "..." "}"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   R "{" E "," "}"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   R "{" E1 "..." E2 "}"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   R "{" E1 "," E2 "}"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "let" X0 ":" T0 ":=" E0 "," ... "," Xn ":" Tn ":=" En "in"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         R
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "end" "let"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "if" F0 "then"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         R0
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     [ "elsif" F1 "then"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         R1
<tt> </tt>&nbsp;<tt> </tt>&nbsp;       ...
<tt> </tt>&nbsp;<tt> </tt>&nbsp;       "elsif" Fn "then"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         Rn
<tt> </tt>&nbsp;<tt> </tt>&nbsp;       "else"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         Rn+1 ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "end" "if"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "case" E "in"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         P0 [ "where" E0 ] "-&gt;" R0
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         ...
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "|" Pn [ "where" En ] "-&gt;" Rn
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "end" "case"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "choice" X0 ":" T0 [ "among" "{" E01 "..." E02 "}" ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;              "," ... ","
<tt> </tt>&nbsp;<tt> </tt>&nbsp;              Xn ":" Tn [ "among" "{" En1 "..." En2 "}" ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "in"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         R
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "end" "choice"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "while" F "do"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         R
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "end" "while"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "repeat"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         R
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "until" F "end" "repeat"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "for" X ":" T "from" E1 "to" E2 [ "step" E3 ] "do"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         R
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "end" "for"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "loop" [ "(" X0 ":" T0 ":=" E0 "," ... "," Xn ":" Tn ":=" En ")" ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;            [ ":" "(" X'0 ":" T'0 "," ... "," X'm ":" T'm ")" ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "in"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         R
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "end" "loop"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "continue" [ "(" E0 "," ..."," En ")" ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "exit" [ "(" E0 "," ... "," Em ")" ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "export" "(" X0 ":" T0 ":=" E0 "," ... "," Xn ":" Tn ":=" En ")"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "(" R ")"
</PRE>  <P>
Syntactically, all binary operators on regular formulas are left-associative.
The "<CODE>*</CODE>", "<CODE>+</CODE>", "<CODE>?</CODE>", and "<CODE>{</CODE> ... <CODE>}</CODE>" operators have the highest precedence, followed
by "<CODE>.</CODE>", followed by "<CODE>|</CODE>". <P>
A regular formula <I>R</I> denotes a sequence (represented
by the couple of its source and target states) of consecutive LTS transitions
such that the word obtained by concatenating the actions labeling them
belongs to the regular language defined by <I>R</I>. <P>
A transition sequence <I>weakly
satisfies</I> a regular formula <I>R</I> iff, by deleting some of its invisible transitions,
the resulting sub-sequence satisfies <I>R</I>. In other words, the transitions of
the sequence matched by the action predicates of <I>R</I> (which can denote either
visible or invisible actions) can be interspersed with sub-sequences of
0 or more invisible transitions. <P>
The semantics of <I>MCL</I> regular formulas is
described informally below. <P>
  <PRE>A
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the action regular formula, which denotes one-step transition sequences.
It is satisfied by a sequence of LTS transitions iff this sequence consists
of a single transition labeled by an action satisfying the action formula
<I>A</I>. <P>
All data variables exported by <I>A</I> are also exported to the enclosing formula.
</DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"nil"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the null regular formula, which denotes empty transition sequences.
It is satisfied by any sequence of LTS transitions that is empty, i.e., it
contains no transitions. An empty sequence has identical source and target
states. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>R1 "." R2
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the concatenation regular formula, which denotes the concatenation
of two transition sequences. It is satisfied by a sequence of LTS transitions
iff this sequence consists of a first sub-sequence concatenated with a second
one (the target state of the first sub-sequence being the source state of
the second one), the first sub-sequence satisfying <I>R1</I> and the second one
satisfying <I>R2</I>. <P>
All data variables exported by <I>R1</I> are visible in <I>R2</I>. For each
data variable <I>X</I> exported by both <I>R1</I> and <I>R2</I>, the occurrence of <I>X</I> exported
by <I>R2</I> is also exported to the enclosing formula (i.e., it overrides the occurrence
of <I>X</I> possibly exported by <I>R1</I>). All the other data variables (i.e., those exported
by <I>R1</I> only and by <I>R2</I> only) are also exported to the enclosing formula. </DD><P>
</DL></DD><P></DL>
<P>

 <PRE>R1 "|" R2
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the choice regular formula, which denotes the choice between two
transition sequences. It is satisfied by a sequence of LTS transitions iff
this sequence satisfies <I>R1</I> or it satisfies <I>R2</I>. <P>
None of the data variables
exported by <I>R1</I> (resp. by <I>R2</I>) is visible in <I>R2</I> (resp. in <I>R1</I>). All data variables
exported both by <I>R1</I> and by <I>R2</I> are also exported to the enclosing formula.
</DD><P>
</DL></DD><P></DL>
<P>
  <PRE>R "*"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the repetition regular formula, which denotes the repetition of a
transition sequence 0 or more times (transitive reflexive closure). It is
satisfied by a sequence of LTS transitions iff this sequence consists of
the concatenation of 0 or more sub-sequences, each of them satisfying <I>R</I>.
Note that any empty sequence satisfies the repetition formula. <P>
None of the
data variables exported by <I>R</I> is exported to the enclosing formula, since
none of these variables will be initialized when the repetition formula
is satisfied by an empty sequence. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>R "+"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the strict repetition regular formula, which denotes the repetition
of a transition sequence 1 or more times (transitive closure). It is satisfied
by a sequence of LTS transitions iff this sequence consists of the concatenation
of 1 or more sub-sequences, each of them satisfying <I>R</I>. <P>
All data variables
exported by <I>R</I> are also exported to the enclosing formula, since <I>R</I> is always
satisfied by at least one sub-sequence of the current sequence. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>R "?"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the option regular formula, which denotes the optional occurrence
of a transition sequence (i.e., its repetition 0 or 1 times). It is satisfied
by a sequence of LTS transitions iff this sequence is empty or it satisfies
<I>R</I>. <P>
None of the data variables exported by <I>R</I> is exported to the enclosing
formula, since none of these variables will be initialized when the option
formula is satisfied by an empty sequence. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>R "{" E "}"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the counting regular formula, which denotes the repetition of a transition
sequence <I>E</I> times, where <I>E</I> must be of type <CODE>nat</CODE>. It is satisfied by a sequence
of LTS transitions iff this sequence is the concatenation of exactly <I>E</I>
sub-sequences, each of them satisfying <I>R</I>. <P>
None of the data variables exported
by <I>R</I> is exported to the enclosing formula, since none of these variables
will be initialized when the value of <I>E</I> is 0 (i.e., when the counting formula
is satisfied by an empty sequence). </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>R "{" E "..." "}"
</PRE>or   <PRE>R "{" E "," "}"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the left interval counting regular formula, which denotes the repetition
of a transition sequence at least <I>E</I> times, where <I>E</I> must be of type <CODE>nat</CODE>.
It is satisfied by a sequence of LTS transitions iff this sequence is the
concatenation of <I>E</I> or more sub-sequences, each of them satisfying <I>R</I>. <P>
None
of the data variables exported by <I>R</I> is exported to the enclosing formula,
since none of these variables will be initialized when the value of <I>E</I> is
0 (i.e., when the left interval counting formula is satisfied by an empty
sequence). </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>R "{" E1 "..." E2 "}"
</PRE>or   <PRE>R "{" E1 "," E2 "}"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the interval counting regular formula, which denotes the repetition
of a transition sequence at least <I>E1</I> times and at most <I>E2</I> times, where
<I>E1</I> and <I>E2</I> must be of type <CODE>nat</CODE>. It is satisfied by a sequence of LTS transitions
iff this sequence is the concatenation of <I>E1</I> or more (but not more than
<I>E2</I>) sub-sequences, each of them satisfying <I>R</I>. <P>
If the value of <I>E1</I> is equal
to the value of <I>E2</I>, the regular formula is equivalent to <I>R</I> <CODE>{</CODE> <I>E1</I> <CODE>}</CODE>. <P>
If the
value of <I>E1</I> is larger than the value of <I>E2</I>, the regular formula is equivalent
to <CODE>nil</CODE>. <P>
None of the data variables exported by <I>R</I> is exported to the enclosing
formula, since none of these variables will be initialized when the value
of <I>E1</I> is 0 (i.e., when the interval counting formula is satisfied by an empty
sequence). </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"let" X0 ":" T0 ":=" E0 "," ... "," Xn ":" Tn ":=" En "in"
    R
"end" "let"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the variable definition regular formula, which declares and initializes
data variables. It is satisfied by a sequence of LTS transitions iff this
sequence satisfies the regular formula <I>R</I> in which all occurrences of variables
<I>X0</I>, ..., <I>Xn</I> are substituted with the values of the expressions <I>E0</I>, ..., <I>En</I>, respectively.
Each expression <I>Ei</I> must be of type <I>Ti</I> for 0 &lt;= <I>i</I> &lt;= <I>n</I>. <P>
Variables <I>X0</I>, ..., <I>Xn</I>
are visible in <I>R</I> but not in the enclosing formula. All data variables exported
by <I>R</I> are also exported to the enclosing formula (regardless of whether
or not they are identical to some of the variables <I>X0</I>, ..., <I>Xn</I>). </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"if" F0 "then"
    R0
[ "elsif" F1 "then"
    R1
  ...
  "elsif" Fn "then"
    Rn
  "else"
    Rn+1 ]
"end" "if"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the conditional regular formula, which denotes the conditional branching
between several alternative transition sequences depending whether their
source states satisfy or not certain state formulas. It is satisfied by
a sequence of LTS transitions iff the source state of this sequence satisfies
<I>F0</I> and the sequence satisfies <I>R0</I>, or the source state of this sequence
satisfies <I>F1</I> (if present) and the sequence satisfies <I>R1</I>, ..., or the source
state of this sequence satisfies <I>Fn</I> (if present) and the sequence satisfies
<I>Rn</I>, or the sequence satisfies <I>Rn+1</I> (if present). <P>
All state formulas <I>F0</I>,
..., <I>Fn</I> occurring as conditions of the branches must be propositionally closed
(i.e., they cannot contain free occurrences of propositional variables, but
may contain free occurrences of data variables) in order to ensure the
syntactic monotonicity condition (see STATE FORMULAS below) for the whole
<I>MCL</I> formula. <P>
The branches "<CODE>elsif</CODE>" and "<CODE>else</CODE>" are optional; if they are all
absent and the source state of the sequence does not satisfy <I>F0</I>, then the
empty sequence consisting of that state satisfies the conditional formula.
In other words, the following equality holds: <P>
<PRE>    "if" F "then" R "end if"
    =
    "if" F "then" R "else" "nil" "end" "if"
</PRE><P>
If the "<CODE>else</CODE>" clause is absent, none of the data variables exported by
the regular formulas <I>R0</I>, ..., <I>Rn</I> is exported to the enclosing formula, since
none of these variables will be initialized when the conditional formula
is satisfied by an empty sequence. If the "<CODE>else</CODE>" clause is present, each
data variable exported simultaneously by all regular formulas <I>R0</I>, ..., <I>Rn+1</I>
is also exported to the enclosing formula. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"case" E "in"
    P0 [ "where" E0 ] "-&gt;" R0
    ...
"|" Pn [ "where" En ] "-&gt;" Rn
"end" "case"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the selection regular formula, which denotes the selection between
several alternative transition sequences depending whether the value <I>v</I>
of <I>E</I> matches or not certain patterns. It is satisfied by a sequence of LTS
transitions iff this sequence matches one of the branches 0, ..., <I>n</I> of the
selection, in this order. A sequence matches a branch <I>i</I> iff the following
conditions hold: <P>
- <I>v</I> matches the pattern <I>Pi</I>; <P>
- the boolean expression <I>Ei</I>
(if present) evaluates to true in a context in which all variables declared
in <I>Pi</I> are replaced with the corresponding values extracted from <I>v</I>; <P>
- the
sequence satisfies <I>Ri</I> in the same context. <P>
If the value of <I>E</I> does not match
any of the patterns <I>P0</I>, ..., <I>Pn</I>, then an empty sequence satisfies the selection
formula. In other words, in this case the selection formula becomes equivalent
to "<CODE>nil</CODE>". <P>
If some pattern <I>Pi</I> for some 0 &lt;= <I>i</I> &lt;= <I>n</I> is <CODE>any</CODE>, then each data variable
exported simultaneously by all regular formulas <I>R0</I>, ..., <I>Ri</I> is also exported
to the enclosing formula, since at least one of these regular formulas
will be satisfied by the current sequence. If none of the patterns <I>Pi</I> is
<CODE>any</CODE>, then none of the data variables exported by the regular formulas <I>R0</I>,
..., <I>Rn</I> is exported to the enclosing formula, since none of these variables
will be initialized when the selection formula is satisfied by an empty
sequence. <P>
Note: For technical reasons (syntactic ambiguity concerning the
"<CODE>|</CODE>" symbol occurring both as choice operator and as branch separator), formulas
<I>R0</I>, ..., <I>Rn</I> must <I>not</I> contain the "<CODE>|</CODE>" operator at top-level. For instance, the
following formula is illegal: <PRE>    case E in
        P0 -&gt; R1 | R2
    |   P1 -&gt; R3
    end case
</PRE>If regular formulas with the "<CODE>|</CODE>" operator at top-level are required as branches
of a selection formula, then they must be surrounded by parentheses, as
in the formula below: <PRE>    case E in
        P0 -&gt; (R1 | R2)
    |   P1 -&gt; R3
    end case
</PRE>which is legal. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"choice" X0 ":" T0 [ "among" "{" E01 "..." E02 "}" ]
         "," ... ","
         Xn ":" Tn [ "among" "{" En1 "..." En2 "}" ]
"in"
    R
"end" "choice"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the generalized choice regular formula, which denotes the choice
among several alternative transition sequences depending whether data variables
belong or not to certain domains. It is satisfied by a sequence of LTS transitions
iff for each 0 &lt;= <I>i</I> &lt;= <I>n</I> there exists at least a value <I>vi</I> of type <I>Ti</I> in the
domain delimited by the values of <I>Ei1</I> and <I>Ei2</I> (if present) such that the
sequence satisfies the regular formula <I>R</I> in which all occurrences of variables
<I>X0</I>, ..., <I>Xn</I> are substituted with the values <I>v0</I>, ..., <I>vn</I>, respectively. The optional
expressions <I>Ei1</I> and <I>Ei2</I> must be of type <I>Ti</I> for 0 &lt;= <I>i</I> &lt;= <I>n</I>. Only the types
<CODE>bool</CODE> and <CODE>nat</CODE> are allowed currently as <I>Ti</I>s. <P>
All data variables exported by
<I>R</I> are also exported to the enclosing formula (regardless of whether or
not they are identical to some of the variables <I>X0</I>, ..., <I>Xn</I>). </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"while" F "do"
    R
"end" "while"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the initial condition loop regular formula, which denotes the repetition
of a regular sub-sequence as long as its source state satisfies a certain
state formula. It is satisfied by a sequence of LTS transitions iff this
sequence consists of the concatenation of 0 or more sub-sequences such that
the source state of each sub-sequence satisfies <I>F</I> and each sub-sequence satisfies
<I>R</I>. <P>
None of the data variables exported by <I>R</I> is exported to the enclosing
formula, since none of these variables will be initialized when the initial
condition loop formula is satisfied by an empty sequence (whose source
state does not satisfy <I>F</I>). </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"repeat"
    R
"until" F "end" "repeat"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the final condition loop regular formula, which denotes the repetition
of a regular sub-sequence until its target state satisfies a certain state
formula. It is satisfied by a sequence of LTS transitions iff this sequence
consists of the concatenation of 1 or more sub-sequences such that the target
state of each sub-sequence satisfies <I>F</I> and each sub-sequence satisfies <I>R</I>.
<P>
All data variables exported by <I>R</I> are also exported to the enclosing formula,
since <I>R</I> is always satisfied by at least one sub-sequence of the current
sequence (the body of the final condition loop formula is repeated at least
once). </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"for" X ":" T "from" E1 "to" E2 [ "step" E3 ] "do"
    R
"end" "for"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the bounded loop regular formula, which denotes the repetition of
a regular sub-sequence depending on the values taken by variable <I>X</I> in an
interval. It is satisfied by a sequence of LTS transitions iff this sequence
consists of the concatenation of 0 or more sub-sequences, such that each
sub-sequence satisfies the regular formula <I>R</I> for the current value of variable
<I>X</I> (which may occur or not in <I>R</I>). The expressions <I>E1</I>, <I>E2</I>, and <I>E3</I> must be
of type <I>T</I>. At the first iteration of the loop, <I>X</I> is initialized with the
value of <I>E1</I>. At each sub-sequent iteration, <I>X</I> is incremented either by  the
value of <I>E3</I> if the optional clause "step" is present, or by 1 otherwise.
The loop terminates when <I>X</I> becomes strictly greater than the value of <I>E2</I>.
<P>
None of the data variables exported by <I>R</I> is exported to the enclosing formula,
since none of these variables will be initialized when the bounded loop
formula is satisfied by an empty sequence. <P>
The type <I>T</I> of the iteration variable
can be currently the <CODE>nat</CODE> type only. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"loop" [ "(" X0 ":" T0 ":=" E0 "," ... "," Xn ":" Tn ":=" En ")" ]
       [ ":" "(" X'0 ":" T'0 "," ... "," X'm ":" T'm ")" ]
"in"
    R
"end" "loop"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the general loop regular formula, which denotes the repetition of
a regular sub-sequence satisfying <I>R</I> depending on the values of the optional
input parameters <I>X0</I>, ..., <I>Xn</I>. These parameters are initialized at the start
of the loop with the values of expressions <I>E0</I>, ..., <I>En</I>, which must be of types
<I>T0</I>, ..., <I>Tn</I>, respectively. Upon termination of the loop, the optional output
parameters <I>X'0</I>, ..., <I>X'm</I> are assigned appropriate values and are exported to
the enclosing formula. <P>
An iteration of the loop is triggered when the evaluation
of <I>R</I> on a sub-sequence of the current sequence leads to the evaluation of
a "continue" subformula of <I>R</I> (see below), which must assign values to the
input parameters <I>X0</I>, ..., <I>Xn</I>. The loop terminates when the evaluation of <I>R</I>
on a sub-sequence of the current sequence either does not lead to the evaluation
of a "continue" subformula (in this case the loop must not have output
parameters), or it leads to the evaluation of an "exit" subformula of <I>R</I>
(see below), which must assign values to the output parameters <I>X'0</I>, ..., <I>X'm</I>.
<P>
None of the data variables exported by <I>R</I> is exported to the enclosing formula,
since none of these variables will be initialized when the general loop
formula is satisfied by an empty sequence. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"continue" [ "(" E0 "," ..."," En ")" ]
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the continuation regular formula, which denotes the general loop
repetition. It can occur only in the scope of a "loop" regular formula. If
present, the optional expressions <I>E0</I>, ..., <I>En</I> must be of the same types <I>T0</I>,
..., <I>Tn</I> as the input parameters <I>X0</I>, ..., <I>Xn</I> of the immediately enclosing "loop"
formula. The continuation formula is always satisfied by an LTS sequence
and triggers an iteration of the immediately enclosing "loop" formula,
the input parameters of which are assigned the values of the expressions
<I>E0</I>, ..., <I>En</I>, respectively. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"exit" [ "(" E0 "," ... "," Em ")" ]
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the termination regular formula, which denotes the general loop termination.
It can occur only in the scope of a "loop" regular formula. If present,
the optional expressions <I>E0</I>, ..., <I>Em</I> must be of the same types <I>T'0</I>, ..., <I>T'm</I> as
the output parameters <I>X'0</I>, ..., <I>X'm</I> of the immediately enclosing "loop" formula.
The termination formula is always satisfied by an LTS sequence and triggers
the termination of the immediately enclosing "loop" formula, the output
parameters of which are exported to the enclosing formula after being assigned
the values of the expressions <I>E0</I>, ..., <I>Em</I>, respectively. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"export" "(" X0 ":" T0 ":=" E0 "," ... "," Xn ":" Tn ":=" En ")"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the exporting regular formula, which assigns the values of expressions
<I>E0</I>, ..., <I>En</I> to variables <I>X0</I>, ..., <I>Xn</I> and exports them to the enclosing formula.
The expressions <I>E0</I>, ..., <I>En</I> must be of types <I>T0</I>, ..., <I>Tn</I>, respectively. The exporting
formula is satisfied by any LTS sequence. It is an abbreviation of the following
"loop" formula: <P>
<PRE>    "loop" "(" X0 ":" T0"," ... "," Xn ":" Tn ")" "in"
        "exit" "(" E0 "," ... "," En ")"
    "end" "loop"
</PRE><P>
Note: The "let" regular formula (see above) also assigns values to variables,
but these variables are visible only in the regular subformula of the "let"
formula and are not exported to the enclosing formula. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"(" R ")"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>a sequence of LTS transitions satisfies this formula iff it satisfies
<I>R</I>. Parentheses are useful for imposing an evaluation order of subformulas
different from the order given by the associativity and precedence of operators.
</DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect11" HREF="#sect11">State Formulas</A></H2>
A <I>state formula</I> is a logical formula built from boolean operators,
modalities, fixed point operators, and data-handling constructs inspired
from functional programming languages. The syntax of <I>MCL</I> state formulas
is defined by the following grammar: <P>
  <PRE>F<tt> </tt>&nbsp;<tt> </tt>&nbsp;::=  E
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "true"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "false"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "not" F
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   F1 "or" F2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   F1 "xor" F2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   F1 "and" F2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   F1 "implies" F2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   F1 "equ" F2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "&lt;" R "&gt;" F
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "&lt;&lt;" R "&gt;&gt;" F
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "[" R "]" F
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "[[" R "]]" F
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "&lt;" R "&gt;" "@"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "&lt;&lt;" R "&gt;&gt;" "@"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "[" R "]" "-|"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "[[" R "]]" "-|"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   Y [ "(" E0 "," ... "," En ")" ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "mu" Y [ "(" X0 ":" T0 ":=" E0 "," ... ","
<tt> </tt>&nbsp;<tt> </tt>&nbsp;                  Xn ":" Tn ":=" En ")" ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "." F
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "nu" Y [ "(" X0 ":" T0 ":=" E0 "," ... ","
<tt> </tt>&nbsp;<tt> </tt>&nbsp;                  Xn ":" Tn ":=" En ")" ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "." F
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "exists" X0 ":" T0 [ "among" "{" E01 "..." E02 "}" ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;             "," ... ","
<tt> </tt>&nbsp;<tt> </tt>&nbsp;              Xn ":" Tn [ "among" "{" En1 "..." En2 "}" ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "." F
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "forall" X0 ":" T0 [ "among" "{" E01 "..." E02 "}" ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;              "," ... ","
<tt> </tt>&nbsp;<tt> </tt>&nbsp;              Xn ":" Tn [ "among" "{" En1 "..." En2 "}" ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "." F
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "let" X0 ":" T0 ":=" E0 "," ... "," Xn ":" Tn ":=" En "in"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         F
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "end" "let"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "if" F0 "then"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         F'0
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     [ "elsif" F1 "then"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         F'1
<tt> </tt>&nbsp;<tt> </tt>&nbsp;       ...
<tt> </tt>&nbsp;<tt> </tt>&nbsp;       "elsif" Fn "then"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         F'n
<tt> </tt>&nbsp;<tt> </tt>&nbsp;       "else"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         Fn+1 ]
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "end" "if"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "case" E "in"
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         P0 [ "where" E0 ] "-&gt;" F0
<tt> </tt>&nbsp;<tt> </tt>&nbsp;         ...
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "|" Pn [ "where" En ] "-&gt;" Fn
<tt> </tt>&nbsp;<tt> </tt>&nbsp;     "end" "case"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "(" F ")"

</PRE>  <P>
Syntactically, all binary operators on state formulas are left-associative.
The unary operators "<CODE>not</CODE>", "&lt;"..."&gt;", "&lt;&lt;"..."&gt;&gt;", "["..."]", "[["..."]]", "mu", "nu", "exists",
and "forall" have the highest precedence, followed by "<CODE>and</CODE>", followed by
"<CODE>or</CODE>" and "<CODE>xor</CODE>", followed by "<CODE>implies</CODE>", followed by "<CODE>equ</CODE>". <P>
The minimal and
maximal fixed point operators "mu" and "nu" act as binders for the propositional
variables <I>Y</I> in a way that is similar to quantifiers in first-order logic.
In each meaningful "<CODE>mu</CODE> <I>Y</I> <CODE>(</CODE>...<CODE>)</CODE> <CODE>.</CODE> <I>F</I>" or "<CODE>nu</CODE> <I>Y</I> <CODE>(</CODE>...<CODE>)</CODE> <CODE>.</CODE> <I>F</I>" formula, <I>Y</I> is assumed to
have free occurrences inside <I>F</I>. <P>
State formulas must satisfy the following
two syntactic conditions: 
<UL>
<LI type=disc><I>Syntactic monotonicity</I> [Koz83] means that in
each fixed point formula "<CODE>mu</CODE> <I>Y</I> <CODE>(</CODE>...<CODE>)</CODE> <CODE>.</CODE> <I>F</I>" or "<CODE>nu</CODE> <I>Y</I> <CODE>(</CODE>...<CODE>)</CODE> <CODE>.</CODE> <I>F</I>", free occurrences
of the propositional variable <I>Y</I> in <I>F</I> may appear only under an even number
of negations and/or left-hand sides of implications. </LI><P><LI type=disc><I>Alternation-freeness</I>
[EL86] means that each fixed point formula "<CODE>mu</CODE> <I>Y</I> <CODE>(</CODE>...<CODE>)</CODE> <CODE>.</CODE> <I>F</I>" cannot contain
free occurrences of propositional variables <I>Y'</I> defined by "<CODE>nu</CODE>" operators,
and each fixed point formula "<CODE>nu</CODE> <I>Y</I> <CODE>(</CODE>...<CODE>)</CODE> <CODE>.</CODE> <I>F</I>" cannot contain free occurrences
of propositional variables <I>Y'</I> defined by "<CODE>mu</CODE>" operators. When checking this
condition on a formula, strong possibility (resp. necessity) modalities
whose regular subformulas contain an iteration operator, and weak possibility
(resp. necessity) modalities are interpreted as "hidden" minimal (resp. maximal)
fixed point operators. Note that the state formulas corresponding to infinite
looping and saturation operators do not satisfy the alternation-freeness
condition (see REMARKS below). </LI><P>
</UL>
<P>
A state formula defines a predicate over
the states of the LTS. The semantics of <I>MCL</I> state formulas is described
informally below. <P>
  <PRE>E
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>a state of the LTS satisfies a boolean expression <I>E</I> iff <I>E</I> evaluates
to <CODE>true</CODE>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"true"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>a state of the LTS always satisfies this formula. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"false"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>a state of the LTS never satisfies this formula. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"not" F
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>a state of the LTS satisfies this formula iff it does not satisfy <I>F</I>.
</DD><P>
</DL></DD><P></DL>
<P>
  <PRE>F1 "or" F2
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>a state of the LTS satisfies this formula iff it satisfies <I>F1</I> or it
satisfies <I>F2</I>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>F1 "xor" F2
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>a state of the LTS satisfies this formula iff it satisfies exactly one
of <I>F1</I> and <I>F2</I>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>F1 "and" F2
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>a state of the LTS satisfies this formula iff it satisfies both <I>F1</I> and
<I>F2</I>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>F1 "implies" F2
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>a state of the LTS satisfies this formula iff it does not satisfy <I>F1</I>
or it satisfies <I>F2</I>. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>F1 "equ" F2
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>a state of the LTS satisfies this formula iff either it satisfies both
<I>F1</I> and <I>F2</I>, or neither of them. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"&lt;" R "&gt;" F
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the possibility modality. It is satisfied by a state of the LTS iff
there is some transition sequence going out of this state that satisfies
the regular formula <I>R</I> and leads to a state satisfying the state formula
<I>F</I>. <P>
The evaluation of <I>F</I> on the target state of the transition sequence is
carried out in a context in which all data variables exported by <I>R</I> are
initialized with the corresponding values extracted from the sequence. If
there is no transition sequence satisfying <I>R</I>, then the whole possibility
modality is false and <I>F</I> is not evaluated at all. <P>
All data variables exported
by <I>R</I> are visible in <I>F</I>, but none of them is exported outside the whole possibility
modality. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"&lt;&lt;" R "&gt;&gt;" F
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the weak possibility modality. It is satisfied by a state of the LTS
iff there is some transition sequence going out of this state that weakly
satisfies the regular formula <I>R</I> and leads to a state satisfying the state
formula <I>F</I>. <P>
The evaluation of <I>F</I> on the target state of the transition sequence
is carried out in a context in which all data variables exported by <I>R</I> are
initialized with the corresponding values extracted from the sequence. If
there is no transition sequence weakly satisfying <I>R</I>, then the whole weak
possibility modality is false and <I>F</I> is not evaluated at all. <P>
All data variables
exported by <I>R</I> are visible in <I>F</I>, but none of them is exported outside the
whole weak possibility modality. <P>
The regular formula <I>R</I> must not contain
any occurrence of the <CODE>tau</CODE> action formula. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"[" R "]" F
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the necessity modality. It is satisfied by a state of the LTS iff
for each transition sequence going out of this state, if this sequence
satisfies the regular formula <I>R</I>, then it must lead to a state satisfying
the state formula <I>F</I>. <P>
The evaluation of <I>F</I> on the target state of each transition
sequence is carried out in a context in which all data variables exported
by <I>R</I> are initialized with the corresponding values extracted from that
sequence. If there is no transition sequence satisfying <I>R</I>, then the whole
necessity modality is true and <I>F</I> is not evaluated at all. <P>
All data variables
exported by <I>R</I> are visible in <I>F</I>, but none of them is exported outside the
whole necessity modality. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"[[" R "]]" F
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the weak necessity modality. It is satisfied by a state of the LTS
iff for each transition sequence going out of this state, if this sequence
weakly satisfies the regular formula <I>R</I>, then it must lead to a state satisfying
the state formula <I>F</I>. <P>
The evaluation of <I>F</I> on the target state of each transition
sequence is carried out in a context in which all data variables exported
by <I>R</I> are initialized with the corresponding values extracted from that
sequence. If there is no transition sequence weakly satisfying <I>R</I>, then the
whole weak necessity modality is true and <I>F</I> is not evaluated at all. <P>
All
data variables exported by <I>R</I> are visible in <I>F</I>, but none of them is exported
outside the whole weak necessity modality. <P>
The regular formula <I>R</I> must not
contain any occurrence of the <CODE>tau</CODE> action formula. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"&lt;" R "&gt;" "@"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the infinite looping formula. It is satisfied by a state of the LTS
iff there is some transition sequence going out of this state and consisting
of an infinite concatenation of sub-sequences that satisfy the regular formula
<I>R</I>. <P>
None of the data variables exported by <I>R</I> is exported outside of the infinite
looping formula. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"&lt;&lt;" R "&gt;&gt;" "@"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the weak infinite looping formula. It is satisfied by a state of the
LTS iff there is some transition sequence going out of this state and consisting
of an infinite concatenation of sub-sequences that weakly satisfy the regular
formula <I>R</I>. <P>
None of the data variables exported by <I>R</I> is exported outside
of the weak infinite looping formula. <P>
The regular formula <I>R</I> must not contain
any occurrence of the <CODE>tau</CODE> action formula. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"[" R "]" "-|"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the finite saturation formula. It is satisfied by a state of the LTS
iff for each transition sequence going out of this state, if this sequence
consists of a concatenation of sub-sequences that satisfy the regular formula
<I>R</I>, then the sequence must be finite. <P>
None of the data variables exported
by <I>R</I> is exported outside of the finite saturation formula. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"[[" R "]]" "-|"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the weak finite saturation formula. It is satisfied by a state of
the LTS iff for each transition sequence going out of this state, if this
sequence consists of a concatenation of sub-sequences that weakly satisfy
the regular formula <I>R</I>, then the sequence must be finite. <P>
None of the data
variables exported by <I>R</I> is exported outside of the weak finite saturation
formula. <P>
The regular formula <I>R</I> must not contain any occurrence of the <CODE>tau</CODE>
action formula. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>Y [ "(" E0 "," ... "," En ")" ]
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is a call of the propositional variable <I>Y</I>. It can occur only in the scope
of a fixed point formula defining <I>Y</I>. If present, the optional expressions
<I>E0</I>, ..., <I>En</I> must be of the same types <I>T0</I>, ..., <I>Tn</I> as the parameters <I>X0</I>, ..., <I>Xn</I>
of the corresponding fixed point formula. The propositional variable call
formula is satisfied by a state of the LTS iff this state belongs to the
solution <I>Y</I> of the corresponding fixed point equation, evaluated by assigning
the values of the expressions <I>E0</I>, ..., <I>En</I> to the parameters <I>X0</I>, ..., <I>Xn</I>, respectively.
</DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"mu" Y [ "(" X0 ":" T0 ":=" E0 "," ... ","
             Xn ":" Tn ":=" En ")" ]
"." F
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the parameterized minimal fixed point formula defining the propositional
variable <I>Y</I>. The expressions <I>E0</I>, ..., <I>En</I> must be of types <I>T0</I>, ..., <I>Tn</I>, respectively.
The formula is satisfied by a state of the LTS iff this state belongs to
the minimal solution of the fixed point equation <I>Y</I> (<I>X0</I>, ..., <I>Xn</I>) = <I>F</I>, evaluated
by assigning the values of the expressions <I>E0</I>, ..., <I>En</I> to the parameters <I>X0</I>,
..., <I>Xn</I>, respectively. The parameters <I>X0</I>, ..., <I>Xn</I> are visible only in <I>F</I> and are
not exported outside the minimal fixed point formula. <P>
Intuitively, a parameterized
minimal fixed point formula characterizes finite subgraphs contained in
the LTS. The parameters enable one to perform arbitrary computations during
a forward traversal of the subgraphs. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"nu" Y [ "(" X0 ":" T0 ":=" E0 "," ... ","
             Xn ":" Tn ":=" En ")" ]
"." F
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the parameterized maximal fixed point formula defining the propositional
variable <I>Y</I>. The expressions <I>E0</I>, ..., <I>En</I> must be of types <I>T0</I>, ..., <I>Tn</I>, respectively.
The formula is satisfied by a state of the LTS iff this state belongs to
the maximal solution of the fixed point equation <I>Y</I> (<I>X0</I>, ..., <I>Xn</I>) = <I>F</I>, evaluated
by assigning the values of the expressions <I>E0</I>, ..., <I>En</I> to the parameters <I>X0</I>,
..., <I>Xn</I>, respectively. The parameters <I>X0</I>, ..., <I>Xn</I> are visible only in <I>F</I> and are
not exported outside the maximal fixed point formula. <P>
Intuitively, a parameterized
maximal fixed point formula characterizes infinite subgraphs contained
in the LTS. The parameters enable one to perform arbitrary computations
during a forward traversal of the subgraphs. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"exists" X0 ":" T0 [ "among" "{" E01 "..." E02 "}" ]
         "," ... ","
         Xn ":" Tn [ "among" "{" En1 "..." En2 "}" ]
"." F
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the existential quantification over variables <I>X0</I>, ..., <I>Xn</I>. It is satisfied
by a state of the LTS iff there exists a combination of values <I>v0</I>, ..., <I>vn</I>
belonging to the types <I>T0</I>, ..., <I>Tn</I> (possibly restricted to the optional domains
delimited by the values of <I>E01</I>, <I>E02</I>, ..., <I>En1</I>, <I>En2</I> if present) such that this
state satisfies the state formula <I>F</I> in which all occurrences of variables
<I>X0</I>, ..., <I>Xn</I> are substituted with the values <I>v0</I>, ..., <I>vn</I>, respectively. The optional
expressions <I>Ei1</I> and <I>Ei2</I> must be of type <I>Ti</I> for 0 &lt;= <I>i</I> &lt;= <I>n</I>. Only the types
<CODE>bool</CODE> and <CODE>nat</CODE> are allowed currently as <I>Ti</I>s. <P>
The variables <I>X0</I>, ..., <I>Xn</I> are visible
only in <I>F</I> and are not exported outside the existential quantification formula.
<P>
Note: The existential quantifier is not, strictly speaking, a primitive
operator of <I>MCL</I>. It can be seen as an abbreviation of the disjunction operator.
Assuming that the domain of variable <I>Xi</I> is <CODE>{</CODE> <I>vi0</I>, ... <I>vimi</I> <CODE>}</CODE> for 0 &lt;= <I>i</I> &lt;= <I>n</I>,
the existential quantification formula is equivalent to the disjunction
below: <P>
<PRE>    F (v00, ..., vn0) or ... or F (v00, ..., vnmn)
    or ... or
    F (v0m0, ..., vn0) or ... or F (v0m0, ..., vnmn)
</PRE><P>
where <I>F</I> (<I>v0j</I>, ..., <I>vnk</I>) denotes the state formula <I>F</I> in which all occurrences
of variables <I>X0</I>, ..., <I>Xn</I> are substituted with the values <I>v0j</I>, ..., <I>vnk</I>, respectively.
In practice, the usage of the existential quantifier may yield much more
concise formulations of properties than its equivalent disjunctive formulation.
</DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"forall" X0 ":" T0 [ "among" "{" E01 "..." E02 "}" ]
         "," ... ","
         Xn ":" Tn [ "among" "{" En1 "..." En2 "}" ]
"." F
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the universal quantification over variables <I>X0</I>, ..., <I>Xn</I>. It is satisfied
by a state of the LTS iff for every combination of values <I>v0</I>, ..., <I>vn</I> belonging
to the types <I>T0</I>, ..., <I>Tn</I> (possibly restricted to the optional domains delimited
by the values of <I>E01</I>, <I>E02</I>, ..., <I>En1</I>, <I>En2</I> if present), this state satisfies
the state formula <I>F</I> in which all occurrences of variables <I>X0</I>, ..., <I>Xn</I> are
substituted with the values <I>v0</I>, ..., <I>vn</I>, respectively. The optional expressions
<I>Ei1</I> and <I>Ei2</I> must be of type <I>Ti</I> for 0 &lt;= <I>i</I> &lt;= <I>n</I>. Only the types <CODE>bool</CODE> and <CODE>nat</CODE>
are allowed currently as <I>Ti</I>s. <P>
The variables <I>X0</I>, ..., <I>Xn</I> are visible only in
<I>F</I> and are not exported outside the universal quantification formula. <P>
Note:
The universal quantifier is not, strictly speaking, a primitive operator
of <I>MCL</I>. It can be seen as an abbreviation of the conjunction operator. Assuming
that the domain of variable <I>Xi</I> is <CODE>{</CODE> <I>vi0</I>, ... <I>vimi</I> <CODE>}</CODE> for 0 &lt;= <I>i</I> &lt;= <I>n</I>, the universal
quantification formula is equivalent to the conjunction below: <P>
<PRE>    F (v00, ..., vn0) and ... and F (v00, ..., vnmn)
    and ... and
    F (v0m0, ..., vn0) and ... and F (v0m0, ..., vnmn)
</PRE><P>
where <I>F</I> (<I>v0j</I>, ..., <I>vnk</I>) denotes the state formula <I>F</I> in which all occurrences
of variables <I>X0</I>, ..., <I>Xn</I> are substituted with the values <I>v0j</I>, ..., <I>vnk</I>, respectively.
In practice, the usage of the universal quantifier may yield much more
concise formulations of properties than its equivalent conjunctive formulation.
</DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"let" X0 ":" T0 ":=" E0 "," ... "," Xn ":" Tn ":=" En "in"
      F
"end" "let"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the variable definition state formula, which declares and initializes
data variables. It is satisfied by a state of the LTS iff this state satisfies
the state formula <I>F</I> in which all occurrences of variables <I>X0</I>, ..., <I>Xn</I> are
substituted with the values of the expressions <I>E0</I>, ..., <I>En</I>, respectively. Each
expression <I>Ei</I> must be of type <I>Ti</I> for 0 &lt;= <I>i</I> &lt;= <I>n</I>. <P>
The variables <I>X0</I>, ..., <I>Xn</I> are
visible only in <I>F</I> and are not exported outside the variable definition
formula. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"if" F0 "then"
     F'0
[ "elsif" F1 "then"
     F'1
  ...
  "elsif" Fn "then"
     F'n
  "else"
     Fn+1 ]
"end" "if"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the conditional state formula, which denotes the branching according
to certain state formulas. It is satisfied by a state of the LTS iff either
this state satisfies <I>F0</I> and it also satisfies <I>F'0</I>, or this state satisfies
<I>F1</I> (if present) and it also satisfies <I>F'1</I>, ..., or this state satisfies <I>Fn</I>
(if present) and it also satisfies <I>F'n</I>, or this state satisfies <I>Fn+1</I> (if
present). <P>
All state formulas <I>F0</I>, ..., <I>Fn</I> occurring as conditions of the branches
must be propositionally closed (i.e., they cannot contain free occurrences
of propositional variables, but may contain free occurrences of data variables)
in order to ensure the syntactic monotonicity condition for the whole <I>MCL</I>
formula. <P>
The branches "<CODE>elsif</CODE>" and "<CODE>else</CODE>" are optional; if they are all absent
and the state does not satisfy <I>F0</I>, then this state satisfies the conditional
formula. In other words, the following equality holds: <P>
<PRE>    "if" F0 "then" F'0 "end if"
    =
    "if" F0 "then" F'0 "else" "true" "end" "if"
</PRE></DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"case" E "in"
    P0 [ "where" E0 ] "-&gt;" F0
    ...
"|" Pn [ "where" En ] "-&gt;" Fn
"end" "case"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>is the selection state formula, which denotes the selection between
several alternatives depending on whether the value <I>v</I> of <I>E</I> matches or not
certain patterns. It is satisfied by a state of the LTS iff this state matches
one of the branches 0, ..., <I>n</I> of the selection, in this order. A state matches
a branch <I>i</I> iff the following conditions hold: <P>
- <I>v</I> matches the pattern <I>Pi</I>;
<P>
- the boolean expression <I>Ei</I> (if present) evaluates to true in a context
in which all variables declared in <I>Pi</I> are replaced with the corresponding
values extracted from <I>v</I>; <P>
- the state satisfies <I>Fi</I> in the same context. <P>
If
the value of <I>E</I> does not match any of the patterns <I>P0</I>, ..., <I>Pn</I>, then the selection
formula is true. </DD><P>
</DL></DD><P></DL>
<P>
  <PRE>"(" F ")"
</PRE>  
<DL><DD><DL COMPACT>

<DT></DT>
<DD>a state of the LTS satisfies this formula iff it satisfies <I>F</I>. Parentheses
are useful for imposing an evaluation order of subformulas different from
the order given by the associativity and precedence of operators. </DD><P>
</DL></DD><P></DL>
<P>
An LTS
satisfies a state formula <I>F</I> iff its initial state <I>s0</I> satisfies <I>F</I>. 
<H2><A NAME="sect12" HREF="#sect12">Remarks</A></H2>
When
writing complex formulas containing many operators (especially when mixing
regular and boolean operators), it is safer to use parentheses to enclose
subformulas whenever being in doubt about the relative precedence of the
operators. Otherwise, the tool may parse and evaluate the formulas in a
way different from the user's intentions, leading to erroneous results that
may be quite difficult to track down. <P>
Not all operators defined above are
primitive constructs of the logic. The boolean operators "<CODE>false</CODE>", "<CODE>and</CODE>",
"<CODE>implies</CODE>", and "<CODE>equ</CODE>" can be expressed in terms of "<CODE>true</CODE>", "<CODE>or</CODE>", and "<CODE>not</CODE>"
in the usual way. The diamond and box modalities are dual: <P>
<PRE>    [ R ] F   = not &lt; R &gt;   not F
    [[ R ]] F = not &lt;&lt; R &gt;&gt; not F
</PRE><P>
The same holds for minimal and maximal fixed point operators (only parameterless
versions are illustrated below): <P>
<PRE>    nu Y . F = not mu Y . not F (not Y)
</PRE><P>
where <I>F</I> <B>(not</B> <I>Y</I><B>)</B> denotes the syntactic substitution of <I>Y</I> by <B>not</B> <I>Y</I> in <I>F</I>. <P>
The
infinite looping operator and the finite saturation operator are opposites:
<P>
<PRE>    &lt; R &gt; @   = not [ R ]   -|
    &lt;&lt; R &gt;&gt; @ = not [[ R ]] -|
</PRE><P>
The modalities containing regular formulas can be translated in terms of
boolean operators, fixed point operators, and modalities containing only
action formulas (see [MS03,MT08] for details). <P>
The infinite looping and
finite saturation operators correspond to fixed point formulas belonging
to the mu-calculus fragment of alternation depth two [EL86]. In practice,
this means that one can write formulas "<CODE>&lt;</CODE> <I>R</I> <CODE>&gt;</CODE> <CODE>@</CODE>" in which the regular subformula
<I>R</I> contains iteration operators. This feature is supported by <B>evaluator4</B>,
but was not available in <B>evaluator3</B>, which accepted only "<CODE>&lt;</CODE> <I>R</I> <CODE>&gt;</CODE> <CODE>@</CODE>" formulas
containing iteration-free regular subformulas <I>R</I>. <P>
<B>evaluator4</B> handles the equivalent
fixed point formulations of infinite looping and saturation operators,
which can be used directly instead of these operators: <P>
<PRE>    &lt; R &gt; @    = nu Y . &lt; R &gt; Y
    &lt;&lt; R &gt;&gt; @  = nu Y . &lt;&lt; R &gt;&gt; Y
    [ R ] -|   = mu Y . [ R ] Y
    [[ R ]] -| = mu Y . [[ R ]] Y
</PRE><P>
Moreover, in the fixed point formulas equivalent to infinite looping and
saturation operators, <B>evaluator4</B> accepts propositional variables <I>Y</I> parameterized
by data values (see FAIRNESS PROPERTIES below). <P>
For efficiency reasons,
when using fixed point operators, it is recommended to put the recursive
call of the propositional variable at the rightmost place in the formula
(as in all fixed point formulas shown above). This reduces both the evaluation
time and the size of the diagnostic generated for the formula. <P>
A fixed point
formula "<CODE>mu</CODE>" <I>X</I> "<CODE>.</CODE>" <I>F</I> or "<CODE>nu</CODE>" <I>X</I> "<CODE>.</CODE>" <I>F</I> is <I>unguarded</I> [Koz83] if <I>F</I> contains at
least one free occurrence of <I>X</I> which is not preceded (not necessarily immediately)
by a modality. The evaluation of an unguarded formula on an LTS may yield
a BES with cyclic dependencies between variables even if the LTS is acyclic.
<P>
Note that a state formula containing regular modalities with nested star
operators may yield after translation an unguarded mu-calculus formula. For
example, in the following formula: <P>
<PRE>    &lt; A1** . A2 &gt; true =
        mu X1 . (&lt; A2 &gt; true or mu X2 . (X1 or &lt; A1 &gt; X2)
</PRE><P>
the free occurrence of <I>X1</I> is not preceded by any modality, and hence the
formula is unguarded. <P>
Unguarded occurrences of propositional variables can
always be eliminated from a mu-calculus formula, at the price of an increase
in size [Koz83,Mat02]. 
<H2><A NAME="sect13" HREF="#sect13">Examples of Temporal Properties</A></H2>
<I>MCL</I> allows to express
concisely various interesting properties. The most useful classes of temporal
properties are illustrated below. 
<H3><A NAME="sect14" HREF="#sect14">Safety Properties</A></H3>
Informally, a <I>safety</I>
property specifies that "something bad never happens." Typical safety properties
are those forbidding "bad" execution sequences in the LTS. These properties
can be naturally expressed using box modalities containing regular formulas.
For instance, mutual exclusion can be characterized by the following formula:
<P>
<PRE>    [ true* . "ENTER !1" . (not "LEAVE !1")* . "ENTER !2" ] false
</PRE><P>
which states that every time process 1 enters its critical section (action
<CODE>"ENTER !1"</CODE>), it is impossible that process 2 also enters its critical section
(action <CODE>"ENTER !2"</CODE>) before process 1 has left its critical section (action
<CODE>"LEAVE !1"</CODE>). <P>
Note that this formula does not make any assumption about the
fact that a process enters/leaves several times its critical section, i.e.,
the formula does not forbid sequences of the form <CODE>"ENTER !1 . ENTER !1 .
LEAVE !1 . LEAVE !1"</CODE>. <P>
The above formula can be made parametric w.r.t. the number
of processes in the system, by using action predicates equipped with data
variables: <P>
<PRE>    [ true* . { ENTER ?m:Nat } . (not { LEAVE !m })* .
      { ENTER ?n:Nat where m &lt;&gt; n } ] false
</PRE><P>
where the values of <CODE>m</CODE>, <CODE>n</CODE> captured by the action predicates <CODE>{</CODE> <I>ENTER</I> ?<I>m</I>:Nat
<CODE>}</CODE> and <CODE>{</CODE> <I>ENTER</I> ?<I>n</I>:Nat <CODE>}</CODE> are propagated to the enclosing formula in order
to ensure that a process <I>n</I> different from <I>m</I> cannot enter its critical section
before process <I>m</I> has left it (action predicate <CODE>{</CODE> <I>LEAVE</I> !<I>m</I> <I>}</I>). <P>
Regular formulas
equipped with counters provide a useful means for describing safety properties
depending on data. The formula below expresses (part of) the safety of a
<I>n</I>-place buffer: <P>
<PRE>    [ (INPUT . (not OUTPUT)*) { n + 1 } ] false
</PRE><P>
by forbidding the existence of a sequence containing more than <I>n</I> insertions
of elements in the buffer (action <I>INPUT</I>) without any deletions of elements
in between (action <I>OUTPUT</I>). <P>
A more precise formulation of the above property
can be obtained by using a fixed point operator parameterized by a counter
<I>c</I>, which stores the number of elements (initially 0) currently present
in the buffer: <P>
<PRE>    nu Buffer (c:Nat := 0) . (
        [ INPUT ] ((c &lt; n) and Buffer (c + 1))
        and
        [ OUTPUT ] ((c &gt; 0) and Buffer (c - 1))
        and
        [ not (INPUT or OUTPUT) ] Buffer (c)
    )
</PRE><P>
The number of elements <I>c</I> in the buffer is equal to the difference between
the number of elements inserted and deleted from the buffer, and for a
<I>n</I>-place buffer <I>c</I> must belong to 0..<I>n</I>. <P>
Other typical safety properties are the
<I>invariants</I>, expressing that every state of the LTS satisfies some "good"
property. For example, deadlock freedom can be expressed by the formula
below: <P>
<PRE>    [ true* ] &lt; true &gt; true
</PRE><P>
stating that every state has at least one successor. Alternately, this formula
may be expressed directly using a fixed point operator: <P>
<PRE>    nu X . (&lt; true &gt; true and [ true ] X)
</PRE><P>
but less concisely than by using a regular formula. <P>
The "<CODE>natset</CODE>" type is
useful for expressing the occurrence of a set of actions in any order. For
instance, the fact that natural numbers inserted in a bag (initially empty)
can be retrieved in any order can be expressed by the <I>MCL</I> formula below:
<P>
<PRE>    nu Bag (b:NatSet := empty) . (
        [ { PUT ?n:nat } ] Bag (insert (n, b))
        and
        [ { GET ?n:nat } ] ((n isin b) and Bag (remove (n, b)))
        and
        [ not ({ PUT ... } or { GET ... }) ] Bag (b)
    )
</PRE><P>
Here the action predicates <CODE>{</CODE> <I>PUT</I> ?<I>n</I>:Nat <CODE>}</CODE> and <CODE>{</CODE> <I>GET</I> ?<I>n</I>:Nat <CODE>}</CODE> denote the
insertion and retrieval of a natural number into/from the bag, respectively.

<H3><A NAME="sect15" HREF="#sect15">Liveness Properties</A></H3>
Informally, a <I>liveness</I> property specifies that "something
good eventually happens." Typical liveness properties are <I>potentiality</I> assertions
(i.e., expressing the reachability on a sequence) and <I>inevitability</I> assertions
(i.e., expressing the reachability on all sequences). <P>
Potentiality assertions
can be directly expressed using diamond modalities containing regular formulas.
For instance, the following formula: <P>
<PRE>    &lt; true* . { PUT ?n:Nat } . true* . { GET !n } &gt; true
</PRE><P>
states that there exists a sequence that passes (after 0 or more transitions)
through a <I>PUT</I> <I>n</I> action for some natural number <I>n</I>, and then leads (after
0 or more transitions) to a <I>GET</I> <I>n</I> action. <P>
Regular formulas allow to express
succinctly complex potentiality assertions, such as the formula below:
<P>
<PRE>    &lt; true* . SEND . (true* . RETRY) { 0 ... max } .
      true* . RECV &gt; true
</PRE><P>
stating that there exists a sequence leading (after 0 or more transitions)
to a <I>SEND</I> action, possibly followed by a sequence of at most <I>max</I> <I>RETRY</I>
actions (possibly separated by other actions) and leading (after 0 or more
transitions) to a <I>RECV</I> action. <P>
Inevitability assertions can be expressed
using fixed point operators. For instance, the following formula: <P>
<PRE>    mu X . (&lt; true &gt; true and [ not START ] X)
</PRE><P>
states that all transition sequences starting at the current state lead
to <I>START</I> actions after a finite number of steps. <P>
Similarly, temporal properties
containing both safety and liveness aspects can be expressed by combining
box modalities and inevitability operators. For example, the <I>response</I> property
stating that every emission of a message must be inevitably followed in
the future by the reception of the same message can be expressed by the
<I>MCL</I> formula below: <P>
<PRE>    [ true* . { SEND ?n:Nat } ]
        mu X . (&lt; true &gt; true and [ not { RECV !n } ] X)
</PRE><P>
Note how variable <I>n</I> is assigned in the box modality by capturing the value
of a message sent (action predicate <CODE>{</CODE> <I>SEND</I> ?<I>n</I>:Nat <CODE>}</CODE>) and is used later
in the body of the fixed point formula (action predicate <CODE>{</CODE> <I>RECV</I> !<I>n</I> <CODE>}</CODE>). 
<H3><A NAME="sect16" HREF="#sect16">Fairness
Properties</A></H3>
These are similar to liveness properties, except that they express
reachability of actions by considering only <I>fair</I> execution sequences. One
simple notion of fairness that can be easily encoded in <I>MCL</I> is the "fair
reachability of predicates" defined by Queille and Sifakis [QS83]: a sequence
is fair iff it does not infinitely often enable the reachability of a certain
state without infinitely often reaching it. For instance, the following
formula specifies that after every message emission (action SEND), all
fair execution sequences will lead to the reception of the message (action
RECV) after a finite number of steps: <P>
 <PRE>    [ true* . SEND . (not RECV)* ] &lt; (not RECV)* . RECV &gt; true
</PRE> <P>
Intuitively, the formula above considers the sequences following the <I>SEND</I>
action by "skipping" the circuits of the LTS that do not contain <I>RECV</I> actions:
it states that from every state of such a circuit, there is still a finite
sequence leading to a <I>RECV</I> action. <P>
More elaborated forms of fairness can
be expressed by specifying the absence of <I>unfair</I> execution sequences, which
can be characterized using the infinite looping operator. For example, the
formula <I>MCL</I> below expresses that after process <I>i</I> has requested access to
a resource, it cannot be indefinitely preempted by another process <I>j</I>: <P>
<PRE>    [ true* . { REQUEST ?i:Nat } ]
      not &lt; (not { GRANT !i })* . { REQUEST ?j:Nat where j &lt;&gt; i } .
            (not { GRANT !i })* . { GRANT !j } &gt; @
</PRE><P>
This formula can be expressed more concisely by propagating the negation
in front of the infinite looping operator and using the saturation operator:
<P>
<PRE>    [ true* . { REQUEST ?i:Nat } ]
      [ (not { GRANT !i })* . { REQUEST ?j:Nat where j &lt;&gt; i } .
        (not { GRANT !i })* . { GRANT !j } ] -|
</PRE><P>
The existence of complex cycles can be specified using the fixed point
formulation of the infinite looping operator, in which the propositional
variable has data parameters. The formula below expresses the existence
of a cycle on which the pairs emission-reception of messages <CODE>n=0..4</CODE> occur
in this order: <PRE>    nu Y (n:Nat := 0) .
      &lt; true* . { PUT !n } . true* . { GET !n } &gt;
        Y ((n + 1) % 5)
</PRE><P>
Other, more elaborated examples of fairness properties can be found in
[MT08,MS10]. 
<H3><A NAME="sect17" HREF="#sect17">Action Predicates</A></H3>
The use of action formulas (and, in particular,
of regexps) may be of considerable help when dealing with actions having
the same gate but different values in the offers. For instance, the following
formula: <P>
 <PRE>    &lt; true* . 'SEND !1.*' and not 'SEND !1.*!2.*' &gt; true
</PRE> <P>
states the potential reachability of an action having the gate <I>SEND</I> followed
by the value 1, possibly followed by other values different from 2.  <P>
Moreover,
action formulas combined with modalities allow to express invariants over
actions (i.e., action formulas that must be satisfied by all transition labels
of the LTS). For instance, the following formula: <P>
 <PRE>    [ true* . { RECV ?src:Nat ?dest:Nat where src &lt;&gt; dest } ] false
</PRE> <P>
states that all message receptions have different source and destination
fields. Another way of formulating this property is by using regexps on
character strings: <P>
 <PRE>    [ true* .
      not ('RECV !.* !.*' and 'RECV !\(.*\) !\1')
    ] false
</PRE> <P>
Note the use of the UNIX regular expression construct `<B>\( \)</B>' allowing to
match a portion of a string and to reuse it later in the same regexp. 
<H2><A NAME="sect18" HREF="#sect18">Macros
and Libraries</A></H2>
<I>evaluator4</I> allows to define and use macros for temporal operators
parameterized by action and/or state formulas. This feature is particularly
useful for constructing reusable libraries encoding various temporal operators
of other logics translatable in regular alternation-free mu-calculus (like
CTL and ACTL). The <I>macro-definitions</I> have the following syntax: <P>
 <PRE>    "macro" M "(" P1"," ..."," Pn ")" "="
        &lt;text&gt;
    "end_macro"
</PRE> <P>
The above construct defines a macro <I>M</I> having the parameters <I>P1</I>, ..., <I>Pn</I> and
the body <I>&lt;text&gt;</I>, which is a string of alpha-numeric characters (normally)
containing occurrences of the parameters <I>P1</I>, ..., <I>Pn</I>. For example, the following
macro-definition: <P>
  <PRE>    macro EU_A (F1, A, F2) =
        mu X . ((F2) or ((F1) and &lt; A &gt; X))
    end_macro
</PRE>  <P>
encodes the "Exists Until" operator of ACTL, which states that there
exists a sequence of transitions leading to a state satisfying F2 such
that all intermediate states satisfy F1 and all intermediate labels satisfy
A. <P>
The calls of a macro <I>M</I> have the following form: <P>
<PRE>    M "(" &lt;text1&gt;"," ..."," &lt;textn&gt; ")"
</PRE><P>
where the arguments <I>&lt;text1&gt;</I>, ..., <I>&lt;textn&gt;</I> are strings. The result of the call is
the body &lt;text&gt; of the macro <I>M</I> in which all occurrences of the parameters
<I>Pi</I> have been syntactically substituted with the arguments <I>&lt;texti&gt;</I>, for all
i between 1 and n. For example, the following call: <P>
<PRE>    EU_A (true, not "SEND", &lt; "RECV" &gt; true)
</PRE><P>
expands into the formula below: <P>
<PRE>    mu X . ((&lt; "RECV" &gt; true) or ((true) and &lt; not "SEND" &gt; X))
</PRE><P>
A macro is visible from the point of its definition until the end of the
formula. Macros may be overloaded: several macros with the same name, but
different arities, may be defined in the same scope. <P>
Various macro-definitions
(typically encoding the operators of some particular temporal logic) can
be grouped into files called <I>libraries</I>. These files may be included in the
source program using the following command: <P>
  <PRE>    "library"
        &lt;file0.mcl&gt;"," ..."," &lt;filen.mcl&gt;
    "end_library"
</PRE>  <P>
At the compilation of the program, the above construct is syntactically
replaced with the contents of the files &lt;<I>file0</I><B>.mcl</B>&gt;, ..., &lt;<I>filen</I><B>.mcl</B>&gt;, placed one
after the other in this order. For example, the following command: <P>
<PRE>    library actl.mcl end_library
</PRE><P>
is syntactically replaced with the contents of the file <I>actl</I><B>.mcl,</B> which
implements the ACTL operators. <P>
The included files are searched first in
the current directory, then in the directory referenced by $CADP/src/xtl.
Multiple inclusions of the same file are silently discarded. 
<H2><A NAME="sect19" HREF="#sect19">Expressiveness</A></H2>
<I>MCL</I>
enables direct and succinct encodings of "pure" branching-time logics like
<I>CTL</I> (Computation Tree Logic) [CES86] or <I>ACTL</I> (Action-based CTL) [DV90],
as well as of regular logics like <I>PDL</I> (Propositional Dynamic Logic) [FL79]
or <I>PDL-delta</I> [Str82]. <P>
The infinite looping operator, whenever it is applied
to a regular subformula containing iteration operators, belongs to the
mu-calculus fragment of alternation depth two [EL86]. It is able to express
the existence of complex cycles (containing regular sub-sequences) in the
LTS, which cannot be expressed using the other operators of <I>MCL</I> because
they belong to the alternation-free fragment of the modal mu-calculus. In
particular, the infinite looping operator can express the existence of
accepting cycles in Bchi automata, which underlies the classical verification
procedure for <I>LTL</I> (Linear Time Logic) [CGP00]. <P>
Therefore, <I>MCL</I> strictly subsumes
both <I>CTL</I> and <I>LTL</I>, since these two logics are not comparable w.r.t. their expressive
power (each of them is able to express properties that the other one cannot).
<I>MCL</I> also syntactically subsumes <I>PDL-delta</I>, which was shown to be more expressive
than <I>CTL*</I> [Wol82]. <P>
When dealing with finite state LTS models, the presence
of data-handling constructs does not, strictly speaking, increase the expressiveness
of <I>MCL</I> because one can instantiate all parameters present in an <I>MCL</I> formula
based on the finite set of values contained in the transition labels of
the LTS. However, in practice the data-handling constructs lead to significant
simplifications and reductions in size of the formulas, thus facilitating
the specification activity and reducing the risk of errors. 
<H2><A NAME="sect20" HREF="#sect20">Model Checking
Complexity</A></H2>
The dataless part of <I>MCL</I> has an efficient on-the-fly model checking
algorithm, with a space and time complexity linear in the size of the formula
(number of operators) and the size of the LTS model (number of states and
transitions). Despite the fact that it belongs to the mu-calculus fragment
of alternation depth two (which has theoretically a quadratic-time model
checking complexity [EL86]), the infinite looping operator can be evaluated
in linear-time using the algorithm proposed in [MT08]. The evaluation of
<I>CTL</I> and <I>PDL-delta</I> operators, which cover the quasi-totality of practical
needs, stores in memory only the states, and not the transitions of the
LTS. <P>
Note: The linear-time model checking complexity obtained for <I>PDL-delta</I>
does not imply a similar result for <I>LTL</I> or <I>CTL*</I>, since the translations
of these logics in <I>PDL-delta</I> are not guaranteed to be succinct. <P>
The evaluation
of fixed points having parameters of infinite types (e.g., <B>nat</B>, <B>string</B>, etc.)
may diverge when the number of fixed point variable instances is unbounded.
Therefore, parameterized fixed points should be used with the same care
as recursive functions in programming languages (note however that cycles
<I>Y</I> (<I>v0</I>, ..., <I>vn</I>) -&gt; ... -&gt; <I>Y</I> (<I>v0</I>, ..., <I>vn</I>) do no harm, since BES resolution algorithms
can handle cyclic dependencies between variables). The evaluation of all
extended regular operators involving counters is guaranteed to converge,
because it always creates a finite number of fixed point variable instances,
bounded by the values of counters and/or the number of LTS states. 
<H2><A NAME="sect21" HREF="#sect21">Bibliography</A></H2>

<DL><DD><DL COMPACT>

<DT>[CES86]
</DT>
<DD>E. M. Clarke, E. A. Emerson, and A. P. Sistla. "Automatic Verification of Finite-State
Concurrent Systems using Temporal Logic Specifications." ACM Transactions
on Programming Languages and Systems, v. 8, no. 2, p. 244-263, 1986. </DD><P>

<DT>[CGP00]
</DT>
<DD>E. M. Clarke, O. Grumberg, and D. Peled. "Model Checking." MIT Press, 2000. </DD><P>

<DT>[DV90]
</DT>
<DD>R. De Nicola and F. W. Vaandrager. "Action versus State based Logics for Transition
Systems." Proceedings Ecole de Printemps on Semantics of Concurrency, LNCS
v. 469, p. 407-419, 1990. </DD><P>

<DT>[EL86] </DT>
<DD>E. A. Emerson and C-L. Lei. "Efficient Model Checking
in Fragments of the Propositional Mu-Calculus." Proceedings of the 1st LICS,
p. 267-278, 1986. </DD><P>

<DT>[FL79] </DT>
<DD>M. J. Fischer and R. E. Ladner. "Propositional Dynamic
Logic of Regular Programs." Journal of Computer and System Sciences, no.
18, p. 194-211, 1979. </DD><P>

<DT>[Gar89] </DT>
<DD>H. Garavel.  Chapter 9 of "Compilation et verification
de programmes LOTOS." PhD thesis, Universite Joseph-Fourier Grenoble, 1989.
Available from <A HREF="http://cadp.inria.fr/publications/Garavel-89-b.html">http://cadp.inria.fr/publications/Garavel-89-b.html</A>
 </DD><P>

<DT>[Koz83] </DT>
<DD>D.
Kozen. "Results on the Propositional Mu-Calculus." Theoretical Computer Science,
v. 27, p. 333-354, 1983. </DD><P>

<DT>[Mat98a] </DT>
<DD>R. Mateescu. "Verification des proprietes temporelles
des programmes paralleles." PhD Thesis, Institut National Polytechnique
de Grenoble, April 1998. Available from <A HREF="http://cadp.inria.fr/publications/Mateescu-98-a.html">http://cadp.inria.fr/publications/Mateescu-98-a.html</A>

</DD><P>

<DT>[Mat98b] </DT>
<DD>R. Mateescu. "Local Model-Checking of an Alternation-Free Value-Based
Modal Mu-Calculus." Proceedings of the 2nd International Workshop on Verification,
Model Checking and Abstract Interpretation VMCAI'98, 1998. Available from
<A HREF="http://cadp.inria.fr/publications/Mateescu-98-b.html">http://cadp.inria.fr/publications/Mateescu-98-b.html</A>
 </DD><P>

<DT>[Mat02] </DT>
<DD>R. Mateescu. "Local
Model-Checking of Modal Mu-Calculus on Acyclic Labeled Transition Systems".
Proceedings of the 8th International Conference on Tools and Algorithms
for the Construction and Analysis of Systems TACAS'02, LNCS v. 2280, p. 281-295,
2002. Full version available as INRIA Research Report RR-4430. Available from
<A HREF="http://cadp.inria.fr/publications/Mateescu-02.html">http://cadp.inria.fr/publications/Mateescu-02.html</A>
 </DD><P>

<DT>[Mat06] </DT>
<DD>R. Mateescu. "CAESAR_SOLVE:
A Generic Library for On-the-Fly Resolution of Alternation-Free Boolean Equation
Systems." Springer International Journal on Software Tools for Technology
Transfer (STTT), v. 8, no. 1, p. 37-56, 2006. Full version available as INRIA
Research Report RR-5948. Available from <A HREF="http://cadp.inria.fr/publications/Mateescu-06-a.html">http://cadp.inria.fr/publications/Mateescu-06-a.html</A>

</DD><P>

<DT>[MS03] </DT>
<DD>R. Mateescu and M. Sighireanu. "Efficient On-the-Fly Model-Checking for
Regular Alternation-Free Mu-Calculus." Science of Computer Programming, v.
46, no. 3, p. 255-281, 2003. Available from <A HREF="http://cadp.inria.fr/publications/Mateescu-Sighireanu-03.html">http://cadp.inria.fr/publications/Mateescu-Sighireanu-03.html</A>

</DD><P>

<DT>[MS10] </DT>
<DD>R. Mateescu and W. Serwe. "A Study of Shared-Memory Mutual Exclusion
Protocols using CADP." Proceedings of the 15th International Workshop on
Formal Methods for Industrial Critical Systems FMICS'10, LNCS v. 6371, p.
180-197, 2010. Available from <A HREF="http://cadp.inria.fr/publications/Mateescu-Serwe-10.html">http://cadp.inria.fr/publications/Mateescu-Serwe-10.html</A>

</DD><P>

<DT>[MT08] </DT>
<DD>R. Mateescu and D. Thivolle. "A Model Checking Language for Concurrent
Value-Passing Systems." Proceedings of the 15th International Symposium on
Formal Methods FM'08, LNCS v. 5014, p. 148-164, 2008. Available from <A HREF="http://cadp.inria.fr/publications/Mateescu-Thivolle-08.html">http://cadp.inria.fr/publications/Mateescu-Thivolle-08.html</A>

</DD><P>

<DT>[QS83] </DT>
<DD>J-P. Queille and J. Sifakis. "Fairness and Related Properties in Transition
Systems - A Temporal Logic to Deal with Fairness." Acta Informatica, v. 19,
p. 195-220, 1983. </DD><P>

<DT>[Str82] </DT>
<DD>R. S. Streett. "Propositional Dynamic Logic of Looping
and Converse." Information and Control, v. 54, p. 121-141, 1982. </DD><P>

<DT>[Wol82] </DT>
<DD>P. Wolper.
"A Translation from Full Branching Time Temporal Logic to One Letter Propositional
Dynamic Logic with Looping." Unpublished manuscript, 1982. </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect22" HREF="#sect22">See Also</A></H2>
<A HREF="evaluator.html"><B>evaluator</B></A>
,
<A HREF="evaluator3.html"><B>evaluator3</B></A>
, <A HREF="evaluator4.html"><B>evaluator4</B></A>
, <A HREF="mcl.html"><B>mcl</B></A>
, <A HREF="mcl3.html"><B>mcl3</B></A>
, <A HREF="regexp.html"><B>regexp</B></A>

<P>
Additional information is available from the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>

<P>
Directives for installation are given in files <B>$CADP/INSTALLATION_*</B>. <P>
Recent
changes and improvements to this software are reported and commented in
file <B>$CADP/HISTORY</B>. 
<H2><A NAME="sect23" HREF="#sect23">Bugs</A></H2>
Please report bugs to <A HREF="mailto:Radu.Mateescu@inria.fr?Subject=CADP-Bug-Report">Radu.Mateescu@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Description</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Lexical Elements</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Types, Functions and Constants</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Expressions</A></LI>
<LI><A NAME="toc5" HREF="#sect5">Declarations</A></LI>
<LI><A NAME="toc6" HREF="#sect6">Patterns</A></LI>
<LI><A NAME="toc7" HREF="#sect7">Offers</A></LI>
<LI><A NAME="toc8" HREF="#sect8">Action Patterns</A></LI>
<LI><A NAME="toc9" HREF="#sect9">Action Formulas</A></LI>
<LI><A NAME="toc10" HREF="#sect10">Regular Formulas</A></LI>
<LI><A NAME="toc11" HREF="#sect11">State Formulas</A></LI>
<LI><A NAME="toc12" HREF="#sect12">Remarks</A></LI>
<LI><A NAME="toc13" HREF="#sect13">Examples of Temporal Properties</A></LI>
<UL>
<LI><A NAME="toc14" HREF="#sect14">Safety Properties</A></LI>
<LI><A NAME="toc15" HREF="#sect15">Liveness Properties</A></LI>
<LI><A NAME="toc16" HREF="#sect16">Fairness Properties</A></LI>
<LI><A NAME="toc17" HREF="#sect17">Action Predicates</A></LI>
</UL>
<LI><A NAME="toc18" HREF="#sect18">Macros and Libraries</A></LI>
<LI><A NAME="toc19" HREF="#sect19">Expressiveness</A></LI>
<LI><A NAME="toc20" HREF="#sect20">Model Checking Complexity</A></LI>
<LI><A NAME="toc21" HREF="#sect21">Bibliography</A></LI>
<LI><A NAME="toc22" HREF="#sect22">See Also</A></LI>
<LI><A NAME="toc23" HREF="#sect23">Bugs</A></LI>
</UL>
</BODY></HTML>
