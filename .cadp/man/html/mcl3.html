 <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>MCL3 manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
mcl, MCL - Model Checking Language version 3 (regular alternation-free
mu-calculus) 
<H2><A NAME="sect1" HREF="#sect1">Description</A></H2>
This manual page presents the version 3 of <I>MCL</I> (<I>Model
Checking Language</I>),  which is the temporal logic accepted as input by <A HREF="evaluator3.html"><B>evaluator3</B></A>
.
<P>
This temporal logic is also known as "regular alternation-free mu-calculus".
A description of the regular alternation-free mu-calculus can be found in
the articles [MS03] and [Mat06], which also describe the verification methods
implemented in versions 3.0 and 3.5 of EVALUATOR, respectively. <P>
The regular
alternation-free mu-calculus is an extension of the alternation-free fragment
of the modal mu-calculus [Koz83, EL86] with action predicates and regular
expressions over action sequences. In this setting, action labels are merely
handled as character strings. <P>
Note: There exists an extended version of
this logic, able to express temporal properties involving data values;
see the <A HREF="mcl4.html"><B>mcl4</B></A>
 manual page for details. This extended version is supported
by <A HREF="evaluator4.html"><B>evaluator4</B></A>
 but not by <A HREF="evaluator3.html"><B>evaluator3</B></A>
. <P>
Regular alternation-free
mu-calculus allows direct encodings of "pure" branching-time logics like
<I>CTL</I> [CES86] or <I>ACTL</I> [DV90], as well as of regular logics like <I>PDL</I> [FL79]
or <I>PDL-delta</I> [Str82]. Moreover, it has an efficient model checking algorithm,
with a linear-time complexity in the size of the formula (number of operators)
and the size of the LTS model (number of states and transitions). The logic
is built from three types of formulas, indicated in the table below. <P>
  <PRE>               +--------+-----------------+
               | Symbol |   Description   |
               +--------+-----------------+
               |   A    | action formula  |
               |   R    | regular formula |
               |   F    | state formula   |
               +--------+-----------------+
</PRE>  <P>
The BNF syntax and the informal semantics of these formulas are defined
below. In the grammar, terminal symbols are written between double quotes.
The axiom of the grammar is the <CODE>F</CODE> symbol. <P>
Identifiers are built from letters,
digits, and underscores (beginning with a letter or an underscore). Keywords
must be written in lowercase. Comments are enclosed between '<CODE>(*</CODE>' and '<CODE>*)</CODE>'. Nested
comments are not allowed. <B>evaluator3</B> is case-sensitive. <P>
The formulas are interpreted
over an LTS <I>&lt;S, A, T, s0&gt;</I>, where: <I>S</I> is the set of <I>states</I>, <I>A</I> is the set of
<I>actions</I> (transition labels), <I>T</I> is the <I>transition relation</I> (a subset of
<I>S * A * S</I>), and <I>s0</I> is the <I>initial state</I>. A transition <I>(s1, a, s2)</I> of <I>T</I>,
also noted <I>s1-a-&gt;s2</I>, indicates that the program from which the LTS has been
generated can move from state <I>s1</I> to state <I>s2</I> by performing action <I>a</I>. 
<H2><A NAME="sect2" HREF="#sect2">Action
Formulas</A></H2>
An <I>action formula</I> is a logical formula built from basic action
predicates and boolean connectives, according to the grammar below: <P>
  <PRE>A<tt> </tt>&nbsp;<tt> </tt>&nbsp;::=  string
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   regexp
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "true"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "false"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "not" A
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   A1 "or" A2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   A1 "and" A2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   A1 "implies" A2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   A1 "equ" A2
</PRE>  <P>
A <I>string</I> is a sequence of zero or more characters, enclosed between double
quotes ('<CODE>"</CODE>'), which denotes a label of the LTS.  A string may contain any
character but '<CODE>\n</CODE>' (end-of-line). Double quotes are also allowed, if preceded
by a backslash ('<CODE>\</CODE>'). Strings can be concatenated using the binary operator
'<CODE>#</CODE>'. <P>
  <PRE>string ::= "(any char but end-of-line)*"
        |   string1 "#" string2
</PRE>  <P>
A transition label of the LTS satisfies a <I>string</I> iff it is identical
to the corresponding character string (obtained after concatenation whenever
needed). <P>
A <I>regexp</I> is a UNIX regular expression (see the <A HREF="regexp.html"><B>regexp</B></A>
 manual
page for a detailed description of UNIX regular expressions), enclosed
between single quotes ('<CODE>'</CODE>'), which denotes a predicate on the labels of the
LTS. Regexp's can be concatenated using the binary operator '<CODE>#</CODE>'. Strings  can
be concatenated to regexp's, in which case they are implicitly converted
into regexp's. <P>
  <PRE>regexp ::= 'UNIX_regular_expression'
        |   regexp1 "#" regexp2
        |   string1 "#" regexp2
        |   regexp1 "#" string2
</PRE>  <P>
A label of the LTS satisfies a <I>regexp</I> if it matches the corresponding
<I>UNIX_regular_expression</I> (obtained after concatenation whenever needed).
<P>
Syntactically, all binary operators on action formulas are left-associative.
The "<CODE>not</CODE>" operator has the highest precedence, followed by "<CODE>and</CODE>", followed
by "<CODE>or</CODE>", followed by "<CODE>implies</CODE>", followed by "<CODE>equ</CODE>". <P>
The boolean operators
have the usual semantics: a label of the LTS always satisfies "<CODE>true</CODE>"; it
never satisfies "<CODE>false</CODE>"; it satisfies "<CODE>not</CODE> <I>A</I>" iff it does not satisfy <I>A</I>;
it satisfies "<I>A1</I> <CODE>or</CODE> <I>A2</I>" iff it satisfies <I>A1</I> or it satisfies <I>A2</I>; it satisfies
"<I>A1</I> <CODE>and</CODE> <I>A2</I>" iff it satisfies both <I>A1</I> and <I>A2</I>; it satisfies "<I>A1</I> <CODE>implies</CODE> <I>A2</I>"
iff it does not satisfy <I>A1</I> or it satisfies <I>A2</I>; it satisfies "<I>A1</I> <CODE>equ</CODE> <I>A2</I>"
iff either it satisfies both <I>A1</I> and <I>A2</I>, or none of them. 
<H2><A NAME="sect3" HREF="#sect3">Regular Formulas</A></H2>
A
<I>regular formula</I> is a logical formula built from action formulas and the
traditional regular expression operators, according to the grammar below:
<P>
  <PRE>R ::=  A
   |   "nil"
   |   R1 "." R2
   |   R1 "|" R2
   |   R "?"
   |   R "*"
   |   R "+"
</PRE>  <P>
where "<CODE>nil</CODE>" is the empty operator, "<CODE>.</CODE>" is the concatenation operator,
"<CODE>|</CODE>" is the choice operator, "<CODE>?</CODE>" is the option operator, "<CODE>*</CODE>" is the transitive
and reflexive closure operator, and "<CODE>+</CODE>" is the transitive closure operator.
<P>
Syntactically, all binary operators on regular formulas are left-associative.
The "<CODE>?</CODE>", "<CODE>*</CODE>", and "<CODE>+</CODE>" operators have the highest precedence, followed by
"<CODE>.</CODE>", followed by "<CODE>|</CODE>". <P>
Note: In early versions of <A HREF="evaluator3.html"><B>evaluator3</B></A>
, the "<CODE>|</CODE>"
operator had a higher precedence than "<CODE>.</CODE>". To ensure that "old" MCL version
3 regular formulas are interpreted by the current version of <A HREF="evaluator3.html"><B>evaluator3</B></A>

according to their original intended meaning, it is recommended to add
parentheses at appropriate places. For example, an "old" MCL version 3 regular
formula "R1 | R2 . R3" should be rewritten as "(R1 | R2) . R3" to maintain
its original meaning, otherwise the current version of <A HREF="evaluator3.html"><B>evaluator3</B></A>

would parse it as "R1 | (R2 . R3)". <P>
A regular formula <I>R</I> denotes a sequence
of (consecutive) LTS transitions such that the word obtained by concatenating
their labels belongs to the regular language defined by <I>R</I>. <P>
The regular operators
have the following semantics: a sequence of LTS transitions satisfies <I>A</I>
iff it has the form <I>s1-a-&gt;s2</I>, where the label <I>a</I> satisfies the formula <I>A</I>; it
satisfies "<CODE>nil</CODE>" iff it is empty (i.e., it contains no transition); it satisfies
"<I>R1</I> <CODE>.</CODE> <I>R2</I>" iff it is the concatenation of two sequences satisfying <I>R1</I> and
<I>R2</I>, respectively; it satisfies "<I>R1</I> <CODE>|</CODE> <I>R2</I>" iff it satisfies <I>R1</I> or it satisfies
<I>R2</I>; it satisfies "<I>R</I> <CODE>?</CODE>" iff it is either empty, or it satisfies <I>R</I>; it satisfies
"<I>R</I> <CODE>*</CODE>" iff it is the concatenation of zero or more sequences satisfying
<I>R</I>; it satisfies "<I>R</I> <CODE>+</CODE>" iff it is the concatenation of one or more sequences
satisfying <I>R</I>. 
<H2><A NAME="sect4" HREF="#sect4">State Formulas</A></H2>
A <I>state formula</I> is a logical formula built from
boolean, modal, and fixed point operators, according to the grammar below:
<P>
  <PRE>F<tt> </tt>&nbsp;<tt> </tt>&nbsp;::=  "true"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "false"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "not" F
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   F1 "or" F2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   F1 "and" F2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   F1 "implies" F2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   F1 "equ" F2
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "&lt;" R "&gt;" F
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "[" R "]" F
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "&lt;" R "&gt;" "@"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "[" R "]" "-|"
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   X
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "mu" X "." F
<tt> </tt>&nbsp;<tt> </tt>&nbsp; |   "nu" X "." F
</PRE>  <P>
where "<CODE>&lt;</CODE> <I>R</I> <CODE>&gt;</CODE> <I>F</I>" and "<CODE>[</CODE> <I>R</I> <CODE>]</CODE> <I>F</I>" are the possibility and necessity modal operators,
"<CODE>&lt;</CODE> <I>R</I> <CODE>&gt;</CODE> <CODE>@</CODE>" is the infinite looping operator, "<CODE>[</CODE> <I>R</I> <CODE>]</CODE> <CODE>-|</CODE>" is the saturation operator,
"<CODE>mu</CODE> <I>X</I> <CODE>.</CODE> <I>F</I>" and "<CODE>nu</CODE> <I>X</I> <CODE>.</CODE> <I>F</I>" are the minimal and maximal fixed point operators,
and <I>X</I> is a <I>propositional variable</I>. <P>
Syntactically, all binary operators on
state formulas are left-associative. The "<CODE>not</CODE>", "<CODE>&lt; &gt;</CODE>", "<CODE>[ ]</CODE>", "<CODE>mu</CODE>", and "<CODE>nu</CODE>"
operators have the highest precedence, followed by "<CODE>and</CODE>", followed by "<CODE>or</CODE>",
followed by "<CODE>implies</CODE>", followed by "<CODE>equ</CODE>". The fixed point operators act
as binders for the variables <I>X</I> in a way similar to quantifiers in first-order
logic. In each meaningful "<CODE>mu</CODE> <I>X</I> <CODE>.</CODE> <I>F</I>" or "<CODE>nu</CODE> <I>X</I> <CODE>.</CODE> <I>F</I>" formula, <I>X</I> is supposed
to have free occurrences inside <I>F</I>. State formulas are assumed to be <I>syntactically
monotonic</I> (i.e., in each fixed point formula "<CODE>mu</CODE> <I>X</I> <CODE>.</CODE> <I>F</I>" or "<CODE>nu</CODE> <I>X</I> <CODE>.</CODE> <I>F</I>", free
occurrences of <I>X</I> in <I>F</I> may appear only under an even number of negations
and/or left-hand sides of implications) and <I>alternation-free</I> (i.e., without
mutually recursive minimal and maximal fixed point variables). <P>
The boolean
operators have the usual semantics: a state of the LTS always satisfies
"<CODE>true</CODE>"; it never satisfies "<CODE>false</CODE>"; it satisfies "<CODE>not</CODE> <I>F</I>" iff it does not
satisfy <I>F</I>; it satisfies "<I>F1</I> <CODE>or</CODE> <I>F2</I>" iff it satisfies <I>F1</I> or it satisfies
<I>F2</I>; it satisfies "<I>F1</I> <CODE>and</CODE> <I>F2</I>" iff it satisfies both <I>F1</I> and <I>F2</I>; it satisfies
"<I>F1</I> <CODE>implies</CODE> <I>F2</I>" iff it does not satisfy <I>F1</I> or it satisfies <I>F2</I>; it satisfies
"<I>F1</I> <CODE>equ</CODE> <I>F2</I>" iff either it satisfies both <I>F1</I> and <I>F2</I>, or none of them. <P>
The
modal operators have the following semantics: a state of the LTS satisfies
"<CODE>&lt;</CODE> <I>R</I> <CODE>&gt;</CODE> <I>F</I>" iff there is (at least) one transition sequence starting at the
state, satisfying <I>R</I>, and leading to a state satisfying <I>F</I>; it satisfies
"<CODE>[</CODE> <I>R</I> <CODE>]</CODE> <I>F</I>" iff all transition sequences starting at the state and satisfying
<I>R</I> are leading to states satisfying <I>F</I>. <P>
The infinite looping and saturation
operators have the following semantics: a state of the LTS satisfies "<CODE>&lt;</CODE>
<I>R</I> <CODE>&gt;</CODE> <CODE>@</CODE>" iff there is a transition sequence starting at the state and consisting
of an infinite concatenation of sequences satisfying <I>R</I>; it satisfies "<CODE>[</CODE>
<I>R</I> <CODE>]</CODE> <CODE>-|</CODE>" iff all transition sequences starting at the state and consisting
of a concatenation of sequences satisfying <I>R</I> are finite. <P>
The fixed point
operators have the following semantics: a state satisfies "<CODE>mu</CODE> <I>X</I> <CODE>.</CODE> <I>F</I>" iff
it belongs to the minimal solution of the fixed point equation <I>X</I> = <I>F</I> (<I>X</I>),
and it satisfies "<CODE>nu</CODE> <I>X</I> <CODE>.</CODE> <I>F</I>" iff it belongs to the maximal solution of the
same equation, where the propositional variable <I>X</I> denotes a set of LTS
states. Intuitively, minimal (resp. maximal) fixed point operators allow
to characterize finite (resp. infinite) tree-like patterns in the LTS. <P>
An
LTS satisfies a state formula <I>F</I> iff its initial state <I>s0</I> satisfies <I>F</I>. 
<DL><DD><DL COMPACT>

<DT>Note:
</DT>
<DD>When writing complex formulas containing many operators (especially when
mixing regular and boolean operators), it is safer to use parenthesis to
enclose subformulas whenever being in doubt about the relative priorities
of the operators. Otherwise, the tool may parse and evaluate the formulas
in a way different from the user's intentions, leading to erroneous results
that may be quite difficult to track down. </DD><P>

<DT>Note: </DT>
<DD>Not all operators defined
above are primitive constructs of the logic. The boolean operators "<CODE>false</CODE>",
"<CODE>and</CODE>", "<CODE>implies</CODE>", and "<CODE>equ</CODE>" can be expressed in terms of "<CODE>true</CODE>", "<CODE>or</CODE>",
and "<CODE>not</CODE>" in the usual way. The diamond and box modalities are dual: <PRE>    [ R ] F = not &lt; R &gt; not F
</PRE>The same holds for minimal and maximal fixed point operators: <PRE>    nu X . F = not mu X . not F (not X)
</PRE>where <I>F</I> <CODE>(not</CODE> <I>X</I><CODE>)</CODE> denotes the syntactic substitution of <I>X</I> by <CODE>not</CODE> <I>X</I> in <I>F</I>. The
saturation operator is the negation of the infinite looping operator: <PRE>    [ R ] -| = not &lt; R &gt; @
</PRE>The modalities containing regular formulas can be translated in terms of
boolean operators, fixed point operators, and modalities containing only
action formulas, by recursively applying the identities below:   <PRE>    &lt; nil &gt; F = &lt; false* &gt; F
    &lt; R1 . R2 &gt; F = &lt; R1 &gt; &lt; R2 &gt; F
    &lt; R1 | R2 &gt; F = &lt; R1 &gt; F or &lt; R2 &gt; F
    &lt; R? &gt; F = &lt; nil | R &gt; F
    &lt; R* &gt; F = mu X . (F or &lt; R &gt; X)
    &lt; R+ &gt; F = &lt; R . R* &gt; F
</PRE>  where <I>X</I> is a "fresh" propositional variable (the corresponding identities
for box modalities are obtained by duality). The infinite looping operator
is equivalent to the maximal fixed point formula below: <PRE>    &lt; R &gt; @ = nu X . &lt; R &gt; X
</PRE>where <I>X</I> is a "fresh" propositional variable. </DD><P>

<DT>Note: </DT>
<DD>Early versions of <A HREF="evaluator3.html"><B>evaluator3</B></A>

accepted only alternation-free formulas, meaning that infinite looping operators
"<CODE>&lt;</CODE> <I>R</I> <CODE>&gt;</CODE> <CODE>@</CODE>" were not allowed to contain "<CODE>*</CODE>" or "<CODE>+</CODE>" operators in their regular
formulas <I>R</I>. The current version of <A HREF="evaluator3.html"><B>evaluator3</B></A>
 accepts regular formulas
with "<CODE>*</CODE>" or "<CODE>+</CODE>" in infinite looping operators, which are now able to characterize
complex cycles in the LTS (e.g., generalized Buchi accepting cycles). An example
of formula accepted by the current version of <A HREF="evaluator3.html"><B>evaluator3</B></A>
 but not
expressible in alternation-free mu-calculus is the following: <PRE>    &lt; true* . "A" &gt; @
</PRE>This formula is equivalent (by applying the identities above) to a fixed
point formula of alternation depth 2: <PRE>    nu X . mu Y . (&lt; "A" &gt; X or &lt; true &gt; Y)
</PRE>Although the mu-calculus fragment of alternation depth 2 has in general
a quadratic-time model checking complexity in the size of the LTS, the alternation
depth 2 formulas resulting from the translation of infinite looping operators
"<CODE>&lt;</CODE> <I>R</I> <CODE>&gt;</CODE> <CODE>@</CODE>" containing "<CODE>*</CODE>" or "<CODE>+</CODE>" operators in their regular formulas <I>R</I> have
a linear-time model checking complexity in the size of the LTS [MT08]. </DD><P>

<DT>Note:
</DT>
<DD>Early versions of <A HREF="evaluator3.html"><B>evaluator3</B></A>
 accepted the syntax "<CODE>@</CODE> <CODE>(</CODE> <I>R</I> <CODE>)</CODE>" for the
infinite looping operator. This syntax is now obsolete, but still accepted
by <A HREF="evaluator3.html"><B>evaluator3</B></A>
 for backward compatibility. It is recommended to use
the new syntax "<CODE>&lt;</CODE> <I>R</I> <CODE>&gt;</CODE> <CODE>@</CODE>", which is closer to the syntax of possibility modalities
and reflects more intuitively the existence of an infinite sequence, terminated
by a loop ("@") in a finite state LTS. </DD><P>
</DL></DD><P></DL>
<P>
A fixed point formula "<CODE>mu</CODE> <I>X</I> <CODE>.</CODE> <I>F</I>" or
"<CODE>nu</CODE> <I>X</I> <CODE>.</CODE> <I>F</I>" is <I>unguarded</I> [Koz83] if <I>F</I> contains at least one free occurrence
of <I>X</I> which is not preceded (not necessarily immediately) by a modality.
The evaluation of an unguarded formula on an LTS may yield a BES with cyclic
dependencies between variables even if the LTS is acyclic. <P>
A state formula
containing regular modalities with nested star operators may yield after
translation an unguarded mu-calculus formula. For example, in the following
formula: <PRE>    &lt; A1** . A2 &gt; true =
        mu X1 . (&lt; A2 &gt; true or mu X2 . (X1 or &lt; A1 &gt; X2)
</PRE>the free occurrence of <I>X1</I> is not preceded by any modality, and hence the
formula is unguarded. Unguarded occurrences of propositional variables can
always be eliminated from a mu-calculus formula, at the price of an increase
in size [Koz83,Mat02]. 
<H2><A NAME="sect5" HREF="#sect5">Examples of Temporal Properties</A></H2>
The regular alternation-free
mu-calculus allows to express concisely various interesting properties. The
most useful classes of temporal properties are illustrated below. 
<H3><A NAME="sect6" HREF="#sect6">Safety
Properties</A></H3>
Informally, a safety property expresses that "something bad never
happens". Typical safety properties are those forbidding "bad" execution
sequences in the LTS. These properties can be naturally expressed using
box modalities containing regular formulas. For instance, mutual exclusion
can be characterized by the following formula: <P>
<PRE>    [ true* . "OPEN !1" . (not "CLOSE !1")* . "OPEN !2" ] false
</PRE><P>
which states that every time process 1 enters its critical section (action
"OPEN !1"), it is impossible that process 2 also enters its critical section
(action "OPEN !2") before process 1 has left its critical section (action
"CLOSE !1"). <P>
Other typical safety properties are the <I>invariants</I>, expressing
that every state of the LTS satisfies some "good" property. For example,
deadlock freedom can be expressed by the formula below: <P>
<PRE>    [ true* ] &lt; true &gt; true
</PRE><P>
stating that every state has at least one successor. Alternately, this formula
may be expressed directly using a fixed point operator: <P>
<PRE>    nu X . (&lt; true &gt; true and [ true ] X)
</PRE><P>
but less concisely than by using a regular formula. 
<H3><A NAME="sect7" HREF="#sect7">Liveness Properties</A></H3>
Informally,
a liveness property expresses that "something good eventually happens".
Typical liveness properties are <I>potentiality</I> assertions (i.e., expressing
the reachability on a sequence) and <I>inevitability</I> assertions (i.e., expressing
the reachability on all sequences). <P>
Potentiality assertions can be directly
expressed using diamond modalities containing regular formulas. For instance,
the following formula: <P>
<PRE>    &lt; true* . "GET !0" &gt; true
</PRE><P>
states that there exists a sequence leading to a "GET !0" action after
performing zero or more transitions. Regular formulas allow to express succinctly
complex potentiality assertions, such as the formula below: <P>
<PRE>    &lt; true* . "SEND" . (true* . "ERROR")* . true* . "RECV" &gt; true
</PRE><P>
stating that there exists a sequence leading (after zero or more transitions)
to a "SEND" action, possibly followed by a sequence of "ERROR" actions
(possibly separated by other actions) and leading (after zero or more transitions)
to a "RECV" action. <P>
Inevitability assertions can be expressed using fixed
point operators. For instance, the following formula: <P>
<PRE>    mu X . (&lt; true &gt; true and [ not "START" ] X)
</PRE><P>
states that all transition sequences starting at the current state lead
to "START" actions after a finite number of steps. 
<H3><A NAME="sect8" HREF="#sect8">Fairness Properties</A></H3>
These
are similar to liveness properties, except that they express reachability
of actions by considering only <I>fair</I> execution sequences. One notion of fairness
that can be easily encoded in the logic is the "fair reachability of predicates"
defined by Queille and Sifakis [QS83]: a sequence is fair iff it does not
infinitely often enable the reachability of a certain state without infinitely
often reaching it. For instance, the following formula expresses that after
every message emission (action "SEND"), all fair execution sequences will
lead to the reception of the message (action "RECV") after a finite number
of steps: <P>
 <PRE>    [ true* . "SEND" . (not "RECV")* ]
    &lt; (not "RECV")* . "RECV" &gt; true
</PRE> <P>
Intuitively, the formula above considers the sequences following the "SEND"
action by "skipping" the cycles of the LTS that do not contain "RECV" actions:
it states that from every state of such a cycle, there is still a finite
sequence leading to a "RECV" action. 
<H3><A NAME="sect9" HREF="#sect9">Action Predicates</A></H3>
The use of action
formulas (and, in particular, of regexp's) may be of  considerable help
when dealing with LOTOS actions having the same gate  but different values
in the offers. For instance, the following formula: <P>
 <PRE>    &lt; true* . 'SEND !1.*' and not 'SEND !1.*!2' &gt; true
</PRE> <P>
states the potential reachability of an action having the gate SEND and
the value of the first offer equal to 1, possibly followed by other offers
with values different from 2. Moreover, action formulas combined with modalities
allow to express invariants over actions (i.e., action formulas that must
be satisfied by all transition labels of the LTS). For instance, the following
formula: <P>
 <PRE>    [ true* .
      not ('RECV !.* !.*' and 'RECV !\(.*\) !\1')
    ] false
</PRE> <P>
states that all message receptions (actions "RECV !source !dest") have
different source and destination fields. The UNIX regular expression construct
`<CODE>\( \)</CODE>' enables to match a portion of a string and to re-use it later in the
same regexp. 
<DL><DD><DL COMPACT>

<DT>Note: </DT>
<DD>For efficiency reasons, when using fixed point operators,
it is recommended to put the recursive call of the propositional variable
at the rightmost place in the formula (as in all fixed point formulas shown
above). This reduces both the evaluation time and the size of the diagnostic
generated for the formula. </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect10" HREF="#sect10">Macros and Libraries</A></H2>
<I>evaluator3</I> allows to define
and use macros for temporal operators parameterized by action and/or state
formulas. This feature is particularly useful for constructing reusable
libraries encoding various temporal operators of other logics translatable
in regular alternation-free mu-calculus (like CTL and ACTL). The <I>macro-definitions</I>
have the following syntax: <P>
 <PRE>    "macro" M "(" P1"," ..."," Pn ")" "="
        &lt;text&gt;
    "end_macro"
</PRE> <P>
The above construct defines a macro <I>M</I> having the parameters <I>P1</I>, ..., <I>Pn</I> and
the body <I>&lt;text&gt;</I>, which is a string of alpha-numeric characters (normally)
containing occurrences of the parameters <I>P1</I>, ..., <I>Pn</I>. For example, the following
macro-definition: <P>
  <PRE>    macro EU_A (F1, A, F2) = 
        mu X . ((F2) or ((F1) and &lt; A &gt; X))
    end_macro
</PRE>  <P>
encodes the "Exists Until" operator of ACTL, which states that there
exists a sequence of transitions leading to a state satisfying F2 such
that all intermediate states satisfy F1 and all intermediate labels satisfy
A. <P>
The calls of a macro <I>M</I> have the following form: <P>
<PRE>    M "(" &lt;text1&gt;"," ..."," &lt;textn&gt; ")"
</PRE><P>
where the arguments <I>&lt;text1&gt;</I>, ..., <I>&lt;textn&gt;</I> are strings. The result of the call is
the body &lt;text&gt; of the macro <I>M</I> in which all occurrences of the parameters
<I>Pi</I> have been syntactically substituted with the arguments <I>&lt;texti&gt;</I>, for all
i between 1 and n. For example, the following call: <P>
<PRE>    EU_A (true, not "SEND", &lt; "RECV" &gt; true)
</PRE><P>
expands into the formula below: <P>
<PRE>    mu X . ((&lt; "RECV" &gt; true) or ((true) and &lt; not "SEND" &gt; X))
</PRE><P>
A macro is visible from the point of its definition until the end of the
program. The macros may be overloaded: several macros with the same name,
but different arities, may be defined in the same scope. <P>
Various macro-definitions
(typically encoding the operators of some particular temporal logic) can
be grouped into files called <I>libraries</I>. These files may be included in the
source program using the following command: <P>
  <PRE>    "library"
        &lt;file0.mcl&gt;"," ..."," &lt;filen.mcl&gt;
    "end_library"
</PRE>  <P>
At the compilation of the program, the above construct is syntactically
replaced with the contents of the files &lt;<I>file0</I><B>.mcl</B>&gt;, ..., &lt;<I>filen</I><B>.mcl</B>&gt;, placed one
after the other in this order. For example, the following command: <P>
<PRE>    library actl.mcl end_library
</PRE><P>
is syntactically replaced with the content of the file <I>actl</I><B>.mcl,</B> which implements
the ACTL operators. <P>
The included files are searched first in the current
directory, then in the directory referenced by $CADP/src/xtl. Multiple inclusions
of the same file are silently discarded. 
<H2><A NAME="sect11" HREF="#sect11">Bibliography</A></H2>

<DL><DD><DL COMPACT>

<DT>[CES86] </DT>
<DD>E. M. Clarke,
E. A. Emerson, and A. P. Sistla. "Automatic Verification of Finite-State Concurrent
Systems using Temporal Logic Specifications". ACM Transactions on Programming
Languages and Systems, v. 8, no. 2, p. 244-263, 1986. </DD><P>

<DT>[DV90] </DT>
<DD>R. De Nicola and
F. W. Vaandrager. "Action versus State based Logics for Transition Systems".
Proceedings Ecole de Printemps on Semantics of Concurrency, LNCS v. 469,
p. 407-419, 1990. </DD><P>

<DT>[EL86] </DT>
<DD>E. A. Emerson and C-L. Lei. "Efficient Model Checking
in Fragments of the Propositional Mu-Calculus". Proceedings of the 1st LICS,
p. 267-278, 1986. </DD><P>

<DT>[FL79] </DT>
<DD>M. J. Fischer and R. E. Ladner. "Propositional Dynamic
Logic of Regular Programs". Journal of Computer and System Sciences, no.
18, p. 194-211, 1979. </DD><P>

<DT>[Koz83] </DT>
<DD>D. Kozen. "Results on the Propositional Mu-Calculus".
Theoretical Computer Science, v. 27, p. 333-354, 1983. </DD><P>

<DT>[Mat98] </DT>
<DD>R. Mateescu. "Verification
des proprietes temporelles des programmes paralleles". PhD Thesis, Institut
National Polytechnique de Grenoble, April 1998. Available from <A HREF="http://cadp.inria.fr/publications/Mateescu-98-a.html">http://cadp.inria.fr/publications/Mateescu-98-a.html</A>

</DD><P>

<DT>[Mat02] </DT>
<DD>R. Mateescu. "Local Model-Checking of Modal Mu-Calculus on Acyclic
Labeled Transition Systems". Proceedings of TACAS'02, LNCS v. 2280, p. 281-295,
2002. Full version available as INRIA Research Report RR-4430. Available from
<A HREF="http://cadp.inria.fr/publications/Mateescu-02.html">http://cadp.inria.fr/publications/Mateescu-02.html</A>
 </DD><P>

<DT>[Mat06] </DT>
<DD>R. Mateescu. "CAESAR_SOLVE:
A Generic Library for On-the-Fly Resolution of Alternation-Free Boolean Equation
Systems". Springer International Journal on Software Tools for Technology
Transfer (STTT), v. 8, no. 1, p. 37-56, 2006. Full version available as INRIA
Research Report RR-5948. Available from <A HREF="http://cadp.inria.fr/publications/Mateescu-06-a.html">http://cadp.inria.fr/publications/Mateescu-06-a.html</A>

</DD><P>

<DT>[MS03] </DT>
<DD>R. Mateescu and M. Sighireanu. "Efficient On-the-Fly Model-Checking for
Regular Alternation-Free Mu-Calculus". Science of Computer Programming, v.
46, no. 3, p. 255-281, 2003. Available from <A HREF="http://cadp.inria.fr/publications/Mateescu-Sighireanu-03.html">http://cadp.inria.fr/publications/Mateescu-Sighireanu-03.html</A>

</DD><P>

<DT>[MT08] </DT>
<DD>R. Mateescu and D. Thivolle. "A Model Checking Language for Concurrent
Value-Passing Systems". Proceedings of the 15th International Symposium on
Formal Methods FM'08, LNCS v. 5014, p. 148-164, 2008. Available from <A HREF="http://cadp.inria.fr/publications/Mateescu-Thivolle-08.html">http://cadp.inria.fr/publications/Mateescu-Thivolle-08.html</A>

</DD><P>

<DT>[QS83] </DT>
<DD>J-P. Queille and J. Sifakis. "Fairness and Related Properties in Transition
Systems - A Temporal Logic to Deal with Fairness". Acta Informatica, v. 19,
p. 195-220, 1983. </DD><P>

<DT>[Str82] </DT>
<DD>R. S. Streett. "Propositional Dynamic Logic of Looping
and Converse". Information and Control, v. 54, p. 121-141, 1982. </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect12" HREF="#sect12">See Also</A></H2>
<A HREF="evaluator.html"><B>evaluator</B></A>
,
<A HREF="evaluator3.html"><B>evaluator3</B></A>
, <A HREF="evaluator4.html"><B>evaluator4</B></A>
, <A HREF="mcl.html"><B>mcl</B></A>
, <A HREF="mcl4.html"><B>mcl4</B></A>
, <A HREF="regexp.html"><B>regexp</B></A>

<P>
Additional information is available from the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>

<P>
Directives for installation are given in files <B>$CADP/INSTALLATION_*</B>. <P>
Recent
changes and improvements to this software are reported and commented in
file <B>$CADP/HISTORY</B>. 
<H2><A NAME="sect13" HREF="#sect13">Bugs</A></H2>
Please report bugs to <A HREF="mailto:Radu.Mateescu@inria.fr?Subject=CADP-Bug-Report">Radu.Mateescu@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Description</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Action Formulas</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Regular Formulas</A></LI>
<LI><A NAME="toc4" HREF="#sect4">State Formulas</A></LI>
<LI><A NAME="toc5" HREF="#sect5">Examples of Temporal Properties</A></LI>
<UL>
<LI><A NAME="toc6" HREF="#sect6">Safety Properties</A></LI>
<LI><A NAME="toc7" HREF="#sect7">Liveness Properties</A></LI>
<LI><A NAME="toc8" HREF="#sect8">Fairness Properties</A></LI>
<LI><A NAME="toc9" HREF="#sect9">Action Predicates</A></LI>
</UL>
<LI><A NAME="toc10" HREF="#sect10">Macros and Libraries</A></LI>
<LI><A NAME="toc11" HREF="#sect11">Bibliography</A></LI>
<LI><A NAME="toc12" HREF="#sect12">See Also</A></LI>
<LI><A NAME="toc13" HREF="#sect13">Bugs</A></LI>
</UL>
</BODY></HTML>
