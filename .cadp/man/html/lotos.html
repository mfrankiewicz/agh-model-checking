 <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>LOTOS manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
lotos, LOTOS - Language of Temporal Ordering Specification 
<H2><A NAME="sect1" HREF="#sect1">Description</A></H2>
LOTOS
[BB88] is a formal specification language to describe communication protocols
and distributed systems. It has been standardized by ISO/IEC in  1989 [ISO89].
The design of LOTOS was motivated by the need for a language  with a high
abstraction level and strong mathematical bases that would allow  complex
systems to be described precisely and unambiguously, then analyzed  using
formal methods supported by appropriate software tools. LOTOS features two
clearly separated parts: 
<UL>
<LI type=disc>The <I>data part</I> of LOTOS, intended to describe data
structures, is based  on the theory of abstract data types and algebraic
specifications (especially the ActOne language defined by Ehrig and Mahr).
In this approach, data structures are described by LOTOS <I>sorts</I>, which represent
value domains,  and LOTOS <I>operations</I>, which are mathematical functions
defined on these  domains. The meaning of operations is defined by algebraic
<I>equations</I>.  Value expressions are strongly-typed algebraic terms built from
variables and operations. Sorts, operations, and equations are grouped in
modules called  <I>types</I>, which can be combined together using importation
(with multiple inheritance), renaming, parametrization, and actualization.
The underlying semantics is that of initial algebras. </LI><P><LI type=disc>The <I>control part</I> of
LOTOS is meant to describe the behaviour of concurrent processes that execute
simultaneously, synchronize, and communicate using message-passing rendezvous.
LOTOS is based on the process algebra approach for concurrency, and combines
the best features of Milner's CCS and Hoare's CSP process calculi. It relies
on a small set  of basic operators, which express primitive concepts such
as sequential composition, non-deterministic choice, guard, parallel composition,
rendezvous, etc. These operators are used to build <I>behaviour  expressions</I>,
which are algebraic terms that describe the behaviour of  concurrent systems,
complex behaviours being obtained by combining simpler  ones. The communication
ports for rendezvous are called <I>gates</I>. Any  behaviour expression can be
given a name and reused several times by enclosing it in a <I>process</I> definition.
 </LI><P>
</UL>
<P>
A comprehensive list of documents about the LOTOS language is available
 from <A HREF="http://cadp.inria.fr/tutorial">http://cadp.inria.fr/tutorial</A>
 <P>
The remainder of this page is devoted
to CADP-specific information about LOTOS. It gathers many technical details
that, so far, were only known by CADP experts. <P>
Note: LOTOS is a powerful
yet involved language. Today, new users who do not know LOTOS already may
prefer instead learning LNT (LOTOS New Technology), a modern language designed
to be a replacement for LOTOS, simpler to learn but equally expressive.
The present manual can yet be of interest to LNT users as well, since LNT
is currently implemented by translation to LOTOS. 
<H2><A NAME="sect2" HREF="#sect2">CADP Tools for LOTOS</A></H2>
The
CADP toolbox provides four main tools to handle LOTOS specifications: 
<UL>
<LI type=disc><A HREF="caesar.adt.html"><B>caesar.adt</B></A>

is a compiler for the data part of LOTOS. It translates LOTOS to C by generating
an implementation for all the sorts and operations defined in a  LOTOS
specification. </LI><P><LI type=disc><A HREF="caesar.html"><B>caesar</B></A>
 is a compiler for the control part of LOTOS.
It translates LOTOS to Petri nets, and then to C code that can be used
for, at least, three different purposes: (i) exhaustively explore all possible
behaviours and generate the  corresponding Labelled Transition System encoded
in <A HREF="aut.html"><B>aut</B></A>
 or <A HREF="bcg.html"><B>bcg</B></A>
 format; (ii) explore possible behaviours on
the fly by interfacing with the OPEN/CAESAR framework of CADP; (iii) connect
the LOTOS specification to its environment by interfacing with the EXEC/CAESAR
framework of CADP, e.g., to pilot an external device using the LOTOS specification
as a  controller. </LI><P><LI type=disc><A HREF="caesar.indent.html"><B>caesar.indent</B></A>
 is a pretty-printer that automatically
reformats and indents LOTOS  specifications. </LI><P><LI type=disc><A HREF="lotos.open.html"><B>lotos.open</B></A>
 is a tool
that allows running the OPEN/CAESAR application programs on LOTOS specifications.
This tool is actually a shell script that invokes <B>caesar.adt</B> and <B>caesar</B>.
</LI><P>
</UL>
<P>
For historical reasons, and because the data part and control part of LOTOS
are largely orthogonal, they are handled separately by the <B>caesar.adt</B>  and
<B>caesar</B> compilers, respectively. The landscape is however not so simple,
as close connections exist between both compilers: 
<UL>
<LI type=disc>Both compilers share
a common front-end, which performs lexical and syntactic analyses, abstract
tree construction, and static semantics checks (e.g., identifier binding,
type checking, etc.). After these common,  preliminary steps, each compiler
performs additional checks for either the  data or control part. </LI><P><LI type=disc>The <B>caesar</B>
compiler requires a <I>concrete</I> implementation in C for each <I>abstract</I> sort
and operation defined in the LOTOS  specification. Such an implementation
can be automatically generated  using <B>caesar.adt</B> or be manually written
by the user. <P>
In most cases, it is advised to let caesar.adt produce the C
code automatically, as the generated code will be both correct and, in
most  cases, highly efficient. For the most common classes of types (Booleans,
enumerated types, bounded integers, records, unions, lists, trees, bit
 vectors, etc.), caesar.adt will generate optimal code (according to model
checking demands, i.e., memory space first, then speed).  <P>
On the other hand,
manual writing gives full control on all implementation details and may
thus be preferred for particular data structures, such as floating-point
numbers, character strings, matrices, variable-length data  with special
encodings, etc. Manual writing also allows to reuse efficient  C or C++
code libraries that already exist and can be imported in a LOTOS  specification
just by redeclaring their interface in the form of LOTOS  abstract data
types. Manual writing also allows to define functions that can perform "short-circuits"
when evaluating their arguments (see the  section below on CALL-BY-NEED EVALUATION).
<P>
Both approaches can be combined, in the sense that certain LOTOS sorts
 and/or operations can be declared as <I>external</I> by the user and  implemented
manually; in such case, <B>caesar.adt</B> will only generate C  code for the non-external
sorts and/or operations, and will import the  C code implementing those
external sorts and/or operations. <P>
In any case, manual writing requires great
care in order to produce correct  implementations. There exist naming and
interfacing conventions (described below) that must be strictly respected.
Certain macro-definitions must be provided by the user to inform <B>caesar.adt</B>
about key properties of  the external sorts. Moreover, manually-written C
functions are not allowed to have side effects, except in a very limited
way (see the section below on SIDE EFFECTS for details). Examples of manually-written
C code for the standard LOTOS types declared in the "<CODE>$CADP/lib</CODE>" directory
(see files "<CODE>X_*.lib</CODE>") can be found in the "<CODE>$CADP/incl</CODE>" directory (see files
"<CODE>X_*.h</CODE>" and "<CODE>adt_*.h</CODE>"). </LI><P><LI type=disc>Yet, the C code generated by <B>caesar.adt</B> for LOTOS specifications
can  also be used in a standalone manner, independently from the <B>caesar</B>
 compiler. In this approach, LOTOS is only used as a higher-level language
 for describing data structures with their related operations, from  which
<B>caesar.adt</B> produces lower-level C code. <P>
This idea has been applied in two
large projects: the development  of <B>caesar.adt</B> (version 4.0 and higher),
most of which is written  in LOTOS data types and which bootstraps itself,
and the development of the <A HREF="xtl.html"><B>xtl</B></A>
 compiler, the largest part of which
consists of LOTOS code too. </LI><P><LI type=disc>Note that both <B>caesar</B> and <B>caesar.adt</B> take great
care to generate C code that does not cause warnings when given to C compilers
with demanding compiling options. So, if warnings are emitted while  compiling
some C code generated by the CADP tools, it is likely that  these warnings
have their origin in the LOTOS specification itself  (e.g., unused operations
or unused operation parameters) or in the  C code manually written by the
user. </LI><P>
</UL>

<H2><A NAME="sect3" HREF="#sect3">Tools Generating LOTOS Code</A></H2>
The CADP toolbox provides two tools that
produce LOTOS code: 
<UL>
<LI type=disc><A HREF="fsp2lotos.html"><B>fsp2lotos</B></A>
 takes specifications written in Magee
and Kramer's FSP (Finite State Processes) language and translates them into
LOTOS. </LI><P><LI type=disc><A HREF="lnt2lotos.html"><B>lnt2lotos</B></A>
 takes specifications written in LNT (LOTOS New Technology)
and translates them into LOTOS. </LI><P>
</UL>
<P>
Other tools have been developed, but not
distributed as part of CADP: 
<UL>
<LI type=disc><B>chp2lotos </B> takes specifications written in
Martin's CHP (Communicating Hardware Processes) and translate them into
LOTOS. See  <A HREF="http://cadp.inria.fr/software/05-b-chp2lotos.html">http://cadp.inria.fr/software/05-b-chp2lotos.html</A>
 for details. </LI><P><LI type=disc><B>flac</B>
takes models written in the FIACRE formalism and translates them into LOTOS.
See <A HREF="http://cadp.inria.fr/software/11-d-flac.html">http://cadp.inria.fr/software/11-d-flac.html</A>
 for details. </LI><P>
</UL>
<P>
Note: Following
the above remark that LOTOS is an involved language for humans, it is involved
for translators too. In practice, it is much easier to generate LNT code
rather than LOTOS code, and let the  <A HREF="lnt2lotos.html"><B>lnt2lotos</B></A>
 translator cope with
the intricacies of generating correct LOTOS code. 
<H2><A NAME="sect4" HREF="#sect4">Restrictions on the Data
Part of LOTOS</A></H2>
Abstract data types, as they exist in LOTOS, are a rather
unconstrained  formalism that is difficult to execute efficiently and from
which it is  difficult to generate executable code. To handle algebraic
specifications, there exist techniques based on rewriting or symbolic evaluation,
but they are often slow and memory-intensive. This is a major problem in
a  model-checking context, because state-space exploration is especially
demanding in terms of performance. <P>
Therefore, in order to enable the use
of <A HREF="caesar.adt.html"><B>caesar.adt</B></A>
 for translating LOTOS abstract data types into C code
automatically, the following restrictions have been set, which turn algebraic
specifications  into (more operational) term-rewrite systems with priorities
(see [Gar89c] and [GT93] for details). <P>
These restrictions also introduce
a suitable discipline in LOTOS, which, even if it is a strongly-typed language
and owns a system of modules,  remains poorly structured and hardly readable,
as sorts, operations, and  equations may appear in arbitrary order, with
no guarantee that operations  related to the same sort or equations related
to the same operation will  be gathered in the same module. 
<H3><A NAME="sect5" HREF="#sect5">Distinction
Between Constructors and Non-constructors</A></H3>
The user must split LOTOS operations
into two classes: the <I>constructors</I>, which are primitive operations, and
the <I>non-constructors</I>, which are non-primitive operations defined using equations.
To this aim, the user must explicitly indicate which operations are constructors
by attaching a special  comment to them (see below the section on SPECIAL
COMMENTS FOR OPERATIONS). <P>
The distinction enables LOTOS abstract data types
to be efficiently  implemented. However, this distinction does not exist
in the standard  definition of the language [ISO89], so that new constraints
on the syntax and static semantics must be added. 
<H3><A NAME="sect6" HREF="#sect6">Constraints on Equations</A></H3>
To
be accepted by <B>caesar.adt</B>, each equation must match the non-terminal symbol
E that is the axiom of the following BNF grammar: <PRE>   E ::= [ G, ..., G =&gt; ] F (P, ..., P) = V
   G ::= V | V = V
   P ::= X | C | P C P | C (P, ..., P) | P of S | (P)
   V ::= X | C | V C V | C (V, ..., V)
           | F | V F V | F (V, ..., V) | V of S | (V)
</PRE>where: 
<UL>
<LI type=disc>square brackets denote an optional element (here, premisses) </LI><P><LI type=disc>C is
a terminal symbol denoting a constructor identifier (either constant, infix
binary, or prefix) </LI><P><LI type=disc>E is a non-terminal symbol denoting a well-formed equation
</LI><P><LI type=disc>F is a terminal symbol denoting a non-constructor identifier (either constant,
infix binary, or prefix) </LI><P><LI type=disc>G is a non-terminal symbol denoting an equation
premiss (either a  Boolean guard or an equality test) </LI><P><LI type=disc>P is a non-terminal
symbol denoting a pattern (i.e., a value expression that does not contain
any non-constructor identifier) </LI><P><LI type=disc>S is a terminal symbol denoting a sort identifier
</LI><P><LI type=disc>V is a non-terminal symbol denoting a value expression </LI><P><LI type=disc>X is a terminal symbol
denoting a value identifier (i.e., a variable) </LI><P>
</UL>
<P>
Any variable occurring in
a guard G or in the right-hand side expression V must also occur in (at
least one of) the left-hand side patterns P. <P>
In such case, one says that
equation E <I>defines</I> the non-constructor F. <P>
All constructors must be <I>free</I>,
meaning that the above syntax does  not allow constructors to be defined
by equations. <P>
If a specification contains non-free constructors, it can be
transformed into an equivalent specification containing only free-constructors.
This can be done in a systematic way (see Section 1.7 of [Gar89c]). 
<H3><A NAME="sect7" HREF="#sect7">Constraints
on Sorts and Constructors</A></H3>

<UL>
<LI type=disc>If a sort <I>S</I> is not external, there must exist
at least one constructor returning a result of sort <I>S</I>. Otherwise, a compiler
warning will be emitted and <B>caesar.adt</B> will consider that <I>S</I> is implicitly
external, so that no C code will be generated to implement this sort. </LI><P><LI type=disc>If
a sort <I>S</I> is not external, then all the constructors returning a result
of sort <I>S</I> should be non-external operations. </LI><P><LI type=disc>If a sort <I>S</I> is external, then
all the constructors returning a result of sort <I>S</I> should be external operations.
</LI><P><LI type=disc>To enforce a modular specification style that LOTOS does not encourage
by default, each constructor returning a result of sort <I>S</I> should be  declared
in the same LOTOS type as <I>S</I>, or a compiler warning  will be emitted. </LI><P><LI type=disc>Each
sort <I>S</I> must be <I>productive</I>, i.e., there must exist at least one <I>ground term</I>
that is <I>well-typed</I> (a ground term being an an algebraic term that contains
only constructors, and neither free  variables nor non-constructors). For
instance, a sort <I>S</I> with only  one constructor defined as "<I>Succ</I> <CODE>:</CODE> <I>S</I> <CODE>-&gt;</CODE> <I>S</I>"
is unproductive (technically, its initial algebra is empty). </LI><P>
</UL>

<H3><A NAME="sect8" HREF="#sect8">Constraints
on Non-constructors and Equations</A></H3>

<UL>
<LI type=disc>If a non-constructor <I>F</I> is not external,
there should exist at least  one equation defining <I>F</I>. Otherwise, a compiler
warning will be emitted, and <B>caesar.adt</B> will consider that <I>F</I> is implicitly
external, so that no C code will be generated to implement this operation.
</LI><P><LI type=disc>If non-constructor <I>F</I> is external, then no equations should  define <I>F</I> (if
such equations have already been written, it is advised to preserve them
by commenting them out rather than simply deleting them). </LI><P><LI type=disc>To enforce a modular
specification style that LOTOS does not encourage by default, each equation
defining a non-constructor <I>F</I> should be  located in the same LOTOS type as
<I>F</I>, or a compiler warning will be emitted. </LI><P>
</UL>

<H3><A NAME="sect9" HREF="#sect9">Constraints on Renaming</A></H3>

<UL>
<LI type=disc>Sort renaming
is supported as follows. If a sort <I>S2</I> renames a  sort <I>S1</I>, then <B>caesar.adt</B>
generates no C code for implementing <I>S2</I>, and the CADP tools simply replace
all occurrences of <I>S2</I> by <I>S1</I> in the C code they generate, meaning that both
 sorts share the same implementation in C. </LI><P><LI type=disc>Consequently, it is forbidden
to define constructors that return a result of the renaming sort <I>S2</I>, meaning
that one cannot modify a renamed  sort by adding constructors to its renaming
sort(s). See item #903 in file  "<B>$CADP/HISTORY</B>" for details. </LI><P><LI type=disc>Operation renaming
is supported as follows. If an operation <I>F2</I>  renames an operation <I>F1</I>, then
<B>caesar.adt</B> generates no C code  for implementing <I>F2</I>, and the CADP tools
simply replace all occurrences of <I>F2</I> by <I>F1</I> in the C code they generate,
meaning that both  operations share the same implementation in C. </LI><P><LI type=disc>Consequently,
it is forbidden to write equations that define the result of the renaming
operation <I>F2</I>, meaning that one cannot modify a renamed non-constructor by
adding equations to its renaming operation(s). See item #2190 in file "<B>$CADP/HISTORY</B>"
for details. </LI><P>
</UL>

<H3><A NAME="sect10" HREF="#sect10">Constraints on Actualization</A></H3>

<UL>
<LI type=disc>Type actualization (i.e., on the
one hand, generic types parameterized by  formal sorts, formal operations,
and/or formal equations, and, on the other hand, actualized types obtained
by instantiating generic types) is supported  only in a partial way. The
CADP tools indeed parse and statically check such type definitions, but
<B>caesar.adt</B> later ignores them silently and generates no C code to implement
them.  </LI><P><LI type=disc>As a consequence, <B>caesar.adt</B> does not handle certain types of the
 LOTOS standard library (e.g., <I>Element</I> and <I>Set</I>). To address this limitation,
the user has to flatten actualized types manually by making a copy of parameterized
and substituting all formal elements by the corresponding actual ones. </LI><P>
</UL>

<H3><A NAME="sect11" HREF="#sect11">Rewrite
Strategy</A></H3>
The C code generated by <B>caesar.adt</B> for evaluating LOTOS value  expressions
uses a term-rewrite strategy that can be characterized  by the two following
rules: 
<DL><DD><DL COMPACT>

<DT><I>call-by-value</I> (or functional evaluation): </DT>
<DD>When several subterms can
be rewritten simultaneously, the innermost ones  are rewritten first. </DD><P>

<DT><I>decreasing
priority between equations</I>: </DT>
<DD>When, for a given subterm, several equations
apply simultaneously, the equation that occurs first in the LOTOS source
text is chosen. </DD><P>
</DL></DD><P></DL>
<P>
Notice that such strategy is not fully deterministic, since
it does not specify in which order subterms at the same nesting level (e.g.,
the various actual arguments of a function call) will be evaluated. The
decision is deferred to the C compiler, which may take advantage of such
degree of freedom to optimize machine-code generation. Therefore, the user
 should not expect leftmost subterms to be rewritten first. <P>
When needed,
the call-by-value strategy can be changed to a call-by-need  one by using external
functions and C macro-definitions (see the section below on CALL-BY-NEED EVALUATION).
<P>
With respect to the well-known theory of term-rewrite systems, the following
 remarks can be made: 
<DL><DD><DL COMPACT>

<DT>Completeness: </DT>
<DD>The issue of completeness arises when
there are <I>not enough</I> equations to define a non-constructor. For instance,
let <I>F</I> be a non-constructor defined by a single equation "<I>F</I> <B>(</B><I>true</I><B>)</B> = <I>true</I>";
the value "<I>F</I> <B>(</B><I>false</I><B>)</B>" remains undefined. In standard LOTOS, this value cannot
be reduced and is added to the initial algebra  of the <I>Bool</I> sort, thus
leading to Booleans having more than two values. This problem is avoided
in the CADP tools, as the C code generated  by <B>caesar.adt</B> raises a run-time
error when trying to evaluate a call to a non-constructor whose result is
not defined by any equation matching the values of the actual parameters
supplied with the call.  The <B>-debug</B> option of <B>caesar.adt</B> can be used to print
these values when a run-time error occurs. Therefore, <B>caesar.adt</B> extends LOTOS
with the concept of partially-defined functions, which are implemented using
(uncatchable) exceptions.  </DD><P>

<DT>Confluence: </DT>
<DD>The issue of confluence arises when
there are <I>too many</I> equations to define a non-constructor. For instance, let
<I>F</I> be a non-constructor  defined by the two following equations "<I>F</I> <B>(</B><I>x</I><B>)</B> =
<I>true</I>" and "<I>F</I> <B>(</B><I>x</I><B>)</B> = <I>x</I>"; the value "<I>F</I> <B>(</B><I>false</I><B>)</B>" can be rewritten either to
<I>true</I> or <I>false</I>. In standard LOTOS, such a definition of <I>F</I> implies that both
values <I>true</I> and <I>false</I> are equal, thus leading to Booleans having a single
value. This problem is avoided with the decreasing priority between equations
enforced by <B>caesar.adt</B>, which ensures that  the evaluation of value expressions
is deterministic. Moreover,  <B>caesar.adt</B> warns about equations that are never
used because they are overriden by equations of higher priority (note that,
when premisses are used, such detection of unused equations cannot be done
systematically). </DD><P>

<DT>Termination: </DT>
<DD>The LOTOS equations are expected to satisfy
the termination property,  but <B>caesar.adt</B> makes no attempt to check this
property (anyway, only sufficient conditions for termination could be checked).
If the  user writes non-terminating equations such as "<I>F</I> (<I>X</I>) <B>=</B> <I>F</I> (<I>X</I>)", the
generated C code will loop forever or cause a stack overflow when executed.
In such case,  the C debugger and/or the <B>-trace</B> option of <B>caesar.adt</B> can
be  used to understand the reason of the problem. </DD><P>
</DL></DD><P></DL>
<P>
In principle, if the LOTOS
equations are written to be confluent and  terminating, then all rewrite
strategies (including the one implemented  by <B>caesar.adt</B>) should produce
the same result when evaluating a given term. However, in the case of partially-defined
non-constructors, there will be a difference as <B>caesar.adt</B> will trigger a
run-time error. Moreover, seeking for confluent equations prevents from taking
advantage of priority between equations, i.e., from using the "if-then-else"
facility offered by priority, which often leads to shorter specifications
and more efficient implementations. A striking example of the benefits of
priority is the ability to define an equality operation <I>eq</I> for any sort
<I>S</I> using only two equations: <PRE>     forall x, y : S
     ofsort Bool
        x eq x = true ;
        x eq y = false
</PRE><P>
Examples of issues that may arise when adding new operations to existing
LOTOS sorts are given in Section 2.a of [Gar13]. 
<H2><A NAME="sect12" HREF="#sect12">Restrictions on the Control
Part of LOTOS</A></H2>
The CADP tools accept a very large class of LOTOS behaviour
expressions and process definitions: all behavioural operators are accepted
and value expressions are handled as well. However, there are a few restrictions
 dictated either by the need to produce finite-state transition systems,
 or by the efficiency of the translation algorithms. Some restrictions 
also depend on the kind of analysis performed (e.g.,exhaustive state-space
exploration vs sequential C code generation). 
<H3><A NAME="sect13" HREF="#sect13">Static-control Constraints</A></H3>
For
efficiency reasons (namely, to ensure that the interpreted Petri nets generated
by the translation have at most one token per place), the CADP tools lay
additional constraints on LOTOS behaviour expressions. Only a subset of
LOTOS behaviour expressions is accepted, those that satisfy the so-called
<I>static control</I> property: any recursive call  to a process is prohibited
if it occurs in any of the five following  contexts: 
<UL>
<LI type=disc>on the left- or on
the right-hand side of a parallel composition operator  ("<CODE>||</CODE>", "<CODE>|||</CODE>", "<CODE>|[</CODE>...<CODE>]|</CODE>") </LI><P><LI type=disc>through
a "<CODE>par</CODE>" operator </LI><P><LI type=disc>through a "<CODE>hide</CODE>" operator </LI><P><LI type=disc>on the left-hand side of a "<CODE>&gt;&gt;</CODE>"
(enable) operator </LI><P><LI type=disc>on the left-hand side of a "<CODE>[&gt;</CODE>" (disable) operator </LI><P>
</UL>
<P>
See
Section 3.1 of [Gar89b] for a formal definition of static control  constraints,
illustrated with detailed examples. Notice that a call  to a recursive process
is not necessarily a recursive process call (although the converse is true).
<P>
In practice, LOTOS specifications that do not satisfy these constraints
 often exhibit a non-regular behaviour and, thus, cannot be translated to
 finite-state transition systems. 
<H3><A NAME="sect14" HREF="#sect14">Finite-domain Constraints</A></H3>
The three following
LOTOS behaviour expressions require a nondeterministic  selection, in the
domain of sort <I>S</I>, of some value to be stored in variable <I>x</I>: 
<UL>
<LI type=disc>"<CODE>choice</CODE> <I>x</I><CODE>:</CODE><I>S</I>
<CODE>[]</CODE> ..." </LI><P><LI type=disc>"<CODE>exit (any</CODE> <I>S</I><CODE>)</CODE>" </LI><P><LI type=disc>"<I>G</I> <B>?</B><I>x</I><CODE>:</CODE><I>S</I> <CODE>;</CODE> ..." (provided that this  input action on the
visible gate <I>G</I> is not synchronized with an  ouput action "<I>G</I> <B>!</B><I>v</I> <CODE>;</CODE> ..." that
would impose value <I>v</I> to <I>x</I>). </LI><P>
</UL>
<P>
In general, to execute such behaviour expressions,
the CADP tools enumerate  all possible values in the domain of sort S and
try all possible execution paths, one for each value. That is, these tools
perform <I>concrete</I> rather than <I>symbolic</I> execution.  <P>
Enumerating the domain
of sort <I>S</I> is only possible if this domain is  finite or, in the case of
infinite sorts (such as lists, strings, trees,  etc.), if the enumeration
is restricted to a finite subset (e.g., only those lists whose length is
less than five). <P>
If the domain of sort <I>S</I> is infinite, or if it is so large
that  the user wants to restrict it to a smaller subset in order to avoid
 state-space explosion issues, or if <I>S</I> is an external sort, the user must
provide an <I>iterator</I> for sort S, i.e., a fragment of C code that enables a
variable <I>x</I> of sort <I>S</I> to enumerate all  possible values in the chosen subset.
<P>
If sort <I>S</I> is never used in any of the three kinds of behaviour  expressions
listed above, then no iterator for sort <I>S</I> is required,  as the domain of
<I>S</I> will not be enumerated. Thus, sorts with infinite or large domains are
perfectly accepted, as long as no attempt is made at enumerating their
domains. Notice also that, by default, <I>caesar.adt</I> automatically generates
iterators for all finite,  non-external sorts (and bounded iterators for
infinite, non-external sorts isomorphic to natural numbers). <P>
Notice that,
if a LOTOS specification satisfies the static-control property and the finite-domain
constraints for all its sorts that must be enumerated, then its labelled
transition system is necessarily finite. However, even  if finite in theory,
it may still be too large to be generated in practice. 
<H3><A NAME="sect15" HREF="#sect15">Closed-world Modelling</A></H3>
As
mentioned in the previous section, in the particular case of an input 
action "<I>G</I> <B>?</B><I>x</I><CODE>:</CODE><I>S</I> <CODE>;</CODE> ..."  not synchronized, on the visible gate <I>G</I>, with a corresponding
output action, the CADP tools will enumerate all possible values in the
domain of sort <I>S</I>. Such enumeration is indeed conformant with the operational
semantics of LOTOS, in which both terms "<I>G</I> <B>?</B><I>x</I><CODE>:</CODE><I>S</I> <CODE>;</CODE> <I>B</I>" and "<CODE>choice</CODE> <I>x</I><CODE>:</CODE><I>S</I> <CODE>[]</CODE>
<I>G</I> <B>!</B><I>x</I> <CODE>;</CODE> <I>B</I>" are equivalent modulo strong bisimulation. <P>
Note: in certain cases,
value enumeration could be avoided. For instance, the LOTOS terms "<I>G</I> <B>?</B><I>x</I><CODE>:</CODE><I>S</I>
<CODE>[</CODE><I>x</I><CODE>=</CODE><I>v</I><CODE>]</CODE>  <CODE>;</CODE> <I>B</I>" and  "<I>G</I> <B>?</B><I>x</I><CODE>:</CODE><I>S</I> <CODE>;</CODE>  <CODE>[</CODE><I>x</I><CODE>=</CODE><I>v</I><CODE>]</CODE> <CODE>-&gt;</CODE> <I>B</I>" are strongly equivalent to the term
"<I>G</I> <B>!</B><I>v</I> <CODE>;</CODE> <I>B</I>" and thus do not require enumerating all values in the domain
of  sort <I>S</I>. However, such optimizations are not yet implemented in the <B>caesar</B>
compiler.  <P>
To be precise, value enumeration only takes place when performing
exhaustive state-space exploration (namely, when using <B>caesar</B> to generate
a Labelled Transition System encoded, e.g., in the <A HREF="aut.html"><B>aut</B></A>
 or <A HREF="bcg.html"><B>bcg</B></A>

format), or when performing on-the-fly exploration using one of the tools
based upon the OPEN/CAESAR framework. However, when <B>caesar</B> is used to generate
C code that will be connected to a real environment using the EXEC/CAESAR
framework, such iteration does not take place and is replaced  by a call
to a so-called "gate function" that will actually input a value from the
real environment, rather than enumerating all possible values that could
be input. <P>
To restrict value enumeration on an infinite or excessively-large
sort domain, the definition (or redefinition) of an ad-hoc iterator (mentioned
in the  previous section) is sometimes non feasible, because it would affect
all other places in the LOTOS specification where this sort is used. In
such case, alternative techniques must be used. <P>
If the sort domain is finite
or isomorphic to natural numbers  (which <B>caesar.adt</B> implements using a finite
interval), the enumeration can be straightforwardly restricted by adding
a predicate to the input action,  i.e., "<I>G</I> <B>?</B><I>x</I><CODE>:</CODE><I>S</I>  <CODE>[</CODE><I>f</I>(<I>x</I>)<CODE>]</CODE> <CODE>;</CODE> ...", so that only
those values <I>v</I> satisfying <I>f</I>(<I>x</I>) will be selected. This may cause an overhead
in CPU time, but it is usually  negligible. <P>
Another technique to restrict
the enumeration is to synchonize each input action with one or many output
actions defining the possible values that  can be sent by the external
environment in which the LOTOS specification is evolving. This requires
to introduce, in the LOTOS specification, an extra process that runs in
parallel with the remainder of the specification and synchronizes on input
gates (at least). This added process describes scenarios of input (and possibly,
output) actions exchanged between the system described  by the LOTOS specification
and its environment. In model-checking terminology, a specification extended
with a model of the environment is often called a <I>closed-world</I> description,
as opposed to an <I>open-world</I> description, where no assumption is made about
the environment. In the LOTOS literature, using parallel composition as
a logical conjunction to specify  additional properties is known as a <I>constraint-oriented</I>
specification style. 
<H2><A NAME="sect16" HREF="#sect16">Other Extensions to LOTOS</A></H2>
For convenience, a few enhancements
to LOTOS have been implemented in the  CADP tools. These extensions deviate
from the standard definition of LOTOS  [ISO89] but they can be disabled
by giving the command-line option  "<B>-iso</B>", which enforces the standard definition
of LOTOS. These extensions are the following: 
<DL><DD><DL COMPACT>

<DT>1.</DT>
<DD>In standard LOTOS, "i" and
"I" are reserved keywords, which forbids to declare any identifier named
"i" or "I". The CADP tools relax this constraint by turning "i" and "I"
into reserved identifiers for gates only. This makes it possible to declare,
e.g., variables or operations named "i" or "I".  See item #1512 in file "<B>$CADP/HISTORY</B>"
for details. </DD><P>

<DT>2.</DT>
<DD>In standard LOTOS, the sorts of formal variable parameters
are not used to resolve overloading ambiguities in actual value expressions
of process instantiations. For instance, if a process P is declared with
a formal  variable parameter X of sort Nat, invoking this process with
the actual value zero requires to write "0 of Nat" rather than simply "0"
if sorts Nat  and Int both have a constant 0. To address this issue, the
CADP tools use extended type-checking rules that allow to write simply "0"
rather than  "0 of Nat", because the declaration of X is taken into account
to infer that 0 has sort Nat. See item #1803 in file "<B>$CADP/HISTORY</B>" for
details. </DD><P>

<DT>3.</DT>
<DD>In standard LOTOS, the sorts of the value parameters and exit
results of the  top-level specification must be declared in the section
of global definitions (located before the "behaviour" keyword). When this
section is empty, the CADP tools look into the local definitions (located
after the "behaviour" keyword) to find the declaration of these sorts. See
item #1875 in file "<B>$CADP/HISTORY</B>" for details. </DD><P>

<DT>4.</DT>
<DD>The CADP tools use a modified
semantics for flattening parameterized types, rather than the standard
(seemingly questionable) semantics of LOTOS. The modified semantics is described
in [GS95a]; in practice, however,  the differences between both semantics
should not matter too much, given  that parameterized types are not fully
implemented by the CADP tools. See item #346 in file "<B>$CADP/HISTORY</B>" for
details. </DD><P>

<DT>5.</DT>
<DD>The CADP tools recognize a special comment of the form "<CODE>(*! atomic
*)</CODE>" that, if present in a LOTOS specification (usually, after some "&gt;&gt;" operator),
removes all hidden transitions (labelled "<CODE>i</CODE>") created by the "&gt;&gt;" operators.
Such special comment is mostly used for the translation of LNT to LOTOS,
and purposedly deviates from the standard operational semantics of LOTOS
behaviour expressions.  See item #1327 in file "<B>$CADP/HISTORY</B>" for details.
</DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect17" HREF="#sect17">Other Deviations from the LOTOS Standard</A></H2>
This section lists a few minor
differences between the LOTOS standard [ISO89] and the way it is implemented
in the CADP tools: 
<UL>
<LI type=disc>In the labelled transition systems generated by the
CADP tools, the auxiliary gate used for sequential composition, which is
noted using the Greek letter "delta" in the standard semantics of LOTOS,
is noted  "<B>exit</B>" (always in lower case). This decision is justified by the
need to use Latin-alphabet letters only, by the fact that gate "delta" can
only be produced by the "<B>exit</B>" operator of LOTOS, and by the fact that
no user-defined gate can be named "<B>exit</B>" since this name is  a reserved
keyword of LOTOS (which is not the case of "delta"). </LI><P><LI type=disc>In the labelled transition
systems generated by the CADP tools, the invisible (or internal) gate,
which is usually noted using the Greek letter "tau" in the scientific literature,
is noted "<B>i</B>" (always in lower case). The standard  semantics of LOTOS also
uses the same "<B>i</B>" notation. </LI><P><LI type=disc>When a LOTOS specification is defined with formal
variable parameters, the standard semantics of LOTOS does not say much
on how these parameters should be handled. Certain LOTOS implementations
(e.g., the TOPO tool) reject such parameterized specifications. The CADP tools
(namely, <B>caesar</B>) also  reject them, unless the "<B>-root</B>" option is used to
provide actual value expressions that instantiate the formal variable parameters.
<P>
Note: Earlier versions of <B>caesar</B> handled formal variable parameters by
enumerating the domains of their respective sorts, but this is no longer
the case. See item #2014 in file "<B>$CADP/HISTORY</B>" for details. </LI><P><LI type=disc>The CADP tools
may differ from [ISO89] when handling process calls in which two (or more)
actual gate parameters are identical. For instance, the following behavior:
<PRE>      P [c, c]
   where
      process P [a, b] : noexit :=
         a ; stop || b ; stop
      endproc
</PRE>is strongly equivalent to "<CODE>stop</CODE>" according to the standard semantics of
 LOTOS, because the body of process <I>P</I> is evaluated <I>after</I> applying the gate
relabelling function that maps <I>a</I> to <I>c</I> and <I>b</I> to <I>c</I>. However, this behaviour
is equivalent to  "<I>c</I><CODE> ;</CODE> <CODE>stop</CODE>" according to the CADP tools because the  expansion
phase of <B>caesar</B> implements a <I>call-by-value</I> semantics  that applies the gate
relabelling function <I>before</I> evaluating the body  of <I>P</I>, which becomes therefore
 "<I>c</I><CODE> ;</CODE> <CODE>stop</CODE> <CODE>||</CODE> <I>c</I><CODE> ;</CODE> <CODE>stop</CODE>". Both semantics coincide in most cases, and may only
diverge if a process is called with identical actual gate parameters and
if some of the corresponding  formal gate parameters are synchronized together
in the body of the  process. <B>caesar</B> always emits a warning message if the
relabelling function is not injective; in the absence of such a warning,
the call-by-value semantics conforms to the standard LOTOS semantics. </LI><P>
</UL>
<P>
There
are a few other subtle differences, which should not matter to most  users:

<UL>
<LI type=disc>When declaring an infix operation "<CODE>_</CODE><I>F</I><CODE>_</CODE> <CODE>:</CODE> <I>S1</I>, ..., <I>Sn</I> <CODE>-&gt;</CODE> <I>S</I>", the standard syntax
of LOTOS allows spaces to be inserted between <I>F</I>  and its two surrounding
underscores (see <I>operator-descriptor</I> in Section 6.2.5 of [ISO89]). Such syntax
is difficult to parse; at the expense  of internal complexity, the CADP
tools parse it properly but do not check that  identifier <I>F</I> is not a reserved
keyword. Though it may be possible to  declare an infix operation whose
name is a keyword, any further occurrences  of this operation will be syntactically
rejected. </LI><P><LI type=disc>In Section 7.3.3 of [ISO89], it is acknowledged that the syntax
of LOTOS is ambiguous, as it does not allow to make the difference between
a variable (i.e., value identifier) and a nullary operation occuring in a
value expression. The disambiguation can only be done later using static
semantics  information, but the remainder of the section does not state
clearly how to bind an identifier <I>x</I> when both a variable and a nullary
operation exist  with both the same name <I>x</I> and both an appropriate sort.
<P>
The CADP tools proceed in two steps. First, they search whether a variable
 named <I>x</I> exists; if so, the identifier <I>x</I> is bound to this variable, whatever
the sort of the variable (a type-checking error will occur later if the
variable does not have the proper sort). Second, if no variable named <I>x</I>
exists, they perform operation binding and overloading resolution, which
will have the effect of binding the identifier to a  nullary operation
<I>x</I> if it exists with an appropriate sort. Thus, preference is always given
to variables over nullary operations, which seems compatible with the principle
of binding with the innermost operation definition when resolving operation
overloading. </LI><P><LI type=disc>In Section 7.3.4.5.e of [ISO89], requirement (e1) was strengthened
to state that, when the clause "<CODE>accept</CODE>...<CODE>in</CODE>" is missing, the behaviour expression
<I>B1</I> occurring in "<I>B1</I> <CODE>&gt;&gt;</CODE> <I>B2</I>" must have  the functionality "<I>exit</I>". </LI><P><LI type=disc>The decision
to implement the "<CODE>library</CODE>" declaration using file inclusion (see below
the section on LIBRARY FILES) leads to slightly different rules for the
visibility of identifiers declared in libraries.  </LI><P>
</UL>

<H2><A NAME="sect18" HREF="#sect18">Filenames</A></H2>
This section
describes the various files related to LOTOS specifications and their implementation.

<H3><A NAME="sect19" HREF="#sect19">LOTOS Files</A></H3>
The files containing LOTOS specifications should have a "<B>.lotos</B>"
suffix. This is the preferred convention when using CADP. However, to ease
the use of non-CADP tools, the alternative suffixes "<B>.lot</B>" and "<B>.l</B>" are also
tolerated, i.e., properly recognized by the CADP tools.  
<H3><A NAME="sect20" HREF="#sect20">Library Files</A></H3>
The
directive "<CODE>library</CODE> <I>f1</I>, ..., <I>fn</I> <CODE>endlib</CODE>" that is present in the standard LOTOS
definition [BB88] without explicit meaning is implemented using file inclusion
by the CADP tools, as follows: when such a clause is encountered, the CADP
tools look for files  named "<I>F1</I><B>.lib</B>", ..., "<I>Fn</I><B>.lib</B>" (where the  strings "<I>F1</I>,
..., <I>Fn</I>" are obtained from "<I>f1</I>, ..., <I>fn</I>" by turning lower-case letters to upper
case, since LOTOS identifiers are case insensitive whereas file names are
often case sensitive) and include  these files, in that order, at the place
where the directive "<CODE>library</CODE>" occurs (the directive itself is replaced
by the contents of the files). This is similar to the effect of a "<CODE>#include</CODE>"
directive with the C preprocessor. <P>
The "<B>.lib</B>" files are searched first in
the current directory, or else  in the <CODE>$CADP/lib</CODE> directory, which contains
a collection of predefined  LOTOS libraries. If a file cannot be found using
these search rules, a fatal  error is reported. More elaborate search rules
can be obtained by creating symbolic links to library files in the current
directory. <P>
Library inclusion can be transitive, meaning that "<B>.lib</B>" files
may contain "<CODE>library</CODE>" directives. Circular inclusions are  prohibited. <P>
Contrary
to the standard LOTOS definition [BB88], a "<CODE>library</CODE>" directive may occur
at any place (i.e., not only in data-type definitions) and may  contain arbitrary
LOTOS code fragments (e.g., process definitions, rather  than type definitions
only). These extensions help splitting large LOTOS specifications into several
files and enable one to develop reusable libraries of processes (e.g., buffers,
shared variables, etc.). 
<H3><A NAME="sect21" HREF="#sect21">Include Files</A></H3>
To be processed by the CADP tools,
a LOTOS specification contained in a  given file <I>filename</I><B>.lotos</B> should come
together with an  implementation (in the C language) of the LOTOS sorts
and operations. This implementation must be provided in a file named <I>filename</I><B>.h</B>
located in the current directory. <P>
This file can be either written by hand
or automatically generated using <A HREF="caesar.adt.html"><B>caesar.adt</B></A>
.<B></B> In the latter case, both
approaches can be combined, as the user may (optionally) provide two additional
files: 
<UL>
<LI type=disc>a file named <I>filename</I><B>.t</B> (where "<B>.t</B>" stands for "types")  that contains
manually-written C code for implementing certain LOTOS sorts, </LI><P><LI type=disc>a file named
<I>filename</I><B>.f</B> (where "<B>.f</B>" stands for "functions")  that contains manually-written
C code for implementing certain LOTOS operations. </LI><P>
</UL>
<P>
Each of these files, if
present in the current directory at the moment when <B>caesar.adt</B> is invoked,
will be #included in  the <I>filename</I><B>.h</B> file generated by <B>caesar.adt</B>. If both
files are present, <I>filename</I><B>.t</B> will be included before <I>filename</I><B>.f</B>. <P>
The motivation
behind the "<B>.t</B>" and "<B>.f</B>" files is to offer the possibility to introduce manually-written
C code for certain sorts and/or operations, and also to customize the C
code produced by <B>caesar.adt</B> without modifying the contents of the "<B>.h</B>" file
generated  by <B>caesar.adt</B>. <P>
In particular, the files "<CODE>$CADP/incl/X_*.h</CODE>", which
contain  manually-written C code to implement standard LOTOS types, should
be included (using a "<CODE>#include</CODE>" directive) in the "<B>.t</B>" file if the LOTOS
specification imports the corresponding types defined in "<CODE>$CADP/lib/X_*.lib</CODE>".
<P>
The CADP tools generate auxiliary C programs that include the "<B>.h</B>",  "<B>.t</B>",
and "<B>.f</B>" files, then compile these programs and execute them to obtain information
about the types defined in these files. To be more precise, <B>caesar.adt</B> compiles
only the "<B>.t</B>" file if it  exists, while <B>caesar</B> compiles only the "<B>.h</B>" file
if it exists (keeping in mind that, if the "<B>.h</B>" file has been generated
 using <B>caesar.adt</B>, it should include the "<B>.t</B>", and "<B>.f</B>" files if they were
present at the time <B>caesar.adt</B> was invoked). <P>
So doing, the CADP tools check
that the manually-written C code contained in these files is valid according
to the definition of the C language. However, the CADP tools cannot verify
whether this C code correctly implements the  intended meaning of the sorts
and operations defined in the LOTOS specification. In practice, such mistakes
can be difficult to detect.  When debugging such problems, one can safely
assume that the errors are in  the C code manually written by the user,
rather than in the C code generated  by the CADP tools. <P>
Notice that the
"<B>-external</B>" option of <B>caesar.adt</B> is helpful, as it generates, for the "<B>.t</B>",
and "<B>.f</B>" files, skeletons that  can be later filled in by the user. 
<H2><A NAME="sect22" HREF="#sect22">Tailored
Code Generation for Data Types</A></H2>
<B>caesar.adt</B> analyzes LOTOS sorts and their
constructors and recognizes  various classes of sorts that can be implemented
efficiently, if not optimally [Gar89c,GT93]. These classes are the following:

<DL><DD><DL COMPACT>

<DT><I>singleton sorts</I>: </DT>
<DD>They have only one element; such sorts often arise when
performing value abstraction, i.e., replacing a complex sort by a singleton.
</DD><P>

<DT><I>enumeration sorts</I>: </DT>
<DD>They correspond to the usual notion of enumerated types.
</DD><P>

<DT><I>numeral sorts</I>: </DT>
<DD>They correspond to the usual notion of (infinite) natural
numbers, which <B>caesar.adt</B> restricts to a finite range 0...(<I>n</I>-1). The value of
<I>n</I> is determined as follows: if the  macro <CODE>CAESAR_ADT_HASH_</CODE><I>N</I> is defined
in the "<B>.t</B>" file (see below the section on SPECIAL SYMBOLS for details),
then <I>n</I> is given by the value of this macro; else if <B>caesar.adt</B> is invoked
with option <B>-numeral</B>, then <I>n</I> is given by the integer value following this
option; otherwise <I>n</I> is set to 256 (meaning that, by default, values of
a numeral sort are stored using a single byte to avoid wasting memory during
state-space exploration). </DD><P>

<DT><I>tuple sorts</I>: </DT>
<DD>They correspond to the usual notion
of record types. </DD><P>

<DT><I>ordinary sorts</I>: </DT>
<DD>They correspond to the usual notion of
discriminated union types. </DD><P>
</DL></DD><P></DL>
<P>
Even when automatic code generation is used,
it is still possible to  instruct <B>caesar.adt</B> to adapt its C code generation
to particular requirements. This can be done in four (non mutually exclusive)
ways: 
<UL>
<LI type=disc>By passing specific options on the command line (e.g., <B>-debug</B>, <B>-infix</B>,
<B>-macro</B>, <B>-prefix</B>, <B>-trace</B>) to modify the  generated C code; </LI><P><LI type=disc>By declaring certain
LOTOS sorts as <I>external</I> (see the section below on SPECIAL COMMENTS FOR
SORTS) and providing the C code that implements these sorts in <I>filename</I><B>.t</B>.
</LI><P><LI type=disc>By declaring certain LOTOS operations as <I>external</I> (see the section  below
on SPECIAL COMMENTS FOR OPERATIONS) and providing the C code that implements
these operations in <I>filename</I><B>.f</B>. </LI><P><LI type=disc>By inserting, in the aforementioned file
<I>filename</I><B>.t</B>, various directives that influence the way certain LOTOS sorts
are implemented in C. See below the section on SPECIAL SYMBOLS for details.
</LI><P>
</UL>

<H2><A NAME="sect23" HREF="#sect23">LOTOS and C Identifiers</A></H2>
To execute LOTOS specifications, one must establish
a correspondence between  <I>abstract</I> data types (i.e., LOTOS sorts and operations)
and  their <I>concrete</I> implementations (i.e., C types and functions or  macro-definitions).
There is no direct, one-to-one correspondence, because: (i) LOTOS operation
identifiers may contain special characters (e.g., "#",  "@", etc.) that are
not allowed in C identifiers; (ii) LOTOS allows a sort and an operation
to share the same identifier, whereas types and functions must have distinct
identifiers in C; (iii) a LOTOS operation identifier may be overloaded
and thus be implemented by different C functions or  macro-definitions,
each of which must have unique identifier in C. Notice also that, although
LOTOS identifiers are case-insensitive, C  identifiers are case-sensitive.
<P>
In the sequel, a <I>valid C identifier</I> denotes any identifier that obeys the
rules of the C language; such an identifier must be different from the
reserved keywords of C (i.e., "<CODE>if</CODE>", "<CODE>while</CODE>", etc.), but should  also be different
from POSIX names (e.g., "<CODE>exit</CODE>", "<CODE>FILE</CODE>",  "<CODE>fopen</CODE>", "<CODE>malloc</CODE>", "<CODE>printf</CODE>", etc.).
Moreover, it should  not start with a prefix used by the CADP tools, among
which "<CODE>ADT_</CODE>, "<CODE>adt_</CODE>, "<CODE>CAESAR_</CODE>", "<CODE>caesar_</CODE>", "<CODE>BCG_</CODE>", "<CODE>bcg_</CODE>", "<CODE>XTL_</CODE>", and "<CODE>xtl_</CODE>".
It may be worth that users choose another prefix and use it systematically
before their own C identifiers. <P>
The standard definition of LOTOS makes no
provision for mapping abstract data types to concrete ones, so that interface
conventions often differ across tools that implement LOTOS. The next section
describes the conventions adopted by the CADP tools for LOTOS. 
<H2><A NAME="sect24" HREF="#sect24">Special Comments</A></H2>
<P>
Mapping
information is inserted directly in the LOTOS specifications by means of
<I>special comments</I>. Such special comments have the following syntax "<CODE>(*! ...
*)</CODE>" and are thus a subset of ordinary LOTOS comments "<CODE>(* ... *)</CODE>". But, unlike
ordinary comments, their content is meaningful  and parsed.  <P>
Note: users
should carefully respect the syntax of special comments because they are
scanned at a lexical rather than syntactic level. Thus, in case of  syntax
errors in a special comment, the error-recovery actions performed by the
SYNTAX compiler-generator system used to build the CADP tools may be less
intuitive than usually, yielding a cascade of cryptic error messages. <P>
There
are two main classes of special comments: those attached to LOTOS operations,
and those attached to LOTOS sorts. Unless stated otherwise, special comments
are optional. If present, they must occur immediately after the declaration
of the sort or the operation they are attached to.  <P>
It is not permitted
to attach a special comment to a LOTOS sort or operation  defined by renaming
an other sort or operation, because <B>caesar.adt</B> generates no C code for renamed
sorts and operations, and just implements these as synonyms of the sorts
and operations they rename. <P>
It is not permitted to attach a special comment
to a LOTOS sort or operation that is either formal (i.e., generic) or defined
by actualizing an other sort or operation, because <B>caesar.adt</B> generates
no C code to implement  parameterized data types. <P>
Numerous examples of special
comments can be found by examining the  predefined LOTOS libraries contained
in directory "<B>$CADP/lib</B>". The simplest example is probably the <I>BIT</I> type
declared in  "<B>$CADP/lib/X_BIT.lib</B>" and implemented in "<B>$CADP/incl/X_BIT.h</B>".

<H3><A NAME="sect25" HREF="#sect25">Special Comments for Sorts</A></H3>
A special comment attached to the declaration
of a LOTOS sort <I>S</I> has the following syntax (where square brackets mean
optional elements): <PRE>   (*!
      [ implementedby N ]
      [ comparedby N1 ]
      [ iteratedby N2 and N3 ]
      [ printedby N4 ]
      [ list ]
      [ external ]
   *)
</PRE><P>
where <I>N</I>, <I>N1</I>, <I>N2</I>, <I>N3</I>, and <I>N4</I> are valid C identifiers. Even if these elements
are optional, their order cannot be  modified. Spaces and blanks are allowed
inside special comments. All letters in the words "<CODE>implementedby</CODE>", "<CODE>comparedby</CODE>",
..., "<CODE>external</CODE>" can be either in lower or upper case; it is advised to use
the lower case only. <P>
The meaning of special comments is the following: 
<UL>
<LI type=disc>The
attribute "<CODE>implementedby</CODE> <I>N</I>", if present, indicates that the abstract LOTOS
sort <I>S</I> is implemented by a concrete C type  named <I>N</I>. The simplest way is
to declare <I>N</I> using a "<CODE>typedef</CODE>" instruction, but declaring <I>N</I> as a macro-definition
is also possible. <P>
Type <I>N</I> can be any C type whose values occupy a fixed number
of bits, so that values of type <I>N</I> can be copied using a standard C assignment
operator "<CODE>=</CODE>". This obviously allows (signed and unsigned)  integers and
characters, reals, and enums. This also allows struct and union  types,
for which assignment is also permitted in C; the CADP tools take into 
account the case of certain C compilers that copy each field of structs
or  unions, but do not copy the padding bits that may exist between these
fields: in such case, assignment is replaced by a call to the <CODE>memcpy()</CODE>
function to avoid creating uncanonical values (i.e., identical struct or
union values having a different representation in memory). Array types are
not allowed because assignment is not permitted for them. Finally, pointer
types (to, e.g., vectors, matrices, linked lists, binary trees, etc.) are
also allowed, provided that the allocated memory cells to which they point
are assigned  only once and not modified later. Thus, any function with
an argument of  pointer type should not modify this  argument but first
make a copy of it  and modify this copy only. Under this condition, structural
sharing (i.e., several pointers referring to the same memory cell) will work
correctly. See below the section on SPECIAL SYMBOLS for a discussion on
structural sharing, as well as other points such as bit fields. <P>
If the attribute
"<CODE>implementedby</CODE>" is absent, the CADP tools will generate  a unique C identifier
for the implementation of <I>S</I>. Nothing else should be assumed about this identifier.
In particular, it may change with future  versions of the CADP tools. <P>
The
option <B>-comments</B> of the CADP tools emits a warning for each unspecified
"<CODE>implementedby</CODE>" attribute. <P>
The option <B>-map</B> of the CADP tools produces a file
that gives the name correspondence between abstract LOTOS sorts and concrete
C types. </LI><P><LI type=disc>The attribute "<CODE>comparedby</CODE> <I>N1</I>", if present, indicates that the equality
comparison between two abstract values of sort <I>S</I> is implemented by a concrete
C function (or macro-definition) named <I>N1</I>. This function takes two arguments
of type <I>N</I> and returns a result  of type <CODE>int</CODE>, which is zero if both arguments
are equal, or non-zero (yet not necessarily one) if both arguments are different.
<P>
If the attribute "<CODE>comparedby</CODE>" is absent, a unique C identifier is generated
for <I>N1</I>, with no other guarantee. <P>
Notice that function <I>N1</I> should always exist,
even if sort <I>S</I> has no associated comparison operation (e.g., "<I>eq</I> <CODE>:</CODE> <I>S</I>,  <I>S</I>
<CODE>-&gt;</CODE> <I>Bool</I>") defined explicitly in the LOTOS specification. Indeed, one must
compare values of sort <I>S</I> whenever they occur  in equation premisses ("<I>X</I><CODE>=</CODE><I>Y</I>
<CODE>=&gt;</CODE> ..."), in Boolean guards ("<CODE>[</CODE><I>X</I><CODE>=</CODE><I>Y</I><CODE>] -&gt;</CODE> ..."), or in rendezvous with value matching
("<I>G</I><CODE>!</CODE><I>X</I> ... <CODE>||</CODE> <I>G</I><CODE>!</CODE><I>Y</I> ..."). <P>
For simple types (e.g., integers or enumerated types), function
<I>N1</I> is often a mere equality test (noted "<CODE>==</CODE>" in C). However, for more complex
types, computations may be more involved, e.g., comparison of two real numbers
 up to a given precision, or deep comparison of linked data structures.
<P>
The definition of function <I>N1</I> should always take into account the  cases
where one or both of its arguments is equal to a bit pattern consisting
 only of zeros, even if such a bit-zero pattern does not normally belong
to the admissible values of type <I>N</I> (for instance, if <I>N</I> is a pointer type
denoting C character strings, the case of the <CODE>NULL</CODE> value should  nevertheless
be considered). This is due to the fact that <B>caesar</B> initializes all simulator
variables to an undefined value represented by a bit-zero pattern, and also
resets variables to this undefined value as  soon as they are no longer
used. </LI><P><LI type=disc>The attribute "<CODE>iteratedby</CODE> <I>N2</I> <CODE>and</CODE> <I>N3</I>", if present, indicates that the
enumeration of all values in the domain of sort <I>S</I> (or in a finite subset
if this domain is infinite or too large) is implemented by two macro-definitions
named <I>N2</I> and <I>N3</I> (see above the section on FINITE-DOMAIN CONSTRAINTS for
a discussion on iterators).  The macro <I>N2</I> has no argument and returns a
constant value of  type <I>N</I>, which is the "first" value to be enumerated
in the  domain of <I>S</I>. The macro <I>N3</I> takes one argument, which is an l-value
of type <I>N</I>, and returns a result of type <CODE>int</CODE>;  <I>N3</I> tries to advance its argument
to the "next" value  in the domain of <I>S</I> and returns a non-zero result if
such a next value exists, or a zero result if the argument was already
equal to the "last" value in the domain of <I>S</I>. Therefore, enumerating the
domain of <I>S</I> can be achieved using the following fragment of C code: <PRE>   N x;
   x = N2;
   do {
      ...
   } while (N3 (x));
</PRE>For an external sort, the iteration macros <I>N2</I> and <I>N3</I> have to be provided
by the user in the "<B>.t</B>" file. Notice that, for the  external sorts <I>Bit</I>, <I>Bool</I>,
<I>Char</I>, <I>Int</I>, and <I>Nat</I> defined in the "<CODE>$CADP/lib/X_*.lib</CODE>" files, manually-written
iterators are provided in the corresponding "<CODE>$CADP/incl/X_*.h</CODE>" and  "<CODE>$CADP/incl/adt_*.h</CODE>"
files. For the two latter sorts, the bounds of the iterator can be modified
by defining the macros <CODE>ADT_INF_NAT</CODE>, <CODE>ADT_SUP_NAT</CODE>, <CODE>ADT_INF_INT</CODE>, and/or <CODE>ADT_SUP_INT</CODE>
before including the "<CODE>X_*.h</CODE>" file. <P>
For a non-external sort, these macros are
generated automatically by <B>caesar.adt</B> if and only if the domain of the sort
is finite; however, these macros are also generated for numeral sorts,
even if the  domain of these sorts is infinite, but <B>caesar.adt</B> restricts
the iterations to a finite range (by default, 0...255). <P>
Even when the iteration
macros are generated by <B>caesar.adt</B>, the user  can still provide alternative
definitions for these macros (e.g., to  enumerate only prime numbers below
1000). This can be done by inserting, in the "<B>.t</B>" file, the following directives:
<PRE>   #undef N2
   #define N2 ...
   #undef N3
   #define N3(...) ...
</PRE>For numeral sorts, a simpler way to restrict the iterations to the  range
0...(<I>n</I>-1) is to define the macro <CODE>CAESAR_ADT_HASH_</CODE><I>N</I> to <I>n</I> (see below the section
on SPECIAL SYMBOLS for details). <P>
If the attribute "<CODE>iteratedby</CODE>" is absent,
unique C identifiers are generated for <I>N2</I> and <I>N3</I>, with no other guarantee.
<P>
Note: the attribute "<CODE>iteratedby</CODE>" was introduced in April 2004; earlier
versions of the CADP tools used another attribute "<CODE>enumeratedby</CODE>" that is
now deprecated as it could not provide iteration for "complex" LOTOS sorts.
See item #903 in file "<B>$CADP/HISTORY</B>" for details and comparison between
old-style and new-style iterators. </LI><P><LI type=disc>The attribute "<CODE>printedby</CODE> <I>N4</I>", if present,
indicates that the abstract values of sort <I>S</I> can be displayed using a concrete
C function (or macro-definition) named <I>N4</I>. This function takes two arguments,
a POSIX stream (of type "<CODE>FILE *</CODE>") and a value of type <I>N</I>, and returns a
result of type <CODE>void</CODE> (i.e., no result at all). This function prints the value
to the stream as a human-readable character string, on a single line and
using printable characters only (carriage-return or line-feed character are
forbidden, and non-printable characters must be escaped). <P>
If the attribute
"<CODE>printedby</CODE>" is absent, a unique C identifier is generated for <I>N4</I>, with
no other guarantee. <P>
The definition of function <I>N4</I> should always take into
account the case where the value to print is undefined (i.e., equal to a
bit-zero pattern). </LI><P><LI type=disc>The attribute "<CODE>list</CODE>", if present, signals that sort <I>S</I>
is a list data structure and instructs <B>caesar.adt</B> to generate a printing
function <I>N4</I> that displays the values of this sort as lists rather  than
algebraic terms, e.g., "{<I>x</I>, <I>y</I>, <I>y</I>}" rather than "CONS (<I>x</I>, CONS (<I>y</I>, CONS (<I>z</I>,
NIL)))". See item #1475 in file "<B>$CADP/HISTORY</B>" for details. </LI><P><LI type=disc>The attribute
"<CODE>external</CODE>", if present, instructs <B>caesar.adt</B> not to generate C code for
<I>S</I>, which has to be implemented manually. For this sort, the user must provide,
in the "<B>.t</B>" file, the corresponding C type <I>N</I> that implements <I>S</I>, the comparison
 function <I>N1</I>, the iteration macros <I>N2</I> and <I>N3</I> (if needed),  and the printing
function <I>N4</I>. <P>
If a sort is declared to be external, the attributes "<CODE>implementedby</CODE>",
"<CODE>comparedby</CODE>", "<CODE>iteratedby</CODE>" (if needed), and "<CODE>printedby</CODE>" should be present,
so that the names <I>N</I>, ... <I>N4</I> are fixed and will not change even if the LOTOS
specification is modified or if the CADP tools are upgraded to a new version.
<P>
Other constraints on external sorts have been listed above in the section
entitled CONSTRAINTS ON SORTS AND CONSTRUCTORS. </LI><P>
</UL>

<H3><A NAME="sect26" HREF="#sect26">Special Comments for Operations</A></H3>
A
special comment attached to the declaration of a LOTOS operation <I>F</I> has
the following syntax (where square brackets mean optional elements): <PRE>   (*!
      [ implementedby N ]
      [ constructor ]
      [ external ]
   *)
</PRE><P>
where <I>N</I> is a valid C identifier. Even if these elements are optional, their
order cannot be modified. Spaces and blanks are allowed inside special comments.
 All letters in the words "<CODE>implementedby</CODE>", "<CODE>constructor</CODE>", "<CODE>external</CODE>" can
be either in lower or upper case; it is advised to use the lower case only.
<P>
The meaning of special comments is the following: 
<UL>
<LI type=disc>The attribute "<CODE>implementedby</CODE>
<I>N</I>", if present, indicates that the abstract LOTOS operation <I>F</I> is implemented
by a concrete C function  or macro-definition named <I>N</I>. The parameters and
result of <I>N</I> must be compatible with those of <I>F</I>. <P>
If <I>F</I> is a LOTOS constant
(i.e., an operation with arity zero) and if <I>N</I> is a C macro-definition, then
<I>N</I> must be defined to be followed by parentheses surrounding an empty list
of arguments, so that any  call to <I>N</I> should be written "<I>N()</I>" rather than
"<I>N</I>". <P>
If the attribute "<CODE>implementedby</CODE>" is absent, the CADP tools will generate
 a unique C identifier for the implementation of <I>F</I>. Nothing else should
be assumed about this identifier. In particular, it may change with future
 versions of the CADP tools. <P>
The option <B>-comments</B> of the CADP tools emits
a warning for each unspecified "<CODE>implementedby</CODE>" attribute. <P>
The option <B>-map</B>
of the CADP tools produces a file that gives the name correspondence between
abstract LOTOS operations and concrete C functions. </LI><P><LI type=disc>The attribute "<CODE>constructor</CODE>",
if present, instructs <B>caesar.adt</B>  that <I>F</I> is a constructor operation. Otherwise,
<B>caesar.adt</B> will assume that <I>F</I> is a non-constructor, i.e., an operation whose
meaning is defined by the algebraical equations contained in the LOTOS
specification. </LI><P><LI type=disc>The attribute "<CODE>external</CODE>", if present, instructs <B>caesar.adt</B>
not to generate C code for <I>F</I>, which has to be implemented manually. <P>
If <I>F</I>
is a non-constructor, the user must provide, in the "<B>.f</B>"  file, the corresponding
C function or macro-definition <I>N</I> that implements <I>F</I>. <P>
If <I>F</I> is a constructor,
the user must provide, in the "<B>.t</B>" file,  the corresponding C function or
macro-definition <I>N</I> that implements <I>F</I>, a <I>tester</I> function <I>N0</I> taking one  argument
<I>x</I> of type <I>N</I> and returning a non-zero result if <I>x</I> matches at its top level
the constructor <I>F</I>, and <I>n</I> <I>selector</I>  functions <I>N1</I>, ..., <I>Nn</I> (where <I>n</I> is the arity
of <I>F</I>) taking one argument <I>x</I> of type <I>N</I> that satisfies <I>N0</I> (<I>x</I>) != 0 and returning,
respectively, the values <I>x1</I>, ..., <I>xn</I> such that <I>x</I> = <I>N</I> (<I>x1</I>, ..., <I>xn</I>). <P>
If an operation
is declared to be external, the attribute "<CODE>implementedby</CODE>" should be present,
so that the name <I>N</I> of the implementation is fixed and will not change even
if the LOTOS specification is modified or if the CADP tools are upgraded
to a new version.  <P>
If the operation is a constructor, attributes should
exist for fixing the names of the tester and selector functions, but such
attributes are not implemented yet. <P>
Other constraints on external sorts
have been listed above in the section entitled CONSTRAINTS ON NON-CONSTRUCTORS
AND EQUATIONS. </LI><P>
</UL>

<H2><A NAME="sect27" HREF="#sect27">Side Effects in External Functions</A></H2>
As a general principle,
any C function implementing a (constructor or non-constructor) LOTOS operation
should not perform side effects because these are not present in the formal
semantics of LOTOS abstract data types. <P>
When the manually-written C code
is to be used together with <B>caesar</B> (i.e., mixed with C code automatically
generated by <B>caesar</B> for state-space exploration), the above principle holds
quite strictly. In practice, side effects may be possible but only under
very limited forms: allocating new memory cells, storing data values in
a unique way  using hash tables, or writing information to files (e.g., traces
on log files). All other forms of side effects are prohibited. In particular,
certain optimizations performed by <B>caesar</B> may become incorrect in presence
of external functions with side effects. <P>
When the manually-written C code
is not to be used with <B>caesar</B>, the aforementioned prohibition can be relaxed,
so as to obtain the same features as monads in functional languages. It
becomes even possible to  provide manually-written C functions that keep
internal variables or  modify previously allocated data structures (e.g.,
update certain fields  of a linked list). <P>
This is a risky practice that
requires care and insight. An example of  monads can be found by inspecting
the <I>ACTION</I> type declared in  "<B>$CADP/lib/X_ACTION.lib</B>" and implemented in
 "<B>$CADP/incl/X_ACTION.h</B>". 
<H2><A NAME="sect28" HREF="#sect28">Call-By-Need Evaluation in External Functions</A></H2>
<P>
When
implemented manually as C macro-definitions, certain LOTOS operations can
avoid the call-by-value semantics enforced by <B>caesar.adt</B> (i.e.,  the actual
arguments of a function are always evaluated before calling this function)
and rely on call-by-need semantics instead. <P>
A first example is given by the
<I>and_then</I> and <I>or_else</I> operators declared in <B>$CADP/lib/X_BOOLEAN.lib</B>". These
operators are implemented in "<B>$CADP/incl/X_BOOLEAN.h</B>" as macro-definitions
that expand to the C operators "<CODE>&amp;&amp;</CODE>" and "<CODE>||</CODE>". Depending on the value of their
first argument, these operators may skip evaluating their second argument
(performing so-called "short-circuits"). <P>
A second example is given by the
<I>if_then</I> and <I>if_then_else</I>  operators declared in "<B>$CADP/lib/X_ACTION.lib</B>".
These operators are implemented in "<B>$CADP/incl/X_ACTION.h</B>" as macro-definitions
that  expand to the C ternary operator "(...<CODE>?</CODE>...<CODE>:</CODE>...)". The value of the first argument
determines which one of the remaining arguments will be evaluated. 
<H2><A NAME="sect29" HREF="#sect29">Memory
Concerns with Data Types</A></H2>
Saving memory is of utmost importance when using
verification techniques based on state-space exploration. This section presents
some effective  ways to save memory when using LOTOS abstract data types
with the CADP tools. <P>
Let <I>C</I> be a constructor that may allocate memory when
invoked (for  instance, <I>C</I> can be the <I>cons</I> operator of linked lists). Any
call to <I>C</I> in the patterns on the left-hand side of an equation will not
allocate memory. However, any call to <I>C</I> in a premiss or on the right-hand
side of an equation will allocate memory, so one should be careful about
such calls if memory space needs to be optimized. <P>
Dynamically-allocated data
types are expensive. By default, <B>caesar.adt</B> tries to reduce their use by
introducing as few pointer types as needed in  the generated C code, only
resorting to pointers where they are necessary to break dependencies between
circular types, or where the user has explicitly asked for pointers (see
the <CODE>CAESAR_ADT_HASH_</CODE><I>N</I> symbol below). <P>
For a dynamically-allocated type that
needs pointers (e.g., a list type),  the user can request (still using the
<CODE>CAESAR_ADT_HASH_</CODE><I>N</I> symbol) to store all the values of this type in a hash
table, meaning that  each value is represented by its index in the table.
Different types have  different hash tables, meaning that the sizes of
tables and the numbers of  bits for indexes can be tuned for each type
independently. The user has to predict a maximal size for each table, i.e.,
an upper bound on the number of values that will be inserted. The advantages
of this approach are twofold: (i) memory consumption is significantly reduced,
as identical values are stored in memory only once; and (ii) the CPU overhead
required for insertion and lookup in hash tables is usually compensated
by the gain in comparing values, because only indexes have to be compared
(it is no longer necessary to perform "deep" structural comparison of algebraic
terms). Because the "<B>caesar_table_1</B>" library of OPEN/CAESAR is used to handle
these  hash tables, any "<B>.h</B>" file generated by <B>caesar.adt</B> must be linked,
if it uses hash tables, against the "<B>libcaesar.a</B>" library of OPEN/CAESAR
and, possibly, the complement library "<B>libcaesar_plug.a</B>". <P>
Finally, for dynamically-allocated
types not stored in tables, it is also possible to activate a conservative
garbage collector, using the "<CODE>CAESAR_ADT_GARBAGE_COLLECTION</CODE>" macro defined
below. 
<H2><A NAME="sect30" HREF="#sect30">Special Symbols Used in the C Code</A></H2>
A number of variables, functions,
and macro-definitions may or must be used to exploit at its best the C code
generated by <B>caesar.adt</B>. Here are the most important ones, sorted into different
categories. 
<H3><A NAME="sect31" HREF="#sect31">Version Checking</A></H3>
The four following symbols are used for checking
versions: 
<DL><DD><DL COMPACT>

<DT><CODE>CAESAR_ADT</CODE> </DT>
<DD>This macro is defined in any "<B>.h</B>" file generated by
<B>caesar.adt</B>  and is equal to the version number of <B>caesar.adt</B> (e.g., 5.4) at
the  time the file was produced. This macro can be consulted in the "<B>.f</B>"
and "<B>.t</B>" files written by the user. </DD><P>

<DT><CODE>CAESAR_ADT_EXPERT</CODE> </DT>
<DD>In any "<B>.h</B>" file not
generated by <B>caesar.adt</B> and containing manually-written C code to be used
with <B>caesar</B>, the user should  insert a macro-definition of the following
form: <PRE>     #define CAESAR_ADT_EXPERT x.y
</PRE>where x.y is the version number of <B>caesar.adt</B> at the time  the file was written.
<B>caesar</B> will check this number and, should the conventions evolve in the
future, use it to ensure backward compatibility or warn about deprecated
contents. See items #622 and #1033 in file  "<B>$CADP/HISTORY</B>" for details.
</DD><P>

<DT><CODE>CAESAR_ADT_EXPERT_F</CODE> </DT>
<DD>In any "<B>.f</B>" file, the user should insert a macro-definition
of the  following form: <PRE>     #define CAESAR_ADT_EXPERT_F x.y
</PRE>where x.y is the version number of <B>caesar.adt</B> at the time  the file was written.
<B>caesar</B> and <B>caesar.adt</B> will check this number  and, should the conventions
evolve in the future, use it to ensure backward compatibility or warn about
deprecated contents. See items #622 and #1033 in  file "<B>$CADP/HISTORY</B>" for
details. </DD><P>

<DT><CODE>CAESAR_ADT_EXPERT_T</CODE> </DT>
<DD>In any "<B>.t</B>" file, the user should insert a macro-definition
of the  following form: <PRE>     #define CAESAR_ADT_EXPERT_T x.y
</PRE>where x.y is the version number of <B>caesar.adt</B> at the time  the file was written.
<B>caesar</B> and <B>caesar.adt</B> will check this number  and, should the conventions
evolve in the future, use it to ensure backward compatibility or warn about
deprecated contents. See items #622 and #1033 in file "<B>$CADP/HISTORY</B>" for
details. </DD><P>
</DL></DD><P></DL>

<H3><A NAME="sect32" HREF="#sect32">Interfacing</A></H3>
The following symbol determines the usage of a "<B>.h</B>" file:

<DL><DD><DL COMPACT>

<DT><CODE>CAESAR_ADT_INTERFACE</CODE> </DT>
<DD>The "<B>.h</B>" file generated by <B>caesar.adt</B> often contains
more than mere interface declarations, as it also contains definitions
of variables and  functions. Thus, the "<B>.h</B>" file can be included only once,
in one  single "<B>.c</B>" file, otherwise double definitions will ensue at link-edit
time. The <CODE>CAESAR_ADT_INTERFACE</CODE> macro-definition addresses this issue. If this
macro is defined before including the "<B>.h</B>" file, i.e.: <PRE>     #define CAESAR_ADT_INTERFACE
     #include "filename.h"
</PRE>only the interface declarations contained in "<I>filename</I><B>.h</B>" will be included.
See item #859 in file "<B>$CADP/HISTORY</B>" for details. </DD><P>
</DL></DD><P></DL>

<H3><A NAME="sect33" HREF="#sect33">Initialization and Termination</A></H3>
The
two following symbols perform initialization and termination: 
<DL><DD><DL COMPACT>

<DT><CODE>CAESAR_ADT_INIT()</CODE>
</DT>
<DD>The "<B>.h</B>" file generated by <B>caesar.adt</B> defines a function named <CODE>CAESAR_ADT_INIT()</CODE>
that must be invoked before using any other  primitive contained in the
"<B>.h</B>" file. See items #212, #1253, and #1914 in file "<B>$CADP/HISTORY</B>" for details.
</DD><P>

<DT><CODE>CAESAR_ADT_TERM(...)</CODE> </DT>
<DD>The "<B>.h</B>" file generated by <B>caesar.adt</B> defines a function
named <CODE>CAESAR_ADT_TERM()</CODE> that can be (optionally) invoked by the user  when
the other primitives contained in the "<B>.h</B>" file will not  be called any
more. This function takes a single parameter of type "<CODE>FILE *</CODE>" and, if this
parameter is not <CODE>NULL</CODE>, prints to  this file the contents of the hash tables
for which the user has  provided a format by means of the symbols <CODE>CAESAR_ADT_FORMAT_</CODE><I>N</I>
or <CODE>CAESAR_ADT_FORMAT</CODE> defined below. This function then deletes all  the
hash tables allocated in memory. See item #1250 in file  "<B>$CADP/HISTORY</B>"
for details. </DD><P>
</DL></DD><P></DL>

<H3><A NAME="sect34" HREF="#sect34">Type Tuning</A></H3>
The following symbols enable the representation
of types to be modified: 
<DL><DD><DL COMPACT>

<DT><CODE>ADT_BITS_NAT</CODE> </DT>
<DD>If defined to a natural value <I>n</I> before
including the file  "<B>$CADP/incl/X_NATURAL.h</B>" that implements the natural
numbers defined in the "<B>X_NATURAL.lib</B>" library, this macro indicates that
natural  numbers are implemented on <I>n</I> bits only. See item #1584 in file
"<B>$CADP/HISTORY</B>" for details. </DD><P>

<DT><CODE>ADT_BITS_INT</CODE> </DT>
<DD>If defined to a natural value
<I>n</I> before including the file  "<B>$CADP/incl/X_INTEGER.h</B>" that implements the
integer numbers defined in the "<B>X_INTEGER.lib</B>" library, this macro indicates
that integer numbers are implemented on <I>n</I> bits only. See item #1584 in file
"<B>$CADP/HISTORY</B>" for details. </DD><P>

<DT><CODE>CAESAR_ADT_BITS_</CODE><I>N</I> </DT>
<DD>If defined, this macro indicates
that the C type <I>N</I> implementing some  LOTOS sort <I>S</I> can be stored as a bit
field in a C struct or union type. The value of the macro should have the
following form ": <I>n</I>" (without the surrounding double quotes), where <I>n</I> is
the number of bits needed  for representing type <I>N</I>, knowing that <I>n</I> &lt;= <B>sizeof</B>
(<I>N</I>). For non-external sorts, this macro is automatically defined  by <B>caesar.adt</B>,
and, for external sorts, it can be manually defined  by the user in the
"<B>.t</B>" file; forgetting to define this macro when appropriate is harmless
though less efficient, as more memory will be used than needed. </DD><P>

<DT><CODE>CAESAR_ADT_HASH_</CODE><I>N</I>
</DT>
<DD>If defined by the user in the "<B>.t</B>" file as an integer value <I>n</I>, this macro
specifies the way in which the C type <I>N</I> implementing a  LOTOS sort <I>S</I> must
be defined. If <I>S</I> is not external, then <B>caesar.adt</B> takes this macro into account
to generate the C code for type <I>N</I>. If <I>S</I> is external, then <B>caesar.adt</B>  takes
this macro into account to implement or optimize the sorts that transitively
depend on <I>S</I>. <P>
Setting <I>n</I> &gt; 1 means that the values of sort <I>S</I> are stored in
a hash table that can contain at most <I>n</I> elements. Type <I>N</I> will be implemented
as an index ranging between 0 and (<I>n</I>-1) that gives access to this table.
<B>caesar.adt</B> checks that the value of <I>n</I>  is not too large. <I>S</I> should be a tuple,
an ordinary, an external, or a numeral sort (the latter case will be detailed
below). If <I>S</I> is a singleton or an enumeration sort, a warning will be emitted
and the definition of <CODE>CAESAR_ADT_HASH_</CODE><I>N</I> will be ignored. If the limit of
<I>n</I> values is exceeded, the execution will stop with a <CODE>SIGTERM</CODE> signal unless
the user has specified a different error handler using the <CODE>CAESAR_ADT_OVERFLOW_</CODE><I>N</I>
macro defined below. <P>
Setting <I>n</I> &lt; 0 means that the values of sort <I>S</I> are stored
in a hash table that can contain at most (2^-<I>n</I>) elements. This case  is similar
to the previous one, noticing that values of type <I>N</I> will be implemented
on (-<I>n</I>) bits exactly. <B>caesar.adt</B> checks  that the value of <I>n</I> is not too small.
<P>
Setting <I>n</I> = 1 means that the values of sort <I>S</I> should be implemented using
pointers to structs or to unions (i.e., they should have a <I>boxed</I> representation).
<I>S</I> should be a tuple, an ordinary,  or a numeral sort (the latter case will
be detailed below). If <I>S</I>  is a singleton, an enumeration, or an external
sort, a warning will be emitted and the definition of <CODE>CAESAR_ADT_HASH_</CODE><I>N</I>
will be ignored. <P>
Setting <I>n</I> = 0 means that the values of sort <I>S</I> should neither
be implemented using pointers (i.e., they should have an <I>unboxed</I>  representation)
nor be stored in a hash table. <I>S</I> can be a singleton, an enumeration, a tuple,
or an ordinary sort; in the two latter cases,  an error is reported if
there are cyclic dependencies that cannot be  resolved by introducing pointers
or table indexes because the user has forbidden to do so by requiring <I>n</I>
= 0 for the mutually recursive types. If <I>S</I> is a numeral, an error message
is also emitted as  having <I>n</I> = 0 would be meaningless. If <I>S</I> is an external
sort,  taking <I>n</I> = 0 has no effect and is ignored silently. <P>
As a consequence
of the above, for singleton and enumeration sorts, the <CODE>CAESAR_ADT_HASH_</CODE><I>N</I>
macro should either be undefined or have its value <I>n</I> set to zero. <P>
In the
case of numeral sorts, hash tables are never used, whatever which value
is given to <I>n</I>. Setting <I>n</I> &gt; 0 means that type <I>N</I> will represent the natural
numbers ranging between 0 and (<I>n</I>-1). Setting <I>n</I> &lt; 0 means that type <I>N</I> will
represent the natural  numbers coded on (-<I>n</I>) bits. <P>
Finally, if the <CODE>CAESAR_ADT_HASH_</CODE><I>N</I>
macro is undefined, <B>caesar.adt</B> automatically chooses the most appropriate
implementation corresponding to either <I>n</I> = 0 or <I>n</I> = 1; <B>caesar.adt</B> will do
its best efforts to avoid implementing <I>N</I> as a pointer type  (i.e., choosing
<I>n</I> = 0) unless this is necessary to break circular type dependencies. Hence,
by default, no LOTOS sort will have its value stored in a hash table unless
specifically requested by the user. <P>
See items #623, #1250, #1251, #1255,
#1332, #1435, #1494, and #1498  in file "<B>$CADP/HISTORY</B>" for details. </DD><P>

<DT><CODE>CAESAR_ADT_HASH_ADT_STRING</CODE>
</DT>
<DD>If defined to an integer value <I>n</I> before including the file  "<B>$CADP/incl/X_STRING.h</B>"
that implements the (variable-length) character strings defined in the "<B>X_STRING.lib</B>"
library, this  macro modifies the way strings are stored in memory. By default,
strings are allocated dynamically using <CODE>malloc()</CODE>, which can be memory-inefficient.
If <I>n</I> &gt; 1, strings are stored in a hash table  with <I>n</I> entries at most. If
<I>n</I> &lt; 0, strings are stored in a hash table with 2^(-<I>n</I>) entries at most. See
item #1495 in file "<B>$CADP/HISTORY</B>" for details. </DD><P>

<DT><CODE>CAESAR_ADT_SCALAR_</CODE><I>N</I> </DT>
<DD>If defined,
this macro indicates that the constant 0 belongs to the C  type <I>N</I> implementing
some LOTOS sort <I>S</I>, so that variables of this type can be reset simply by
assigning zero to them. In the C language,  this corresponds to the usual
notion of <I>scalar</I> type, which includes (signed and unsigned) integers and
characters, reals, enums, and pointers, but excludes arrays, structs, and
unions. For non-external sorts, this macro is automatically defined by <B>caesar.adt</B>,
and, for external sorts, it can be manually defined by the user in the
"<B>.t</B>" file; forgetting to define this macro when appropriate is usually harmless
though slightly less efficient, as variables will be reset using a call
to <CODE>memset()</CODE> rather than an assignment; however, the proper definition of
this macro for external sorts is required when using the <B>-external</B> option
of CAESAR. See item #493 in file "<B>$CADP/HISTORY</B>" for details. </DD><P>

<DT><CODE>CAESAR_ADT_UNCANONICAL_</CODE><I>N</I>
</DT>
<DD>If defined, this macro indicates that the values of the C type <I>N</I>  implementing
some LOTOS sort <I>S</I> are not represented under a canonical  form, meaning
that two concrete C values stored in memory using two different  bit strings
may still denote the same abstract LOTOS value. This can  occur if <I>N</I> is
a pointer type (e.g., two pointers referring to two different memory cells
having the same contents), but in other cases as well (e.g., a struct or
union type with uninitialized padding bits between its fields, or a struct
or union type containing pointer fields, and so on recursively). For non-external
sorts, this macro is automatically defined  by <B>caesar.adt</B>, and, for external
sorts, it must be manually defined  by the user in the "<B>.t</B>" file; forgetting
to define this macro when  appropriate is harmful as it leads to incorrect
comparison and hashing on bit strings. For this reason, the values of non-canonical
sorts should never be stored in hash tables. See items #623 and #1494 in
file  "<B>$CADP/HISTORY</B>" for details. </DD><P>

<DT><CODE>CAESAR_ADT_COLLISIONS_</CODE><I>N</I> </DT>
<DD></DD><P>

<DT><CODE>CAESAR_ADT_COLLISIONS</CODE>
</DT>
<DD>These two macros can be used to reduce the memory size of the hash table
storing the values of the C type <I>N</I> that implements some LOTOS sort. By default,
this table has as many hash entries as its maximal number of elements specified
using the <CODE>CAESAR_ADT_HASH_</CODE><I>N</I> macro, meaning that the average length of collision
lists is expected to be one if the table is entirely filled. The number
of hash entries can be reduced, thus decreasing memory while potentially
increasing access time. If the former macro, or else the latter macro is
defined in the "<B>.t</B>" file as an integer value <I>n</I> &gt;= 1, the number of hash entries
will be the  maximal number of elements divided by <I>n</I>, meaning that the
average  length of collision lists is expected to be <I>n</I> if the table is
 entirely filled. The latter macro applies to all types whose values are
stored in hash tables, but it is overriden by the former macro as far as
type <I>N</I> is concerned. See item #1250 in file "<B>$CADP/HISTORY</B>" for details.
</DD><P>

<DT><CODE>CAESAR_ADT_CREATE_</CODE><I>N</I><CODE>()</CODE> </DT>
<DD></DD><P>

<DT><CODE>CAESAR_ADT_DELETE_</CODE><I>N</I><CODE>()</CODE> </DT>
<DD></DD><P>

<DT><CODE>CAESAR_ADT_SHOW_</CODE><I>N</I><CODE>(...)</CODE> </DT>
<DD>For each
external LOTOS sort S implemented by a C type <I>N</I>, if the user has specified
(by setting the macro <CODE>CAESAR_ADT_CREATE_</CODE><I>N</I> to a value different from 0 and
1) that the values of type <I>N</I> are canonical and stored in a hash table,
the user has to implement this table  manually and provide the corresponding
implementation in the "<B>.t</B>"  file; <B>caesar.adt</B> cannot generate code for this
table because the implementation in C of the elements of this table is
not known at the LOTOS level; to implement this table, the user may reuse
the <B>caesar_table_1</B> library of OPEN/CAESAR. Whatever which implementation
is chosen for the  table, the user must provide, in the "<B>.t</B>" file, the three
above symbols, which must be implemented as macro-definitions, not as functions.
The two former macros respectively allocate and deallocate the hash table;
 the latter macro prints the table contents to a file pointer passed as
a parameter. These macros are invoked by <CODE>CAESAR_ADT_INIT()</CODE> and <CODE>CAESAR_ADT_TERM()</CODE>.
Examples of such macros based upon  the <B>caesar_table_1</B> library of OPEN/CAESAR
can be found by  examining the definitions of <CODE>CAESAR_ADT_CREATE_ADT_STRING()</CODE>,
<CODE>CAESAR_ADT_DELETE_ADT_STRING()</CODE>, and <CODE>CAESAR_ADT_SHOW_ADT_STRING()</CODE>  given
in file "<B>$CADP/incl/X_STRING.h</B>". See item #1498 in  file "<B>$CADP/HISTORY</B>"
for details. </DD><P>
</DL></DD><P></DL>

<H3><A NAME="sect35" HREF="#sect35">Value Printing</A></H3>
The following symbols modify the way terms can
be printed: 
<DL><DD><DL COMPACT>

<DT><CODE>CAESAR_ADT_INFIX</CODE> </DT>
<DD>If defined, this macro indicates that the
values containing constructor operations declared as infix in the LOTOS
specification  (i.e., "<CODE>_</CODE><I>F</I><CODE>_</CODE> <CODE>:</CODE> <I>S</I>, <I>S</I> <CODE>-&gt;</CODE> <I>S'</I>") should be printed in the infix form
"x <I>F</I> y" rather than the prefix form "<I>F</I> (x, y)", the latter being the default.
This macro is  normally set by the options <B>-prefix</B> and <B>-infix</B>  of <B>caesar.adt</B>,
but the user can also define this macro before including the "<B>.h</B>" file generated
by <B>caesar.adt</B>. See items #080 and #208 in file "<B>$CADP/HISTORY</B>" for details.
</DD><P>

<DT><CODE>CAESAR_ADT_PRINT_OPEN_</CODE><I>N</I> </DT>
<DD></DD><P>

<DT><CODE>CAESAR_ADT_PRINT_CLOSE_</CODE><I>N</I> </DT>
<DD>These two macros determine
how a constructor operation <I>F</I> implemented by a C function named <I>N</I> and returning
a result of some record (or even singleton) sort is printed. By default,
these macros are defined in the  "<B>.h</B>" file generated by <B>caesar.adt</B> unless
the user provides alternative definitions before including this file. For
instance, values of type <I>N</I> can be printed as "[x1, x2, ..., xn]" rather than
 "<I>F</I> (x1, x2, ..., xn)". See item #1561 in file "<B>$CADP/HISTORY</B>" for details.
</DD><P>

<DT><CODE>CAESAR_ADT_FORMAT_</CODE><I>N</I> </DT>
<DD></DD><P>

<DT><CODE>CAESAR_ADT_FORMAT</CODE> </DT>
<DD>These two macros determine whether
the hash table storing the values of  the C type <I>N</I> that implements some
LOTOS sort will be displayed in case the table overflows (because it cannot
contain as many values as necessary) or when the <CODE>CAESAR_ADT_TERM()</CODE> function
is executed. If none of these two macros is defined before including the
"<B>.h</B>" file generated by <B>caesar.adt</B>, the table will not be displayed. If the
former macro,  or else the latter macro is defined in the "<B>.t</B>" file as an
integer  value <I>n</I>, the table for type <I>N</I> will be displayed under  format
<I>n</I>, following the conventions of the <CODE>CAESAR_PRINT_TABLE_1()</CODE> primitive of
OPEN/CAESAR. The latter macro applies to all types whose values are stored
in hash tables, but it is overriden by the former macro as far as type
<I>N</I> is concerned. See item #1250 in file "<B>$CADP/HISTORY</B>" for details. </DD><P>
</DL></DD><P></DL>

<H3><A NAME="sect36" HREF="#sect36">Dynamic
Memory</A></H3>
The following symbols control dynamic memory allocation and reclaim:

<DL><DD><DL COMPACT>

<DT><CODE>CAESAR_ADT_ALLOC(...)</CODE> </DT>
<DD>This macro allocates a memory cell to contain a value
of a given type and assigns the address of this cell to a given variable.
If the allocation fails, an error message is displayed and the execution
is interrupted by a <CODE>SIGTERM</CODE> signal. By default, this macro is defined in
the "<B>.h</B>"  file generated by <B>caesar.adt</B> unless the user provides an alternative
definition before including this file. </DD><P>

<DT><CODE>CAESAR_ADT_GARBAGE_COLLECTION</CODE> </DT>
<DD>The
"<B>.h</B>" file generated by <B>caesar.adt</B> checks whether a macro named <CODE>CAESAR_ADT_GARBAGE_COLLECTION</CODE>
is defined. If so, the memory allocation primitive of the Boehm-Demers garbage
collector will be used  rather than the standard <CODE>malloc()</CODE> primitive; this
will require linking  with the "<B>$CADP/gc/bin.*/libgc.a</B>" library. This macro
can be defined by the user when compiling the "<B>.h</B>" file generated  by <B>caesar.adt</B>,
but it is automatically defined by <B>caesar</B> when  invoked with its "<B>-gc</B>" option.
See item #653 in file "<B>$CADP/HISTORY</B>" for details. </DD><P>
</DL></DD><P></DL>

<H3><A NAME="sect37" HREF="#sect37">Error Handling</A></H3>
The following
symbols determine how erroneous situations are handled: 
<DL><DD><DL COMPACT>

<DT><CODE>ADT_CHECK_NAT</CODE> </DT>
<DD>If
defined before including the file "<B>$CADP/incl/X_NATURAL.h</B>" that implements
the natural numbers defined in the "<B>X_NATURAL.lib</B>" library, this macro activates
systematic checks for overflows and underflows, which could otherwise remain
undetected. See item #1584 in file "<B>$CADP/HISTORY</B>" for details. </DD><P>

<DT><CODE>ADT_CHECK_INT</CODE>
</DT>
<DD>If defined before including the file "<B>$CADP/incl/X_INTEGER.h</B>" that implements
the natural numbers defined in the "<B>X_INTEGER.lib</B>" library, this macro activates
systematic checks for overflows and underflows, which could otherwise remain
undetected. See item #1584 in file "<B>$CADP/HISTORY</B>" for details. </DD><P>

<DT><CODE>CAESAR_ADT_ERROR(...)</CODE>
</DT>
<DD>This macro is invoked when a partially-defined non-constructor is called
with actual parameters whose values are not matched by any equation; an
error message is displayed and the execution is interrupted by a <CODE>SIGTERM</CODE>
signal. By default, this macro is defined in the "<B>.h</B>" file generated  by
<B>caesar.adt</B> unless the user provides an alternative definition before including
this file. </DD><P>

<DT><CODE>CAESAR_ADT_OVERFLOW_</CODE><I>N</I><CODE>(...)</CODE> </DT>
<DD>If defined before including the "<B>.h</B>" file
generated by <B>caesar.adt</B>, this macro provides an "overflow" function to be
invoked when the hash table  storing the values of the C type <I>N</I> that implements
some LOTOS sort is full. If the user does not define this macro, <B>caesar.adt</B>
generates  a standard overflow function automatically. See item #1250 in
file "<B>$CADP/HISTORY</B>" for details. </DD><P>
</DL></DD><P></DL>

<H3><A NAME="sect38" HREF="#sect38">Function Tracing</A></H3>
The following symbols
enable functions to be traced at run time:  
<DL><DD><DL COMPACT>

<DT><CODE>CAESAR_ADT_TRACE_</CODE><I>N</I> </DT>
<DD>When invoked
with its "<B>-trace</B>" option, <B>caesar.adt</B> will generate, for each LOTOS operation
<I>F</I> implemented by a C function named <I>N</I>, additional C code that is executed
when entering and exiting <I>N</I>. Compared to the usual function-tracing features
offered by C debuggers, this code can print the values of actual parameters
and returned results using the same notations as in the source LOTOS specification.
The execution  of this code can be enabled or disabled, for each LOTOS
operation  considered individually, using an integer variable named <CODE>CAESAR_ADT_TRACE_</CODE><I>N</I>,
which is initialized to zero. Setting this  variable to one (either at compile
time by manually patching the "<B>.h</B>"  file generated by <B>caesar.adt</B>, or at run
time by assigning the variable  directly from a debugger) allows the code
to be executed when function <I>N</I>  is called and returns. See item #180 in
file "<B>$CADP/HISTORY</B>" for details. </DD><P>

<DT><CODE>CAESAR_ADT_ARGUMENT_TRACE(...)</CODE> </DT>
<DD>This macro
prints the actual parameters passed to functions under trace. By default,
it is defined in the "<B>.h</B>" file generated by <B>caesar.adt</B> unless the user provides
an alternative definition before including this file. See items #180 and
#181 in file "<B>$CADP/HISTORY</B>" for details. </DD><P>

<DT><CODE>CAESAR_ADT_ENTRY_TRACE(...)</CODE> </DT>
<DD>This
macro prints the name and depth level of functions under trace  when they
are entered. By default, it is defined in the "<B>.h</B>" file  generated by <B>caesar.adt</B>
unless the user provides an alternative  definition before including this
file. See items #180 and #181 in file "<B>$CADP/HISTORY</B>" for details. </DD><P>

<DT><CODE>CAESAR_ADT_EXIT_TRACE(...)</CODE>
</DT>
<DD>This macro prints the name and depth level of functions under trace  when
they are exited. By default, it is defined in the "<B>.h</B>" file  generated by
<B>caesar.adt</B> unless the user provides an alternative definition before including
this file. See items #180 and #181 in file "<B>$CADP/HISTORY</B>" for details. </DD><P>

<DT><CODE>CAESAR_ADT_RESULT_TRACE(...)</CODE>
</DT>
<DD>This macro prints the results returned by functions under trace. By default,
it is defined in the "<B>.h</B>" file generated by <B>caesar.adt</B> unless the user provides
an alternative definition before including this file. See items #180 and
#181 in file "<B>$CADP/HISTORY</B>" for details. </DD><P>
</DL></DD><P></DL>

<H3><A NAME="sect39" HREF="#sect39">Deprecated Symbols</A></H3>
The following
symbols are no longer supported: 
<DL><DD><DL COMPACT>

<DT><CODE>CAESAR_ADT_NORMAL_FORM</CODE> </DT>
<DD>See items #059,
#082, and #235 in file "<B>$CADP/HISTORY</B>" for details. </DD><P>

<DT><CODE>CAESAR_ADT_POINTER_</CODE><I>N</I>
</DT>
<DD>See items #235 and #623 in file "<B>$CADP/HISTORY</B>" for details. </DD><P>

<DT><CODE>CAESAR_INFIX_FORM_PRINTING</CODE>
</DT>
<DD>See items #080 and #208 in file "<B>$CADP/HISTORY</B>" for details. </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect40" HREF="#sect40">Bibliography</A></H2>
[BB88]
Tommaso Bolognesi and Ed Brinksma. Introduction to the ISO Specification
Language LOTOS. Computer Networks and ISDN Systems, vol. 14, num. 1, pages
25-59, January 1988. <P>
[Gar89b] Hubert Garavel. Compilation et verification
de programmes LOTOS. These de doctorat, Universite Joseph Fourier, Grenoble,
November 1989. Available from <A HREF="http://cadp.inria.fr/publications/Garavel-89-b.html">http://cadp.inria.fr/publications/Garavel-89-b.html</A>

<P>
[Gar89c] Hubert Garavel. Compilation of LOTOS Abstract Data Types. In Son
T. Vuong, editor, Proceedings of the 2nd International Conference on Formal
Description Techniques (FORTE'89), Vancouver, Canada. North Holland, pages
147-162, December 1989. Available from <A HREF="http://cadp.inria.fr/publications/Garavel-89-c.html">http://cadp.inria.fr/publications/Garavel-89-c.html</A>

<P>
[Gar13] Hubert Garavel et al. 25 Years of Compositionality Issues in CADP:
An Overview. Lecture at the Workshop on the 25 Years of Combining Compositionality
and  Concurrency (WS25CCC), Koenigswinter, Germany, August 6-9, 2013. Available
 from <A HREF="ftp://ftp.inrialpes.fr/pub/vasy/presentations/Garavel-25CCC-13.pdf">ftp://ftp.inrialpes.fr/pub/vasy/presentations/Garavel-25CCC-13.pdf</A>
 <P>
[GS95a]
Hubert Garavel and Mihaela Sighireanu. Defect Report Concerning ISO International
Standard 8807 and Proposal for a Correct Flatenning of LOTOS Parametrized
Types. Rapport SPECTRE, 95-11,  VERIMAG, Grenoble, July 1995 <A HREF="http://cadp.inria.fr/publications/Garavel-Sighireanu-95-a.html">http://cadp.inria.fr/publications/Garavel-Sighireanu-95-a.html</A>

<P>
[GT93] Hubert Garavel and Philippe Turlier. CAESAR.ADT : un compilateur pour
les types abstraits algebriques du langage  LOTOS. In Rachida Dssouli and
Gregor v. Bochmann, editors, Actes du Colloque Francophone pour l'Ingenierie
des Protocoles (CFIP'93), Montreal, Canada, 1993. Available from <A HREF="http://cadp.inria.fr/publications/Garavel-Turlier-93.html">http://cadp.inria.fr/publications/Garavel-Turlier-93.html</A>

<P>
[ISO89] ISO/IEC International Standard 8807:1989. LOTOS - A Formal Description
Technique Based on the Temporal Ordering of Observational Behaviour. International
Organization for Standardization, Information Processing Systems, Open
Systems Interconnection, Geneva, September 1989. 
<H2><A NAME="sect41" HREF="#sect41">See Also</A></H2>
<A HREF="caesar.html"><B>caesar</B></A>
,
<A HREF="caesar.adt.html"><B>caesar.adt</B></A>
, <A HREF="caesar.indent.html"><B>caesar.indent</B></A>
, <A HREF="lotos.open.html"><B>lotos.open</B></A>
, <A HREF="fsp2lotos.html"><B>fsp2lotos</B></A>
,
<A HREF="lnt2lotos.html"><B>lnt2lotos</B></A>
 <P>
Additional information is available from the CADP Web
page located at  <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives for installation are given
in files <B>$CADP/INSTALLATION_*.</B> <P>
Recent changes and improvements to this software
are reported and commented in file <B>$CADP/HISTORY.</B> 
<H2><A NAME="sect42" HREF="#sect42">Bugs</A></H2>
Please report bugs
to <A HREF="mailto:cadp@inria.fr?Subject=CADP-Bug-Report">cadp@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Description</A></LI>
<LI><A NAME="toc2" HREF="#sect2">CADP Tools for LOTOS</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Tools Generating LOTOS Code</A></LI>
<LI><A NAME="toc4" HREF="#sect4">Restrictions on the Data Part of LOTOS</A></LI>
<UL>
<LI><A NAME="toc5" HREF="#sect5">Distinction Between Constructors and Non-constructors</A></LI>
<LI><A NAME="toc6" HREF="#sect6">Constraints on Equations</A></LI>
<LI><A NAME="toc7" HREF="#sect7">Constraints on Sorts and Constructors</A></LI>
<LI><A NAME="toc8" HREF="#sect8">Constraints on Non-constructors and Equations</A></LI>
<LI><A NAME="toc9" HREF="#sect9">Constraints on Renaming</A></LI>
<LI><A NAME="toc10" HREF="#sect10">Constraints on Actualization</A></LI>
<LI><A NAME="toc11" HREF="#sect11">Rewrite Strategy</A></LI>
</UL>
<LI><A NAME="toc12" HREF="#sect12">Restrictions on the Control Part of LOTOS</A></LI>
<UL>
<LI><A NAME="toc13" HREF="#sect13">Static-control Constraints</A></LI>
<LI><A NAME="toc14" HREF="#sect14">Finite-domain Constraints</A></LI>
<LI><A NAME="toc15" HREF="#sect15">Closed-world Modelling</A></LI>
</UL>
<LI><A NAME="toc16" HREF="#sect16">Other Extensions to LOTOS</A></LI>
<LI><A NAME="toc17" HREF="#sect17">Other Deviations from the LOTOS Standard</A></LI>
<LI><A NAME="toc18" HREF="#sect18">Filenames</A></LI>
<UL>
<LI><A NAME="toc19" HREF="#sect19">LOTOS Files</A></LI>
<LI><A NAME="toc20" HREF="#sect20">Library Files</A></LI>
<LI><A NAME="toc21" HREF="#sect21">Include Files</A></LI>
</UL>
<LI><A NAME="toc22" HREF="#sect22">Tailored Code Generation for Data Types</A></LI>
<LI><A NAME="toc23" HREF="#sect23">LOTOS and C Identifiers</A></LI>
<LI><A NAME="toc24" HREF="#sect24">Special Comments</A></LI>
<UL>
<LI><A NAME="toc25" HREF="#sect25">Special Comments for Sorts</A></LI>
<LI><A NAME="toc26" HREF="#sect26">Special Comments for Operations</A></LI>
</UL>
<LI><A NAME="toc27" HREF="#sect27">Side Effects in External Functions</A></LI>
<LI><A NAME="toc28" HREF="#sect28">Call-By-Need Evaluation in External Functions</A></LI>
<LI><A NAME="toc29" HREF="#sect29">Memory Concerns with Data Types</A></LI>
<LI><A NAME="toc30" HREF="#sect30">Special Symbols Used in the C Code</A></LI>
<UL>
<LI><A NAME="toc31" HREF="#sect31">Version Checking</A></LI>
<LI><A NAME="toc32" HREF="#sect32">Interfacing</A></LI>
<LI><A NAME="toc33" HREF="#sect33">Initialization and Termination</A></LI>
<LI><A NAME="toc34" HREF="#sect34">Type Tuning</A></LI>
<LI><A NAME="toc35" HREF="#sect35">Value Printing</A></LI>
<LI><A NAME="toc36" HREF="#sect36">Dynamic Memory</A></LI>
<LI><A NAME="toc37" HREF="#sect37">Error Handling</A></LI>
<LI><A NAME="toc38" HREF="#sect38">Function Tracing</A></LI>
<LI><A NAME="toc39" HREF="#sect39">Deprecated Symbols</A></LI>
</UL>
<LI><A NAME="toc40" HREF="#sect40">Bibliography</A></LI>
<LI><A NAME="toc41" HREF="#sect41">See Also</A></LI>
<LI><A NAME="toc42" HREF="#sect42">Bugs</A></LI>
</UL>
</BODY></HTML>
