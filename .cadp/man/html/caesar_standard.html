  <!-- manual page source format generated by PolyglotMan v3.0.7, -->
<!-- available via anonymous ftp from ftp.cs.berkeley.edu:/ucb/people/phelps/tcltk/rman.tar.Z -->

<HTML>
<HEAD>
<TITLE>caesar_standard manual page</TITLE>
</HEAD>
<BODY bgcolor="white" fgcolor="black">
<A HREF="#toc">Table of Contents</A><P>
  
<H2><A NAME="sect0" HREF="#sect0">Name</A></H2>
caesar_standard - the ``standard'' library of OPEN/CAESAR 
<H2><A NAME="sect1" HREF="#sect1">Purpose</A></H2>
The
``standard'' library provides basic types and notations shared by all <I>OPEN/CAESAR</I>
modules. <P>
<P>

<H2><A NAME="sect2" HREF="#sect2">Usage</A></H2>
The ``standard'' library only consists of a predefined header
file <CODE>caesar_standard.h</CODE>. <P>
<P>

<H2><A NAME="sect3" HREF="#sect3">Features</A></H2>
<P>
 <HR><BR>
 <BR>
<PRE>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;memory.h&gt;
#include &lt;signal.h&gt;

</PRE>Various standard C libraries are imported, notably those providing functions
for dynamic memory allocation, input/output, byte string facilities, and
software signals. In particular, the <CODE>FILE</CODE> type and file handling primitives
are imported. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect4" HREF="#sect4"><CODE>CAESAR_TYPE_NATURAL</CODE></A></H3>
<PRE>typedef unsigned long CAESAR_TYPE_NATURAL;

</PRE><CODE>CAESAR_TYPE_NATURAL</CODE> is the unsigned integer type used in <I>OPEN/CAESAR</I>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect5" HREF="#sect5"><CODE>CAESAR_TYPE_INTEGER</CODE></A></H3>
<PRE>typedef long CAESAR_TYPE_INTEGER;

</PRE><CODE>CAESAR_TYPE_INTEGER</CODE> is the signed integer type used in <I>OPEN/CAESAR</I>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect6" HREF="#sect6"><CODE>CAESAR_TYPE_BOOLEAN</CODE></A></H3>
<PRE>typedef unsigned char CAESAR_TYPE_BOOLEAN;

</PRE><CODE>CAESAR_TYPE_BOOLEAN</CODE> is the boolean type used in <I>OPEN/CAESAR</I>. It follows
the usual conventions of the C language: 0 means ``false'' and any value different
from 0 means ``true''. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect7" HREF="#sect7"><CODE>CAESAR_FALSE</CODE></A></H3>
<PRE>#define CAESAR_FALSE ((CAESAR_TYPE_BOOLEAN) 0)

</PRE><CODE>CAESAR_FALSE</CODE> is the ``false'' boolean value. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect8" HREF="#sect8"><CODE>CAESAR_TRUE</CODE></A></H3>
<PRE>#define CAESAR_TRUE ((CAESAR_TYPE_BOOLEAN) 1)

</PRE><CODE>CAESAR_TRUE</CODE> is one possible ``true'' boolean value. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect9" HREF="#sect9"><CODE>CAESAR_TYPE_BYTE</CODE></A></H3>
<PRE>typedef unsigned char CAESAR_TYPE_BYTE;

</PRE><CODE>CAESAR_TYPE_BYTE</CODE> is the byte type used in <I>OPEN/CAESAR</I>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect10" HREF="#sect10"><CODE>CAESAR_TYPE_STRING</CODE></A></H3>
<PRE>typedef char *CAESAR_TYPE_STRING;

</PRE><CODE>CAESAR_TYPE_STRING</CODE> is the string type (pointer to a character string termined
by a null character) used in <I>OPEN/CAESAR</I>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect11" HREF="#sect11"><CODE>CAESAR_TYPE_FILE</CODE></A></H3>
<PRE>typedef FILE *CAESAR_TYPE_FILE;

</PRE><CODE>CAESAR_TYPE_FILE</CODE> is the file type (pointer to a POSIX file descriptor)
used in <I>OPEN/CAESAR</I>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect12" HREF="#sect12"><CODE>CAESAR_TYPE_POINTER</CODE></A></H3>
<PRE>typedef unsigned char *CAESAR_TYPE_POINTER;

</PRE><CODE>CAESAR_TYPE_POINTER</CODE> is a pointer to a (generic) byte string. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect13" HREF="#sect13"><CODE>CAESAR_TYPE_GENUINE_INT</CODE></A></H3>
<PRE>typedef int CAESAR_TYPE_GENUINE_INT;

</PRE><CODE>CAESAR_TYPE_GENUINE_INT</CODE> is a 32-bit integer type; its usage is discouraged,
except at specific places where the C~standard explicitly requires an ``int''
type to be used. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect14" HREF="#sect14"><CODE>CAESAR_TYPE_ARGC</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_GENUINE_INT CAESAR_TYPE_ARGC;

</PRE><CODE>CAESAR_TYPE_ARGC</CODE> is a 32-bit integer type; it is used to declare the <CODE>argc</CODE>
parameter of the <CODE>main()</CODE> function of a C program. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect15" HREF="#sect15"><CODE>CAESAR_TYPE_ARGV</CODE></A></H3>
<PRE>typedef char **CAESAR_TYPE_ARGV;

</PRE><CODE>CAESAR_TYPE_ARGV</CODE> is a pointer to an array of strings; it is used to declare
the <CODE>argv</CODE> parameter of the <CODE>main()</CODE> function of a C program. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect16" HREF="#sect16"><CODE>CAESAR_SIZE_POINTER</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_SIZE_POINTER ()
   { ... }

</PRE>This function returns the size (in bytes) of a value of type <CODE>CAESAR_TYPE_POINTER</CODE>.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect17" HREF="#sect17"><CODE>CAESAR_ALIGNMENT_POINTER</CODE></A></H3>
<PRE>CAESAR_TYPE_NATURAL CAESAR_ALIGNMENT_POINTER ()
   { ... }

</PRE>This function returns the alignment factor (in bytes) for a value of type
<CODE>CAESAR_TYPE_POINTER</CODE>. <P>
Note: The alignment factor is often dependent from
the machine architecture. For any memory area (and not only those of type
<CODE>CAESAR_TYPE_POINTER</CODE>), the alignment factor is always a power of two (1,
2, 4, ...) and is an exact divider of the size of the area. Whatever the machine
architecture, any memory area must start at a machine address that is an
even multiple of the alignment factor for that area, this constraint stating
that areas must be properly aligned on machine word boundaries. In general,
one has only to care about alignment constraints when creating structures
containing areas with different alignment factors. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect18" HREF="#sect18"><CODE>CAESAR_TYPE_GENERIC_FUNCTION</CODE></A></H3>
<PRE>typedef void (*CAESAR_TYPE_GENERIC_FUNCTION) ();

</PRE><CODE>CAESAR_TYPE_GENERIC_FUNCTION</CODE> is the ``pointer to a function'' type used in
<I>OPEN/CAESAR</I>. The number of parameters for this function, the types of these
parameters (if any) and the result type for this function are not specified.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect19" HREF="#sect19"><CODE>CAESAR_TYPE_COMPARE_FUNCTION</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_BOOLEAN (*CAESAR_TYPE_COMPARE_FUNCTION)
   (CAESAR_TYPE_POINTER, CAESAR_TYPE_POINTER);

</PRE><CODE>CAESAR_TYPE_COMPARE_FUNCTION</CODE> is the ``pointer to a comparison function'' type
used in <I>OPEN/CAESAR</I>. A comparison function takes two parameters (two pointers
to data of the same type) and returns a boolean value, depending whether
both pointers refer to identical data or not. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect20" HREF="#sect20"><CODE>CAESAR_TYPE_HASH_FUNCTION</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_NATURAL (*CAESAR_TYPE_HASH_FUNCTION)
   (CAESAR_TYPE_POINTER, CAESAR_TYPE_NATURAL);

</PRE><CODE>CAESAR_TYPE_HASH_FUNCTION</CODE> is the ``pointer to a hash function'' type used in
<I>OPEN/CAESAR</I>. A hash function takes two parameters (a pointer to data and
a natural number N) and returns a natural number in the range 0..N-1. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect21" HREF="#sect21"><CODE>CAESAR_TYPE_CONVERT_FUNCTION</CODE></A></H3>
<PRE>typedef CAESAR_TYPE_STRING (*CAESAR_TYPE_CONVERT_FUNCTION)
   (CAESAR_TYPE_POINTER);

</PRE><CODE>CAESAR_TYPE_HASH_FUNCTION</CODE> is the ``pointer to a conversion function'' type
used in <I>OPEN/CAESAR</I>. A conversion function takes one parameter (a pointer
to data) and returns a character string containing the data under some
printable form. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect22" HREF="#sect22"><CODE>CAESAR_TYPE_PRINT_FUNCTION</CODE></A></H3>
<PRE>typedef void (*CAESAR_TYPE_PRINT_FUNCTION)
   (CAESAR_TYPE_FILE, CAESAR_TYPE_POINTER);

</PRE><CODE>CAESAR_TYPE_PRINT_FUNCTION</CODE> is the ``pointer to a printing procedure'' type
used in <I>OPEN/CAESAR</I>. A printing procedure takes two parameters (a pointer
to a file and a pointer to data) and prints the latter to the former. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect23" HREF="#sect23"><CODE>CAESAR_TYPE_FORMAT</CODE></A></H3>
<PRE>typedef unsigned char CAESAR_TYPE_FORMAT;

</PRE><CODE>CAESAR_TYPE_FORMAT</CODE> is the type used to control the output of the various
printing functions (i.e., functions whose name starts with <CODE>CAESAR_PRINT_</CODE>)
specified in the <I>OPEN/CAESAR</I> ``graph module'' interface or provided by the
<I>OPEN/CAESAR</I> library. <P>
Many of these functions can display a given object
under various formats with different degree of information (e.g., a concise
format vs a verbose format). <P>
Each format is represented by a small value
of type <CODE>CAESAR_TYPE_FORMAT</CODE>, e.g., 0, 1, 2, etc. <P>
The format to be used by a
printing function is not passed to this function as an argument (this would
be too heavy); instead, the format is stored either in a global variable
or in a field contained in the object to be printed. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect24" HREF="#sect24"><CODE>CAESAR_INVALID_FORMAT</CODE></A></H3>
<PRE>#define CAESAR_INVALID_FORMAT ((CAESAR_TYPE_FORMAT) 255)

</PRE><CODE>CAESAR_INVALID_FORMAT</CODE> is a special value of the type <CODE>CAESAR_TYPE_FORMAT</CODE>.
It can be returned as a result by function <CODE>CAESAR_HANDLE_FORMAT()</CODE> when
this function is invoked with an incorrect argument. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect25" HREF="#sect25"><CODE>CAESAR_CURRENT_FORMAT</CODE></A></H3>
<PRE>#define CAESAR_CURRENT_FORMAT ((CAESAR_TYPE_FORMAT) 254)

</PRE><CODE>CAESAR_CURRENT_FORMAT</CODE> is a special value of the type <CODE>CAESAR_TYPE_FORMAT</CODE>.
It can be passed as an argument to function <CODE>CAESAR_HANDLE_FORMAT()</CODE> and
to the various functions whose name starts with <CODE>CAESAR_FORMAT_</CODE> so as to
query the current value of the global variable or object field that stores
the format used by the corresponding printing function. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect26" HREF="#sect26"><CODE>CAESAR_MAXIMAL_FORMAT</CODE></A></H3>
<PRE>#define CAESAR_MAXIMAL_FORMAT ((CAESAR_TYPE_FORMAT) 253)

</PRE><CODE>CAESAR_MAXIMAL_FORMAT</CODE> is a special value of the type <CODE>CAESAR_TYPE_FORMAT</CODE>.
It can be passed as an argument to function <CODE>CAESAR_HANDLE_FORMAT()</CODE> and
to the various functions whose name starts with <CODE>CAESAR_FORMAT_</CODE> so as to
query the largest format value supported by the corresponding printing
function. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect27" HREF="#sect27"><CODE>CAESAR_PRINT_FORMAT</CODE></A></H3>
<PRE>void CAESAR_PRINT_FORMAT (CAESAR_FILE, CAESAR_FORMAT)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_FORMAT CAESAR_FORMAT;
   { ... }

</PRE>This procedure prints to file <CODE>CAESAR_FILE</CODE> the value of <CODE>CAESAR_FORMAT</CODE>. If
<CODE>CAESAR_FORMAT</CODE> is equal to one of the three special values <CODE>CAESAR_INVALID_FORMAT</CODE>,
<CODE>CAESAR_CURRENT_FORMAT</CODE>, or <CODE>CAESAR_MAXIMAL_FORMAT</CODE>, its value is printed symbolically
rather than numerically. <P>
Before this procedure is called, <CODE>CAESAR_FILE</CODE> must
have been properly opened, for instance using <CODE>fopen(3)</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect28" HREF="#sect28"><CODE>CAESAR_HANDLE_FORMAT</CODE></A></H3>
<PRE>CAESAR_TYPE_FORMAT CAESAR_HANDLE_FORMAT (CAESAR_VARIABLE, CAESAR_VALUE,
                                         CAESAR_MAXIMAL_VALUE)
   CAESAR_TYPE_FORMAT *CAESAR_VARIABLE;
   CAESAR_TYPE_FORMAT CAESAR_VALUE;
   CAESAR_TYPE_FORMAT CAESAR_MAXIMAL_VALUE;
   { ... }

</PRE>This function is an auxiliary function that should be used to define all
the various functions whose name starts with <CODE>CAESAR_FORMAT_</CODE>. Examples of
the proper use of this function can be found by inspecting the C~code generated
by <I>CAESAR</I> or <I>EXP.OPEN</I>. <P>
This function consults or modifies the format value
pointed to by <CODE>CAESAR_VARIABLE</CODE>, which is expected to be the address of the
global variable or object field that stores the format used by the corresponding
printing function. <P>
If <CODE>CAESAR_VALUE</CODE> is equal to <CODE>CAESAR_CURRENT_FORMAT</CODE>, this
function returns the current value of the format pointed to by <CODE>CAESAR_VARIABLE</CODE>.
<P>
If <CODE>CAESAR_VALUE</CODE> is equal to <CODE>CAESAR_MAXIMAL_FORMAT</CODE>, this function returns
<CODE>CAESAR_MAXIMAL_VALUE</CODE>, which is expected to be the largest format value
supported by the corresponding printing function. <P>
If <CODE>CAESAR_VALUE</CODE> is less
or equal to <CODE>CAESAR_MAXIMAL_VALUE</CODE>, then the value of the format pointed
to by <CODE>CAESAR_VARIABLE</CODE> is modified and set to <CODE>CAESAR_VALUE</CODE>. In such case,
this function returns an undefined value. <P>
In all other cases, this function
returns <CODE>CAESAR_INVALID_FORMAT</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect29" HREF="#sect29"><CODE>CAESAR_TYPE_ABSTRACT</CODE></A></H3>
<PRE>#define CAESAR_TYPE_ABSTRACT(CAESAR_NAME) struct CAESAR_NAME *

</PRE><CODE>CAESAR_TYPE_ABSTRACT (CAESAR_NAME)</CODE> is a pointer to a structure of name
<CODE>CAESAR_NAME</CODE>. <P>
Usually, the definition of <CODE>CAESAR_NAME</CODE> is not available, so
that <CODE>CAESAR_TYPE_ABSTRACT (...)</CODE> is a ``generic'' pointer to some data structure,
the internal representation of which is not pertinent to the user. This
data structure is ``abstract'', in the sense that one should not rely on a
particular implementation. <P>
If <CODE>CAESAR_X</CODE> is an expression of type <CODE>CAESAR_TYPE_ABSTRACT
(...)</CODE>, dereferencing <CODE>CAESAR_X</CODE> (e.g., <CODE>*CAESAR_X</CODE> or <CODE>CAESAR_X-&gt;...</CODE>) is not allowed. Note:
if <CODE>CAESAR_X</CODE> is an expression of type <CODE>CAESAR_TYPE_ABSTRACT (...)</CODE>, its value
usually obeys alignment constraints (for instance, it can be an address
multiple of 4). <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect30" HREF="#sect30"><CODE>CAESAR_CREATE</CODE></A></H3>
<PRE>#define CAESAR_CREATE(CAESAR_ADDRESS,CAESAR_SIZE,CAESAR_TYPE) \
        (CAESAR_ADDRESS) = (CAESAR_TYPE) malloc (CAESAR_SIZE)

</PRE>This macro-definition encapsulates the C function <CODE>malloc(3)</CODE>. It allocates
a memory area of <CODE>CAESAR_SIZE</CODE> bytes and assigns its address to variable
<CODE>CAESAR_ADDRESS</CODE>, which should be of type <CODE>CAESAR_TYPE</CODE>. If allocation fails,
a <CODE>NULL</CODE> pointer is assigned to <CODE>CAESAR_ADDRESS</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect31" HREF="#sect31"><CODE>CAESAR_DELETE</CODE></A></H3>
<PRE>#define CAESAR_DELETE(CAESAR_ADDRESS) \
        free ((char *) (CAESAR_ADDRESS))

</PRE>This macro-definition encapsulates the C function <CODE>free(3)</CODE>. It frees the memory
area pointed to by <CODE>CAESAR_ADDRESS</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect32" HREF="#sect32"><CODE>CAESAR_TOOL</CODE></A></H3>
<PRE>extern CAESAR_TYPE_STRING CAESAR_TOOL;

</PRE>The global variable <CODE>CAESAR_TOOL</CODE> is a pointer to a character string which
should contain the name of the <I>OPEN/CAESAR</I> application program. By default,
<CODE>CAESAR_TOOL</CODE> is always initialized to the empty string <CODE>""</CODE>. Although this
default value can be left unchanged, it is advisable for each application
program to give a meaningful value to <CODE>CAESAR_TOOL</CODE>. This is generally done
by the first instruction of the <CODE>main()</CODE> routine: <P>
<PRE>        int main (argc, argv)
        int  argc;
        char *argv[];
        {
        /* additional declarations */
        CAESAR_TOOL = argv[0];
        /* other instructions */
        }

</PRE><P>
<P>
 <HR><BR>
 
<H3><A NAME="sect33" HREF="#sect33"><CODE>CAESAR_WARNING</CODE></A></H3>
<PRE>void CAESAR_WARNING (CAESAR_TYPE_STRING CAESAR_FORMAT, ...)
   { ... }

</PRE>This function displays a (non-fatal) warning message to the standard output.
The warning message is specified by the actual parameters passed to the
function. These parameters follow the same conventions as for <CODE>printf(3)</CODE>
and their number can be variable. The warning message will be prefixed by
the value of the global variable <CODE>CAESAR_TOOL</CODE>, unless this value is the
empty string. The format string given by <CODE>CAESAR_FORMAT</CODE> should not be suffixed
with an end-of-line character, as <CODE>CAESAR_WARNING()</CODE> will add one automatically.
<P>
<P>
 <HR><BR>
 
<H3><A NAME="sect34" HREF="#sect34"><CODE>CAESAR_ERROR</CODE></A></H3>
<PRE>void CAESAR_ERROR (CAESAR_TYPE_STRING CAESAR_FORMAT, ...)
   { ... }

</PRE>This function displays a (fatal) error message to the standard output and
stops using <CODE>exit (1)</CODE>. The error message is specified by the actual parameters
passed to the function. These parameters follow the same conventions as
for <CODE>printf(3)</CODE> and their number can be variable. The error message will be
prefixed by the value of the global variable <CODE>CAESAR_TOOL</CODE>, unless this value
is the empty string. The format string given by <CODE>CAESAR_FORMAT</CODE> should not
be suffixed with an end-of-line character, as <CODE>CAESAR_ERROR()</CODE> will add one
automatically. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect35" HREF="#sect35"><CODE>CAESAR_PROTEST</CODE></A></H3>
<PRE>#define CAESAR_PROTEST() ...

</PRE>This macro-definition displays an error message (containing the current
file name and current line number) and stops. This macro-definition should
be used only to report about unexpected, internal errors. If a more detailed
error message should be displayed, then function <CODE>CAESAR_ERROR()</CODE> should
be used instead. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect36" HREF="#sect36"><CODE>CAESAR_ASSERT</CODE></A></H3>
<PRE>#define CAESAR_ASSERT(CAESAR_ASSERTION) \
        { if (!(CAESAR_ASSERTION)) CAESAR_PROTEST(); }

</PRE>This macro-definition evaluates the boolean expression <CODE>CAESAR_ASSERTION</CODE>
and, if the result is false, displays an error message (containing the
current file name and current line number) and stops. This macro-definition
should be used only to check assertions and report about unexpected, internal
errors. If a more detailed error message should be displayed, then function
<CODE>CAESAR_ERROR()</CODE> should be used instead. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect37" HREF="#sect37"><CODE>CAESAR_TYPE_SIGNAL_HANDLER</CODE></A></H3>
<PRE>typedef void (*CAESAR_TYPE_SIGNAL_HANDLER) (int);

</PRE></CODE><CODE>CAESAR_TYPE_SIGNAL_HANDLER</CODE> is the ``pointer to a signal-handler procedure''
type used in <I>OPEN/CAESAR</I>. A signal-handler procedure takes one parameter,
which a POSIX signal number. The type <CODE>CAESAR_TYPE_SIGNAL_HANDLER</CODE> is identical
to the type <CODE>sighandler_t</CODE> that exists in certain Unix distributions. See
the <CODE>signal</CODE> manual page for further details. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect38" HREF="#sect38"><CODE>CAESAR_SET_SIGNALS</CODE></A></H3>
<PRE>void CAESAR_SET_SIGNALS (CAESAR_HANDLER)
   CAESAR_TYPE_SIGNAL_HANDLER CAESAR_HANDLER;
   { ... }

</PRE>This procedure sets the POSIX signal handler to <CODE>CAESAR_HANDLER</CODE> for the
following signals: <CODE>SIGHUP</CODE>, <CODE>SIGINT</CODE>, <CODE>SIGQUIT</CODE>, <CODE>SIGILL</CODE>, <CODE>SIGABRT</CODE>, <CODE>SIGFPE</CODE>, <CODE>SIGBUS</CODE>,
<CODE>SIGSEGV</CODE>, <CODE>SIGSYS</CODE>, <CODE>SIGTERM</CODE>, and <CODE>SIGPIPE</CODE> (whenever these signals are supported
by the operating system implementation). In particular, the signal handler
<CODE>CAESAR_HANDLER</CODE> can be equal to the predefined values <CODE>SIG_IGN</CODE> or <CODE>SIG_DFL</CODE>.
See the <CODE>signal</CODE> manual page for further details. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect39" HREF="#sect39"><CODE>CAESAR_RESET_SIGNALS</CODE></A></H3>
<PRE>void CAESAR_RESET_SIGNALS ()
   { ... }

</PRE>This procedure resets the POSIX signal handler for the following signals:
<CODE>SIGHUP</CODE>, <CODE>SIGINT</CODE>, <CODE>SIGQUIT</CODE>, <CODE>SIGILL</CODE>, <CODE>SIGABRT</CODE>, <CODE>SIGFPE</CODE>, <CODE>SIGBUS</CODE>, <CODE>SIGSEGV</CODE>, <CODE>SIGSYS</CODE>,
<CODE>SIGTERM</CODE>, and <CODE>SIGPIPE</CODE> (whenever these signals are supported by the operating
system implementation). If the procedure <CODE>CAESAR_SET_SIGNALS</CODE> has been invoked
(at least once) and if no invocation of <CODE>CAESAR_RESET_SIGNALS</CODE> occurred after
the most recent invocation of <CODE>CAESAR_SET_SIGNALS</CODE>, this signal handler is
reset to the value of the <CODE>CAESAR_HANDLER</CODE> argument passed to the most recent
invocation of <CODE>CAESAR_SET_SIGNALS</CODE>. If the procedure <CODE>CAESAR_SET_SIGNALS</CODE> has
never been invoked or not been invoked after the most recent invocation
of <CODE>CAESAR_RESET_SIGNALS</CODE>, this signal handler is reset to <CODE>SIG_DFL</CODE>. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect40" HREF="#sect40"><CODE>CAESAR_TEMPORARY_FILE</CODE></A></H3>
<PRE>CAESAR_TYPE_STRING CAESAR_TEMPORARY_FILE (CAESAR_TEMPORARY_SUFFIX)
   CAESAR_TYPE_STRING CAESAR_TEMPORARY_SUFFIX;
   { ... }

</PRE>This function returns a character string that can safely be used as a file
name for a temporary file. The prefix of this file name (i.e., the directory
in which the temporary file will be created) is either given by the environment
variable <CODE>$CADP_TMP</CODE> if this variable is defined, or is equal to <CODE>"/tmp"</CODE> otherwise.
The suffix of this file name is given by <CODE>CAESAR_TEMPORARY_SUFFIX</CODE>, which
is usually a file extension starting with a dot. If the allocation of the
file name fails (due to a lack of memory) or if the temporary file cannot
not be created in the directory specified by <CODE>$CADP_TMP</CODE> (e.g., because this
directory does not exist, is write-protected, or belongs to a file system
with unsufficient disk space to create new files), the <CODE>NULL</CODE> value is returned.
<P>
The contents of the character string returned by <CODE>CAESAR_TEMPORARY_FILE()</CODE>
differs at every call to this function. <P>
Note: It is not allowed to modify
the character string returned by <CODE>CAESAR_TEMPORARY_FILE()</CODE> nor to free it,
for instance using <CODE>free(3)</CODE>. <P>
Note: The contents of the character string returned
by <CODE>CAESAR_TEMPORARY_FILE()</CODE> may be destroyed by a subsequent call to this
function. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect41" HREF="#sect41"><CODE>CAESAR_OPEN_COMPRESSED_FILE</CODE></A></H3>
<PRE>void CAESAR_OPEN_COMPRESSED_FILE (CAESAR_FILE, CAESAR_FILENAME, CAESAR_MODE)
   CAESAR_TYPE_FILE *CAESAR_FILE;
   CAESAR_TYPE_STRING CAESAR_FILENAME;
   CAESAR_TYPE_STRING CAESAR_MODE;
   { ... }

</PRE>This function opens (for reading or writing) a file, the pathname of which
is <CODE>CAESAR_FILENAME</CODE>. The value of <CODE>CAESAR_MODE</CODE>, which must be equal to <CODE>"r"</CODE>
or <CODE>"w"</CODE>, determines whether this file is opened for reading (<CODE>"r"</CODE>) or writing
(<CODE>"w"</CODE>). <P>
If the suffix of <CODE>CAESAR_FILENAME</CODE> corresponds to a known compression
format (<CODE>".Z"</CODE>, <CODE>".gz"</CODE>, <CODE>".bz2"</CODE>, etc.), the file will be treated as a compressed
file. Otherwise, the file will not be compressed and treated as an ordinary
file. The list of supported suffixes and compression formats is given by
the <CODE>cadp_zip</CODE> shell-script provided within the CADP distribution. <P>
If the file
can be opened, the value of <CODE>*CAESAR_FILE</CODE> is set to a POSIX stream descriptor
from (respectively, to) which data can be read (respectively, written)
using the standard input (respectively, output) routines available in POSIX,
e.g., <CODE>fgets(3)</CODE>, <CODE>fprintf(3)</CODE>, <CODE>fputs(3)</CODE>, <CODE>fscanf(3)</CODE>, etc. Data compression, if
any, is performed transparently, meaning that the data sent or read to
a compressed file are exactly the same as if the file was not compressed.
<P>
If the file cannot be opened, the value of <CODE>*CAESAR_FILE</CODE> is set to <CODE>NULL</CODE>.
<P>
Note: Since type <CODE>CAESAR_TYPE_FILE</CODE> is defined as <CODE>FILE *</CODE>, variable <CODE>CAESAR_FILE</CODE>
is actually of type <CODE>FILE **</CODE>, where <CODE>FILE</CODE> is the type of a POSIX file descriptor.
<P>
Note: Function <CODE>CAESAR_OPEN_COMPRESSED_FILE()</CODE> invokes <CODE>fopen(3)</CODE> to open an
uncompressed file and <CODE>popen(3)</CODE> to open a compressed file. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect42" HREF="#sect42"><CODE>CAESAR_CLOSE_COMPRESSED_FILE</CODE></A></H3>
<PRE>void CAESAR_CLOSE_COMPRESSED_FILE (CAESAR_FILE)
   CAESAR_TYPE_FILE *CAESAR_FILE;
   { ... }

</PRE>This function closes the file pointed to by <CODE>*CAESAR_FILE</CODE>, which must have
been opened previously by a call to the <CODE>CAESAR_OPEN_COMPRESSED_FILE()</CODE> function.
After the file is closed, the value of <CODE>*CAESAR_FILE</CODE> is set to <CODE>NULL</CODE>. <P>
Note:
Since type <CODE>CAESAR_TYPE_FILE</CODE> is defined as <CODE>FILE *</CODE>, variable <CODE>CAESAR_FILE</CODE>
is actually of type <CODE>FILE **</CODE>, where <CODE>FILE</CODE> is the type of a POSIX file descriptor.
<P>
Note: Function <CODE>CAESAR_CLOSE_COMPRESSED_FILE()</CODE> invokes either <CODE>fclose(3)</CODE>
or <CODE>pclose(3)</CODE> to close the file. <P>
<P>
 <HR><BR>
 
<H3><A NAME="sect43" HREF="#sect43"><CODE>CAESAR_FUNCTION_NAME</CODE></A></H3>
<PRE>CAESAR_TYPE_STRING CAESAR_FUNCTION_NAME (CAESAR_FUNCTION)
   void (*CAESAR_FUNCTION) ();
   { ... }

</PRE>This function returns a printable character string identifying the function
<CODE>CAESAR_FUNCTION</CODE>. If <CODE>CAESAR_FUNCTION</CODE> belongs to a predefined set of functions
of the <I>OPEN/CAESAR</I> library, the character string contains the name of this
function (e.g., <CODE>CAESAR_0_HASH</CODE>, <CODE>CAESAR_PRINT_STATE</CODE>, <CODE>CAESAR_COMPARE_LABEL</CODE>,
etc.); otherwise, the character string contains the hexadecimal value of
the function pointer <CODE>CAESAR_FUNCTION</CODE>. <P>
Note: It is not allowed to modify
the character string returned by <CODE>CAESAR_FUNCTION_NAME()</CODE> nor to free it,
for instance using <CODE>free(3)</CODE>. <P>
Note: In fact, <CODE>CAESAR_FUNCTION_NAME()</CODE> is implemented
as a macro-definition that invokes an auxiliary function. This avoids the
need for inserting a type cast before any parameter given to <CODE>CAESAR_FUNCTION_NAME()</CODE>.
<P>
<P>
 <HR><BR>
 
<H2><A NAME="sect44" HREF="#sect44">Author(s)</A></H2>
Hubert Garavel 
<H2><A NAME="sect45" HREF="#sect45">Files</A></H2>
 
<DL><DD><DL COMPACT>

<DT><B>$CADP/incl/caesar_graph.h</B> </DT>
<DD>interface of the
graph module </DD><P>

<DT><B>$CADP/incl/caesar_*.h</B> </DT>
<DD>interfaces of the storage module </DD><P>

<DT><B>$CADP/bin.`arch`/libcaesar.a</B>
</DT>
<DD>object code of the storage module </DD><P>

<DT><B>$CADP/src/open_caesar/*.c</B> </DT>
<DD>source code
of various exploration modules </DD><P>

<DT><B>$CADP/com/lotos.open</B> </DT>
<DD>shell script to run
OPEN/CAESAR  </DD><P>
</DL></DD><P></DL>

<H2><A NAME="sect46" HREF="#sect46">See Also</A></H2>
Reference Manuals of OPEN/CAESAR, CAESAR, and CAESAR.ADT,
<A HREF="lotos.open.html"><B>lotos.open</B></A>
, <A HREF="caesar.html"><B>caesar</B></A>
, <A HREF="caesar.adt.html"><B>caesar.adt</B></A>
 <P>
Additional information
is available from the CADP Web page located at <A HREF="http://cadp.inria.fr">http://cadp.inria.fr</A>
 <P>
Directives
for installation are given in files <B>$CADP/INSTALLATION_*.</B> <P>
Recent changes
and improvements to this software are reported and commented in file <B>$CADP/HISTORY.</B>

<H2><A NAME="sect47" HREF="#sect47">Bugs</A></H2>
Known bugs are described in the Reference Manual of OPEN/CAESAR. Please
report new bugs to <A HREF="mailto:cadp@inria.fr?Subject=CADP-Bug-Report">cadp@inria.fr</A> <P>

<HR><P>
<A NAME="toc"><B>Table of Contents</B></A><P>
<UL>
<LI><A NAME="toc0" HREF="#sect0">Name</A></LI>
<LI><A NAME="toc1" HREF="#sect1">Purpose</A></LI>
<LI><A NAME="toc2" HREF="#sect2">Usage</A></LI>
<LI><A NAME="toc3" HREF="#sect3">Features</A></LI>
<UL>
<LI><A NAME="toc4" HREF="#sect4">CAESAR_TYPE_NATURAL</A></LI>
<LI><A NAME="toc5" HREF="#sect5">CAESAR_TYPE_INTEGER</A></LI>
<LI><A NAME="toc6" HREF="#sect6">CAESAR_TYPE_BOOLEAN</A></LI>
<LI><A NAME="toc7" HREF="#sect7">CAESAR_FALSE</A></LI>
<LI><A NAME="toc8" HREF="#sect8">CAESAR_TRUE</A></LI>
<LI><A NAME="toc9" HREF="#sect9">CAESAR_TYPE_BYTE</A></LI>
<LI><A NAME="toc10" HREF="#sect10">CAESAR_TYPE_STRING</A></LI>
<LI><A NAME="toc11" HREF="#sect11">CAESAR_TYPE_FILE</A></LI>
<LI><A NAME="toc12" HREF="#sect12">CAESAR_TYPE_POINTER</A></LI>
<LI><A NAME="toc13" HREF="#sect13">CAESAR_TYPE_GENUINE_INT</A></LI>
<LI><A NAME="toc14" HREF="#sect14">CAESAR_TYPE_ARGC</A></LI>
<LI><A NAME="toc15" HREF="#sect15">CAESAR_TYPE_ARGV</A></LI>
<LI><A NAME="toc16" HREF="#sect16">CAESAR_SIZE_POINTER</A></LI>
<LI><A NAME="toc17" HREF="#sect17">CAESAR_ALIGNMENT_POINTER</A></LI>
<LI><A NAME="toc18" HREF="#sect18">CAESAR_TYPE_GENERIC_FUNCTION</A></LI>
<LI><A NAME="toc19" HREF="#sect19">CAESAR_TYPE_COMPARE_FUNCTION</A></LI>
<LI><A NAME="toc20" HREF="#sect20">CAESAR_TYPE_HASH_FUNCTION</A></LI>
<LI><A NAME="toc21" HREF="#sect21">CAESAR_TYPE_CONVERT_FUNCTION</A></LI>
<LI><A NAME="toc22" HREF="#sect22">CAESAR_TYPE_PRINT_FUNCTION</A></LI>
<LI><A NAME="toc23" HREF="#sect23">CAESAR_TYPE_FORMAT</A></LI>
<LI><A NAME="toc24" HREF="#sect24">CAESAR_INVALID_FORMAT</A></LI>
<LI><A NAME="toc25" HREF="#sect25">CAESAR_CURRENT_FORMAT</A></LI>
<LI><A NAME="toc26" HREF="#sect26">CAESAR_MAXIMAL_FORMAT</A></LI>
<LI><A NAME="toc27" HREF="#sect27">CAESAR_PRINT_FORMAT</A></LI>
<LI><A NAME="toc28" HREF="#sect28">CAESAR_HANDLE_FORMAT</A></LI>
<LI><A NAME="toc29" HREF="#sect29">CAESAR_TYPE_ABSTRACT</A></LI>
<LI><A NAME="toc30" HREF="#sect30">CAESAR_CREATE</A></LI>
<LI><A NAME="toc31" HREF="#sect31">CAESAR_DELETE</A></LI>
<LI><A NAME="toc32" HREF="#sect32">CAESAR_TOOL</A></LI>
<LI><A NAME="toc33" HREF="#sect33">CAESAR_WARNING</A></LI>
<LI><A NAME="toc34" HREF="#sect34">CAESAR_ERROR</A></LI>
<LI><A NAME="toc35" HREF="#sect35">CAESAR_PROTEST</A></LI>
<LI><A NAME="toc36" HREF="#sect36">CAESAR_ASSERT</A></LI>
<LI><A NAME="toc37" HREF="#sect37">CAESAR_TYPE_SIGNAL_HANDLER</A></LI>
<LI><A NAME="toc38" HREF="#sect38">CAESAR_SET_SIGNALS</A></LI>
<LI><A NAME="toc39" HREF="#sect39">CAESAR_RESET_SIGNALS</A></LI>
<LI><A NAME="toc40" HREF="#sect40">CAESAR_TEMPORARY_FILE</A></LI>
<LI><A NAME="toc41" HREF="#sect41">CAESAR_OPEN_COMPRESSED_FILE</A></LI>
<LI><A NAME="toc42" HREF="#sect42">CAESAR_CLOSE_COMPRESSED_FILE</A></LI>
<LI><A NAME="toc43" HREF="#sect43">CAESAR_FUNCTION_NAME</A></LI>
</UL>
<LI><A NAME="toc44" HREF="#sect44">Author(s)</A></LI>
<LI><A NAME="toc45" HREF="#sect45">Files</A></LI>
<LI><A NAME="toc46" HREF="#sect46">See Also</A></LI>
<LI><A NAME="toc47" HREF="#sect47">Bugs</A></LI>
</UL>
</BODY></HTML>
