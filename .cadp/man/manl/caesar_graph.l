'\" t
.\" @(#)caesar_graph.l - VASY and CONVECS teams - version 2.4
.TH caesar_graph LOCAL "2020/02/11 (version 2.4)" "(C) INRIA" "OPEN/CAESAR MANUAL"
.fp 4 CB
.lg 0
.SH NAME
caesar_graph \- the ``graph'' library of OPEN/CAESAR
.SH PURPOSE
The ``graph module'' provides a C representation for the states and the labels of the transition system generated from the source program. It provides primitives to handle those states and labels.
.sp
It also provides primitives to compute the transition relation (i.e., primitives to compute the initial state and the successors of any given state).
.sp
The application programming interface specified by the graph module is language-independent: various languages can be implemented so as to comply with the ``graph module'' interface.
.sp
Note: The functions and procedures specified below should not perform input/output operations on the standard input and standard output, especially reading from the standard input or writing to the standard output. As a general principle, access to standard input and standard output is reserved to the \fIOPEN/CAESAR\fP application programs (and not to the graph module).
If the functions of the graph module want to emit debugging information, this information should be sent to the standard error or, preferably, to a named, unbuffered log file. Otherwise, some \fIOPEN/CAESAR\fP application programs that rely on the standard input and standard output (e.g., the \fIOPEN/CAESAR\fP Interactive Simulator) might not function properly if the graph module performs conflicting accesses to the standard input or the standard output.
.sp
.SH USAGE
The graph module consists of:
.sp
.IP -
A predefined header file \fBcaesar_graph.h\fP, which can be found in the \fIOPEN/CAESAR\fP package. This file is an interface specification describing a set of C types, procedures, and functions. Conceptually, it can be seen as an abstract data type, with sorts and operations.
.IP -
A C file \fBspec.c\fP, which is generated from the source program (where \fBspec\fP can be any valid filename). For instance, in the case of a LOTOS program \fBspec.lotos\fP, file \fBspec.c\fP is generated by \fICAESAR\fP with the \fB-open\fP option. The \fBspec.c\fP file provides an implementation for all the features described in \fBcaesar_graph.h\fP.
.P
The \fBspec.c\fP must start with the two following directives:
.sp
 \&
.nf
\fB         #define CAESAR_GRAPH_IMPLEMENTATION ...
         #include "caesar_graph.h"
\fP
.fi
where \fB...\fP should be replaced by an integer number corresponding to the version of the graph module interface for which \fBspec.c\fP has been produced. As far as possible, this integer number will be used to preserve backward compatibility in case of future modifications of the graph module interface.
Concretely, this integer number is obtained by taking the version number given for \fIOPEN/CAESAR\fP at the bottom of file \fB$CADP/VERSION\fP, then by multiplying by 10 this version number (considered as real number) in order to turn it into an integer number (since the C preprocessor only handles integers). For instance, if the version of \fIOPEN/CAESAR\fP is 2.4 in the \fB$CADP/VERSION\fP file, then \fBCAESAR_GRAPH_IMPLEMENTATION\fP should be set to 24.
.sp
The features defined in `\fBcaesar_graph.h\fP'' are described below.
.sp
Note: The graph module uses the primitives offered by the ``standard'' and ``version'' libraries.
.sp
.SH GENERAL FEATURES
.P
 ............................................................
.SS \fBCAESAR_GRAPH_COMPILER\fP
 \&
.nf
\fBCAESAR_TYPE_STRING CAESAR_GRAPH_COMPILER ()
   { ... }
\fP
.fi
This function returns a character string containing the name (in upper case letters) of the compiler tool which generated the C program \fBspec.c\fP. For instance, if \fBspec.c\fP is generated by \fICAESAR\fP from a LOTOS program, the result of function \fBCAESAR_GRAPH_COMPILER()\fP is the character string \fB"CAESAR"\fP.
.sp
Note: It is not allowed to modify the character string returned by \fBCAESAR_GRAPH_COMPILER()\fP nor to free it, for instance using \fBfree(3)\fP.
.sp
Note: The contents of the character string returned by \fBCAESAR_GRAPH_COMPILER()\fP may be destroyed by a subsequent call to this function.
.P
 ............................................................
.SS \fBCAESAR_GRAPH_VERSION\fP
 \&
.nf
\fBCAESAR_TYPE_VERSION CAESAR_GRAPH_VERSION ()
   { ... }
\fP
.fi
This function returns the version number of the compiler tool which generated the C program \fBspec.c\fP.
.P
 ............................................................
.SS \fBCAESAR_INIT_GRAPH\fP
 \&
.nf
\fBvoid CAESAR_INIT_GRAPH ()
   { ... }
\fP
.fi
This procedure contains initialization actions for the graph module. It must be invoked once before using any routine of this module.
.sp
Implementation note: This procedure should invoke the \fBCAESAR_CHECK_VERSION()\fP procedure (see the corresponding description in the ``version'' library) in order to detect version clashes between \fBspec.c\fP and \fBcaesar_graph.h\fP.
.SH STATE FEATURES
.P
 ............................................................
.SS \fBCAESAR_BODY_STATE\fP
 \&
.nf
\fBtypedef struct CAESAR_STRUCT_STATE { ... } CAESAR_BODY_STATE;
\fP
.fi
This type denotes the actual implementation of states in the labelled transition system.
Each state is basically a structure named \fBCAESAR_STRUCT_STATE\fP. Thus, each state can be seen as a byte string of fixed size (see function \fBCAESAR_SIZE_STATE()\fP below) with definite alignment constraints (see function \fBCAESAR_ALIGNMENT_STATE()\fP below), and all the states have the same size.
.sp
State definition is ``opaque'': the detailed definition of \fBCAESAR_STRUCT_STATE\fP and \fBCAESAR_BODY_STATE\fP is only available in include mode, but not in link mode. Therefore, making assumptions about the fields of structure \fBCAESAR_STRUCT_STATE\fP is not advisable.
.P
 ............................................................
.SS \fBCAESAR_TYPE_STATE\fP
 \&
.nf
\fBtypedef CAESAR_TYPE_ABSTRACT (...) CAESAR_TYPE_STATE;
\fP
.fi
This type denotes a pointer to the (opaque) representation of states. It is given an abstract definition in file \fBcaesar_graph.h\fP and should be redefined in \fBspec.c\fP.
.sp
Concretely, \fBCAESAR_TYPE_STATE\fP should be defined as a pointer to a structure named \fBCAESAR_STRUCT_STATE\fP or, equivalently, a pointer to type \fBCAESAR_BODY_STATE\fP (see above).
.P
 ............................................................
.SS \fBCAESAR_SIZE_STATE\fP
 \&
.nf
\fBCAESAR_TYPE_NATURAL CAESAR_SIZE_STATE ()
   { ... }
\fP
.fi
This function returns the state size (in bytes), which is always greater than 0.
.sp
Implementation note: Practically, in \fBcaesar_graph.h\fP, function \fBCAESAR_SIZE_STATE()\fP is defined as follows:
 \&
.nf
\fB         #define CAESAR_SIZE_STATE() CAESAR_HINT_SIZE_STATE
\fP
.fi
where \fBCAESAR_HINT_SIZE_STATE\fP is a variable defined by:
 \&
.nf
\fB         extern CAESAR_TYPE_NATURAL CAESAR_HINT_SIZE_STATE;
\fP
.fi
This variable should be defined, properly initialized, and exported by \fBspec.c\fP. It should neither be used nor assigned in any other program than \fBspec.c\fP. This variable is only introduced for efficiency reasons, i.e., to avoid the cost of a function call.
.P
 ............................................................
.SS \fBCAESAR_HASH_SIZE_STATE\fP
 \&
.nf
\fBCAESAR_TYPE_NATURAL CAESAR_HASH_SIZE_STATE ()
   { ... }
\fP
.fi
This function returns a number of bytes N such that, for any state pointed to by a variable \fBCAESAR_S\fP, one can compute a hash function which takes into account the value of the following bytes: \fBCAESAR_S\fP [0], \fBCAESAR_S\fP [1], ... and \fBCAESAR_S\fP [N-1].
.sp
Note: It is always true that:
.TS
center;
l.
 
 0 < \fBCAESAR_HASH_SIZE_STATE ()\fP <= \fBCAESAR_SIZE_STATE ()\fP 
 
.TE
but it is possible that:
.TS
center;
l.
 
 \fBCAESAR_HASH_SIZE_STATE ()\fP < \fBCAESAR_SIZE_STATE ()\fP 
 
.TE
especially if the state vector contains variables of pointer types. By using this function, users can write their own hash functions.
.sp
Implementation note: Practically, in \fBcaesar_graph.h\fP, function \fBCAESAR_HASH_SIZE_STATE()\fP is defined as follows:
 \&
.nf
\fB         #define CAESAR_HASH_SIZE_STATE() CAESAR_HINT_HASH_SIZE_STATE
\fP
.fi
where \fBCAESAR_HINT_HASH_SIZE_STATE\fP is a variable defined by:
 \&
.nf
\fB         extern CAESAR_TYPE_NATURAL CAESAR_HINT_HASH_SIZE_STATE;
\fP
.fi
This variable should be defined, properly initialized, and exported by \fBspec.c\fP. It should neither be used nor assigned in any other program than \fBspec.c\fP. This variable is only introduced for efficiency reasons, i.e., to avoid the cost of a function call.
.P
 ............................................................
.SS \fBCAESAR_ALIGNMENT_STATE\fP
 \&
.nf
\fBCAESAR_TYPE_NATURAL CAESAR_ALIGNMENT_STATE ()
   { ... }
\fP
.fi
This function returns the alignment factor (in bytes) for states. The alignment factor is always a power of two, usually 1, 2, 4, or 8. Any byte string representing a state must be aligned on a boundary that is an even multiple of the alignment factor.
.sp
Implementation note: Practically, in \fBcaesar_graph.h\fP, function \fBCAESAR_ALIGNMENT_STATE()\fP is defined as follows:
 \&
.nf
\fB         #define CAESAR_ALIGNMENT_STATE() CAESAR_HINT_ALIGNMENT_STATE
\fP
.fi
where \fBCAESAR_HINT_ALIGNMENT_STATE\fP is a variable defined by:
 \&
.nf
\fB         extern CAESAR_TYPE_NATURAL CAESAR_HINT_ALIGNMENT_STATE;
\fP
.fi
This variable should be defined, properly initialized, and exported by \fBspec.c\fP. It should neither be used nor assigned in any other program than \fBspec.c\fP. This variable is only introduced for efficiency reasons, i.e., to avoid the cost of a function call.
.P
 ............................................................
.SS \fBCAESAR_CREATE_STATE\fP
 \&
.nf
\fBvoid CAESAR_CREATE_STATE (CAESAR_S)
   CAESAR_TYPE_STATE *CAESAR_S;
   { ... }
\fP
.fi
This procedure allocates a byte string of length \fBCAESAR_SIZE_STATE()\fP using \fBCAESAR_CREATE()\fP and assigns its address to \fB*CAESAR_S\fP. If the allocation fails, the \fBNULL\fP value is assigned to \fB*CAESAR_S\fP.
.sp
Note: because \fBCAESAR_TYPE_STATE\fP is a pointer type, any variable \fBCAESAR_S\fP of type \fBCAESAR_TYPE_STATE\fP must be allocated before used, for instance using:
.TS
center;
l.
 
 \fBCAESAR_CREATE_STATE (&CAESAR_S);\fP 
 
.TE
However, it is not necessary to use \fBCAESAR_CREATE_STATE()\fP to perform the allocation. Instead, users can allocate states into their own data structures (tables, lists, ...)
.sp
Implementation note: It is not necessary to define \fBCAESAR_CREATE_STATE()\fP in \fBspec.c\fP because \fBcaesar_graph.h\fP already implements this procedure using a macro-definition.
.P
 ............................................................
.SS \fBCAESAR_DELETE_STATE\fP
 \&
.nf
\fBvoid CAESAR_DELETE_STATE (CAESAR_S)
   CAESAR_TYPE_STATE *CAESAR_S;
   { ... }
\fP
.fi
This procedure frees the byte string of length \fBCAESAR_SIZE_STATE()\fP pointed to by \fB*CAESAR_S\fP using \fBCAESAR_DELETE()\fP. Afterwards, the \fBNULL\fP value is assigned to \fB*CAESAR_S\fP.
.sp
Implementation note: It is not necessary to define \fBCAESAR_DELETE_STATE()\fP in \fBspec.c\fP because \fBcaesar_graph.h\fP already implements this procedure using a macro-definition.
.P
 ............................................................
.SS \fBCAESAR_COPY_STATE\fP
 \&
.nf
\fBvoid CAESAR_COPY_STATE (CAESAR_S1, CAESAR_S2)
   CAESAR_TYPE_STATE CAESAR_S1;
   CAESAR_TYPE_STATE CAESAR_S2;
   { ... }
\fP
.fi
This procedure copies the state pointed to by \fBCAESAR_S2\fP onto the state pointed to by \fBCAESAR_S1\fP.
.sp
Note: Parameter \fBCAESAR_S2\fP must point to a memory location allocated before procedure \fBCAESAR_COPY_STATE()\fP is invoked.
.sp
Implementation note: It is not necessary to define \fBCAESAR_COPY_STATE()\fP in \fBspec.c\fP because \fBcaesar_graph.h\fP already implements this procedure using a macro-definition.
.P
 ............................................................
.SS \fBCAESAR_COMPARE_STATE\fP
 \&
.nf
\fBCAESAR_TYPE_BOOLEAN CAESAR_COMPARE_STATE (CAESAR_S1, CAESAR_S2)
   CAESAR_TYPE_STATE CAESAR_S1;
   CAESAR_TYPE_STATE CAESAR_S2;
   { ... }
\fP
.fi
This function returns a value different from 0 if both states pointed to by \fBCAESAR_S1\fP and \fBCAESAR_S2\fP are identical, or 0 if they are not.
.P
 ............................................................
.SS \fBCAESAR_HASH_STATE\fP
 \&
.nf
\fBCAESAR_TYPE_NATURAL CAESAR_HASH_STATE (CAESAR_S, CAESAR_MODULUS)
   CAESAR_TYPE_STATE CAESAR_S;
   CAESAR_TYPE_NATURAL CAESAR_MODULUS;
   { ... }
\fP
.fi
This function computes a hash-code value for the state pointed to by \fBCAESAR_S\fP and returns this value, which must be in the range 0..\fBCAESAR_MODULUS\fP-1.
.P
 ............................................................
.SS \fBCAESAR_FORMAT_STATE\fP
 \&
.nf
\fBvoid CAESAR_FORMAT_STATE (CAESAR_FORMAT)
   CAESAR_TYPE_FORMAT CAESAR_FORMAT;
   { ... }
\fP
.fi
This procedure allows to control the format under which states are printed by procedures \fBCAESAR_PRINT_STATE_HEADER()\fP, \fBCAESAR_PRINT_STATE()\fP, and \fBCAESAR_DELTA_STATE()\fP (see below). Currently, the following formats are available:
.sp
.IP -
If the current state format is 0, each state is printed on a single line, which should not be terminated by a new-line character (``\e\fBn\fP'').
.sp
\fICAESAR\fP-specific note: states generated from LOTOS programs are printed as a pair consisting of a marking part (marked places in the parallel components) and a context part (values of state variables).
.sp
\fICAESAR\fP-specific note: only one state format (numbered 0) is available.
.IP -
(no other format available yet).
.P
By default, the current state format is initialized to 0.
.sp
When called with \fBCAESAR_FORMAT\fP between 0 and the maximal format value supported, this fonction sets the current state format to \fBCAESAR_FORMAT\fP and returns an undefined result.
.sp
When called with another value of \fBCAESAR_FORMAT\fP, this function does not modify the current state format but returns a result defined as follows. If \fBCAESAR_FORMAT\fP is equal to the constant \fBCAESAR_CURRENT_FORMAT\fP, the result is the value of the current state format. If \fBCAESAR_FORMAT\fP is equal to the constant \fBCAESAR_MAXIMAL_FORMAT\fP, the result is the maximal format value (e.g., 0 in the case of \fICAESAR\fP). In all other cases, the effect of this function is undefined.
.P
 ............................................................
.SS \fBCAESAR_MAX_FORMAT_STATE\fP
 \&
.nf
\fBCAESAR_TYPE_FORMAT CAESAR_MAX_FORMAT_STATE ()
   { ... }
\fP
.fi
Caution! This function is deprecated. It should no longer be used, as it might be removed from future versions of the \fIOPEN/CAESAR\fP. Use function \fBCAESAR_FORMAT_STATE()\fP instead, called with argument \fBCAESAR_MAXIMAL_FORMAT\fP.
.sp
This function returns the highest format available for state printing, i.e., the highest acceptable value for the parameter \fBCAESAR_FORMAT\fP of function \fBCAESAR_FORMAT_STATE()\fP.
.P
 ............................................................
.SS \fBCAESAR_PRINT_STATE_HEADER\fP
 \&
.nf
\fBvoid CAESAR_PRINT_STATE_HEADER (CAESAR_FILE)
   CAESAR_TYPE_FILE CAESAR_FILE;
   { ... }
\fP
.fi
This procedure prints to file \fBCAESAR_FILE\fP information about the structure of states. The nature of the information is determined by the current state format (see procedure \fBCAESAR_FORMAT_STATE()\fP above). This procedure is to be used in conjunction with the next one.
.sp
Before this procedure is called, \fBCAESAR_FILE\fP must have been properly opened, for instance using \fBfopen(3)\fP.
.P
 ............................................................
.SS \fBCAESAR_PRINT_STATE\fP
 \&
.nf
\fBvoid CAESAR_PRINT_STATE (CAESAR_FILE, CAESAR_S)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_STATE CAESAR_S;
   { ... }
\fP
.fi
This procedure prints to file \fBCAESAR_FILE\fP information about the contents of the state pointed to by \fBCAESAR_S\fP. The nature of the information is determined by the current state format (see procedure \fBCAESAR_FORMAT_STATE()\fP above).
.sp
Before this procedure is called, \fBCAESAR_FILE\fP must have been properly opened, for instance using \fBfopen(3)\fP.
.P
 ............................................................
.SS \fBCAESAR_DELTA_STATE\fP
 \&
.nf
\fBvoid CAESAR_DELTA_STATE (CAESAR_FILE, CAESAR_S1, CAESAR_S2)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_STATE CAESAR_S1;
   CAESAR_TYPE_STATE CAESAR_S2;
   { ... }
\fP
.fi
This procedure prints to file \fBCAESAR_FILE\fP information about the differences (``delta'') between both states pointed to by \fBCAESAR_S1\fP and \fBCAESAR_S2\fP respectively. The nature of the information is determined by the current state format (see procedure \fBCAESAR_FORMAT_STATE()\fP above).
.sp
Before this procedure is called, \fBCAESAR_FILE\fP must have been properly opened, for instance using \fBfopen(3)\fP.
.SH LABEL FEATURES
.P
 ............................................................
.SS \fBCAESAR_BODY_LABEL\fP
 \&
.nf
\fBtypedef struct CAESAR_STRUCT_LABEL { ... } CAESAR_BODY_LABEL;
\fP
.fi
This type denotes the actual implementation of labels in the labelled transition system.
Each label is basically a structure named \fBCAESAR_STRUCT_LABEL\fP. Thus, each label is a byte string of fixed size (see function \fBCAESAR_SIZE_LABEL()\fP below) with definite alignment constraints (see function \fBCAESAR_ALIGNMENT_LABEL()\fP below), and all the labels have the same size.
In a first approach, the label representation is supposed to be ``opaque'': the detailed definition of \fBCAESAR_STRUCT_LABEL\fP and \fBCAESAR_BODY_LABEL\fP is only available in include mode, but not in link mode. Therefore, making assumptions about the fields of structure \fBCAESAR_STRUCT_LABEL\fP is not advisable.
.sp
In a refined approach, it is assumed that labels have an internal structure consisting of a \fIgate\fP (i.e., an identifier representing the name of a communication port) and a finite list of \fIexperiment offers\fP (i.e., typed data parameters exchanged on the gate).
This assumption is made without loss of generality: although the names \fIgate\fP and \fIexperiment offer\fP are borrowed from the LOTOS vocabulary, most formal description techniques for concurrent systems make a distinction between communication ports and the parameters sent or received on these ports.
.sp
Implementation note: If the transition system generated from the source program has only a single state and no transition, there are no labels at all.
In such case, the C program \fBspec.c\fP generated by the compiler tool shall nevertheless provide an implementation for all types, functions, and procedures defined in this section and related to labels.
Such an implementation will not be used (since there are no labels) but it is needed to ensure that everything compiles properly. The implementation details are left undefined: any implementation that complies with the requirements stated below, is acceptable.
.P
 ............................................................
.SS \fBCAESAR_TYPE_LABEL\fP
 \&
.nf
\fBtypedef CAESAR_TYPE_ABSTRACT (...) CAESAR_TYPE_LABEL;
\fP
.fi
This type denotes a pointer to the (opaque) representation of labels. It is given an abstract definition in file \fBcaesar_graph.h\fP and should be redefined in \fBspec.c\fP.
.sp
Concretely, \fBCAESAR_TYPE_LABEL\fP should be defined as a pointer to a structure named \fBCAESAR_STRUCT_LABEL\fP or, equivalently, a pointer to type \fBCAESAR_BODY_LABEL\fP (see above).
.P
 ............................................................
.SS \fBCAESAR_SIZE_LABEL\fP
 \&
.nf
\fBCAESAR_TYPE_NATURAL CAESAR_SIZE_LABEL ()
   { ... }
\fP
.fi
This function returns the label size (in bytes), which is always greater than 0.
.sp
Implementation note: Practically, in \fBcaesar_graph.h\fP, function \fBCAESAR_SIZE_LABEL()\fP is defined as follows:
 \&
.nf
\fB         #define CAESAR_SIZE_LABEL() CAESAR_HINT_SIZE_LABEL
\fP
.fi
where \fBCAESAR_HINT_SIZE_LABEL\fP is a variable defined by:
 \&
.nf
\fB         extern CAESAR_TYPE_NATURAL CAESAR_HINT_SIZE_LABEL;
\fP
.fi
This variable should be defined, properly initialized, and exported by \fBspec.c\fP. It should neither be used nor assigned in any other program than \fBspec.c\fP. This variable is only introduced for efficiency reasons, i.e., to avoid the cost of a function call.
.P
 ............................................................
.SS \fBCAESAR_HASH_SIZE_LABEL\fP
 \&
.nf
\fBCAESAR_TYPE_NATURAL CAESAR_HASH_SIZE_LABEL ()
   { ... }
\fP
.fi
This function returns a number of bytes N such that, for any label pointed to by a variable \fBCAESAR_L\fP, one can compute a hash function which takes into account the value of the following bytes: \fBCAESAR_L\fP [0], \fBCAESAR_L\fP [1], ... and \fBCAESAR_L\fP [N-1].
.sp
Note: It is always true that:
.TS
center;
l.
 
 0 < \fBCAESAR_HASH_SIZE_LABEL ()\fP <= \fBCAESAR_SIZE_LABEL ()\fP 
 
.TE
but it is possible that:
.TS
center;
l.
 
 \fBCAESAR_HASH_SIZE_LABEL ()\fP < \fBCAESAR_SIZE_LABEL ()\fP 
 
.TE
especially if the label vector contains variables of pointer types. By using this function, users can write their own hash functions.
.sp
Implementation note: Practically, in \fBcaesar_graph.h\fP, function \fBCAESAR_HASH_SIZE_LABEL()\fP is defined as follows:
 \&
.nf
\fB         #define CAESAR_HASH_SIZE_LABEL() CAESAR_HINT_HASH_SIZE_LABEL
\fP
.fi
where \fBCAESAR_HINT_HASH_SIZE_LABEL\fP is a variable defined by:
 \&
.nf
\fB         extern CAESAR_TYPE_NATURAL CAESAR_HINT_HASH_SIZE_LABEL;
\fP
.fi
This variable should be defined, properly initialized, and exported by \fBspec.c\fP. It should neither be used nor assigned in any other program than \fBspec.c\fP. This variable is only introduced for efficiency reasons, i.e., to avoid the cost of a function call.
.P
 ............................................................
.SS \fBCAESAR_ALIGNMENT_LABEL\fP
 \&
.nf
\fBCAESAR_TYPE_NATURAL CAESAR_ALIGNMENT_LABEL ()
   { ... }
\fP
.fi
This function returns the alignment factor (in bytes) for labels. The alignment factor is always a power of two, usually 1, 2, 4, or 8. Any byte string representing a label must be aligned on a boundary that is an even multiple of the alignment factor.
.sp
Implementation note: Practically, in \fBcaesar_graph.h\fP, function \fBCAESAR_ALIGNMENT_LABEL()\fP is defined as follows:
 \&
.nf
\fB         #define CAESAR_ALIGNMENT_LABEL() CAESAR_HINT_ALIGNMENT_LABEL
\fP
.fi
where \fBCAESAR_HINT_ALIGNMENT_LABEL\fP is a variable defined by:
 \&
.nf
\fB         extern CAESAR_TYPE_NATURAL CAESAR_HINT_ALIGNMENT_LABEL;
\fP
.fi
This variable should be defined, properly initialized, and exported by \fBspec.c\fP. It should neither be used nor assigned in any other program than \fBspec.c\fP. This variable is only introduced for efficiency reasons, i.e., to avoid the cost of a function call.
.P
 ............................................................
.SS \fBCAESAR_CREATE_LABEL\fP
 \&
.nf
\fBvoid CAESAR_CREATE_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL *CAESAR_L;
   { ... }
\fP
.fi
This procedure allocates a byte string of length \fBCAESAR_SIZE_LABEL()\fP using \fBCAESAR_CREATE()\fP and assigns its address to \fB*CAESAR_L\fP. If the allocation fails, the \fBNULL\fP value is assigned to \fB*CAESAR_L\fP.
.sp
Note: because \fBCAESAR_TYPE_LABEL\fP is a pointer type, any variable \fBCAESAR_L\fP of type \fBCAESAR_TYPE_LABEL\fP must be allocated before used, for instance using:
.TS
center;
l.
 
 \fBCAESAR_CREATE_LABEL (&CAESAR_L);\fP 
 
.TE
However, it is not necessary to use \fBCAESAR_CREATE_LABEL\fP to perform the allocation. Instead, users can allocate labels into their own data structures (tables, lists, ...)
.sp
Implementation note: It is not necessary to define \fBCAESAR_CREATE_LABEL()\fP in \fBspec.c\fP because \fBcaesar_graph.h\fP already implements this procedure using a macro-definition.
.P
 ............................................................
.SS \fBCAESAR_DELETE_LABEL\fP
 \&
.nf
\fBvoid CAESAR_DELETE_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL *CAESAR_L;
   { ... }
\fP
.fi
This procedure frees the byte string of length \fBCAESAR_SIZE_LABEL()\fP pointed to by \fB*CAESAR_L\fP using \fBCAESAR_DELETE()\fP. Afterwards, the \fBNULL\fP value is assigned to \fB*CAESAR_L\fP.
.sp
Implementation note: It is not necessary to define \fBCAESAR_DELETE_LABEL()\fP in \fBspec.c\fP because \fBcaesar_graph.h\fP already implements this procedure using a macro-definition.
.P
 ............................................................
.SS \fBCAESAR_VISIBLE_LABEL\fP
 \&
.nf
\fBCAESAR_TYPE_BOOLEAN CAESAR_VISIBLE_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }
\fP
.fi
This function returns a value different from 0 if the label pointed to by \fBCAESAR_L\fP is visible, or 0 if it is not visible (i.e., ``tau'').
.P
 ............................................................
.SS \fBCAESAR_GATE_LABEL\fP
 \&
.nf
\fBCAESAR_TYPE_STRING CAESAR_GATE_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }
\fP
.fi
This function returns a pointer to a character string containing the name of the gate associated with the label pointed to by \fBCAESAR_L\fP. If this label is not visible (i.e., ``tau''), a pointer to the constant string \fBi\fP is returned.
.sp
Note: in order to determine if the gate of the label pointed to by \fBCAESAR_L\fP is not ``tau'', using:
.TS
center;
l.
 
 \fBCAESAR_VISIBLE_LABEL (CAESAR_L)\fP 
 
.TE
is more efficient than performing a string comparison:
.TS
center;
l.
 
 \fBstrcmp (CAESAR_GATE_LABEL (CAESAR_L), "i") != 0\fP 
 
.TE
.sp
Note: It is not allowed to modify the character string returned by \fBCAESAR_GATE_LABEL()\fP nor to free it, for instance using \fBfree(3)\fP.
.sp
Note: The contents of the character string returned by \fBCAESAR_GATE_LABEL()\fP may be destroyed by a subsequent call to this function.
.P
 ............................................................
.SS \fBCAESAR_CARDINAL_LABEL\fP
 \&
.nf
\fBCAESAR_TYPE_NATURAL CAESAR_CARDINAL_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }
\fP
.fi
This function returns the number of experiment offers associated with the label pointed to by \fBCAESAR_L\fP. The gate itself does not count.
.P
 ............................................................
.SS \fBCAESAR_COPY_LABEL\fP
 \&
.nf
\fBvoid CAESAR_COPY_LABEL (CAESAR_L1, CAESAR_L2)
   CAESAR_TYPE_LABEL CAESAR_L1;
   CAESAR_TYPE_LABEL CAESAR_L2;
   { ... }
\fP
.fi
This procedure copies the label pointed to by \fBCAESAR_L2\fP onto the label pointed to by \fBCAESAR_L1\fP.
.sp
Note: Parameter \fBCAESAR_L2\fP must point to a memory location allocated before procedure \fBCAESAR_COPY_LABEL()\fP is invoked.
.sp
Implementation note: It is not necessary to define \fBCAESAR_COPY_LABEL()\fP in \fBspec.c\fP because \fBcaesar_graph.h\fP already implements this procedure using a macro-definition.
.P
 ............................................................
.SS \fBCAESAR_COMPARE_LABEL\fP
 \&
.nf
\fBCAESAR_TYPE_BOOLEAN CAESAR_COMPARE_LABEL (CAESAR_L1, CAESAR_L2)
   CAESAR_TYPE_LABEL CAESAR_L1;
   CAESAR_TYPE_LABEL CAESAR_L2;
   { ... }
\fP
.fi
This function returns a value different from 0 if both labels pointed to by \fBCAESAR_L1\fP and \fBCAESAR_L2\fP are identical, or 0 if they are not.
.P
 ............................................................
.SS \fBCAESAR_HASH_LABEL\fP
 \&
.nf
\fBCAESAR_TYPE_NATURAL CAESAR_HASH_LABEL (CAESAR_L, CAESAR_MODULUS)
   CAESAR_TYPE_LABEL CAESAR_L;
   CAESAR_TYPE_NATURAL CAESAR_MODULUS;
   { ... }
\fP
.fi
This function computes a hash-code value for the label pointed to by \fBCAESAR_L\fP and returns this value, which must be in the range 0..\fBCAESAR_MODULUS\fP-1.
.P
 ............................................................
.SS \fBCAESAR_PRINT_LABEL\fP
 \&
.nf
\fBvoid CAESAR_PRINT_LABEL (CAESAR_FILE, CAESAR_L)
   CAESAR_TYPE_FILE CAESAR_FILE;
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }
\fP
.fi
This procedure prints to file \fBCAESAR_FILE\fP a character string describing the contents of the label pointed to by \fBCAESAR_L\fP. This string should not contain the special characters new-line (``\e\fBn\fP'') or carriage-return (``\e\fBr\fP''). If the label is not visible, the string printed is \fBi\fP.
.sp
Before this procedure is called, \fBCAESAR_FILE\fP must have been properly opened, for instance using \fBfopen(3)\fP.
.P
 ............................................................
.SS \fBCAESAR_STRING_LABEL\fP
 \&
.nf
\fBCAESAR_TYPE_STRING CAESAR_STRING_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }
\fP
.fi
This function returns a pointer to a character string (terminated by the \fB`\fP\e\fB0'\fP character) describing the contents of the label pointed to by \fBCAESAR_L\fP. This string should not contain the special characters new-line (``\e\fBn\fP'') or carriage-return (``\e\fBr\fP''). If the label is not visible, the string returned is \fBi\fP.
.sp
Note: It is not allowed to modify the character string returned by \fBCAESAR_STRING_LABEL()\fP nor to free it, for instance using \fBfree(3)\fP.
.sp
Note: The contents of the character string returned by \fBCAESAR_STRING_LABEL()\fP may be destroyed by a subsequent call to this function.
.P
 ............................................................
.SS \fBCAESAR_FORMAT_LABEL\fP
 \&
.nf
\fBvoid CAESAR_FORMAT_LABEL (CAESAR_FORMAT)
   CAESAR_TYPE_FORMAT CAESAR_FORMAT;
   { ... }
\fP
.fi
This procedure allows to control the format under which the information attached to labels is displayed by the procedure \fBCAESAR_INFORMATION_LABEL()\fP (see below).
.sp
\fICAESAR\fP-specific note: 3 different label formats (numbered from 0 to 2) are available.
.sp
By default, the current label format is initialized to 0.
.sp
When called with \fBCAESAR_FORMAT\fP between 0 and the maximal format value supported, this fonction sets the current label format to \fBCAESAR_FORMAT\fP and returns an undefined result.
.sp
When called with another value of \fBCAESAR_FORMAT\fP, this function does not modify the current label format but returns a result defined as follows. If \fBCAESAR_FORMAT\fP is equal to the constant \fBCAESAR_CURRENT_FORMAT\fP, the result is the value of the current label format. If \fBCAESAR_FORMAT\fP is equal to the constant \fBCAESAR_MAXIMAL_FORMAT\fP, the result is the maximal format value (e.g., 2 in the case of \fICAESAR\fP). In all other cases, the effect of this function is undefined.
.P
 ............................................................
.SS \fBCAESAR_MAX_FORMAT_LABEL\fP
 \&
.nf
\fBCAESAR_TYPE_FORMAT CAESAR_MAX_FORMAT_LABEL ()
   { ... }
\fP
.fi
Caution! This function is deprecated. It should no longer be used, as it might be removed from future versions of the \fIOPEN/CAESAR\fP. Use function \fBCAESAR_FORMAT_LABEL()\fP instead, called with argument \fBCAESAR_MAXIMAL_FORMAT\fP.
.sp
This function returns the highest format available for label printing, i.e., the highest acceptable value for the parameter \fBCAESAR_FORMAT\fP of function \fBCAESAR_FORMAT_LABEL()\fP.
.P
 ............................................................
.SS \fBCAESAR_INFORMATION_LABEL\fP
 \&
.nf
\fBCAESAR_TYPE_STRING CAESAR_INFORMATION_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }
\fP
.fi
This function returns a character string containing additional information about the label pointed to by \fBCAESAR_L\fP. The nature of the information is determined by the current label format (see procedure \fBCAESAR_FORMAT_LABEL()\fP above). If the current label format is null, this function returns the empty string ``''.
.sp
Note: It is not allowed to modify the character string returned by \fBCAESAR_INFORMATION_LABEL()\fP nor to free it, for instance using \fBfree(3)\fP.
.sp
Note: The contents of the character string returned by \fBCAESAR_INFORMATION_LABEL()\fP may be destroyed by a subsequent call to this function.
.sp
\fICAESAR\fP-specific note: Currently, the following formats are available:
.sp
.IP -
If the current label format is 0: the empty string ``'' is returned.
.IP -
If the current label format is 1: if the label L pointed to by \fBCAESAR_L\fP is visible, the empty string ``'' is returned; if L is not visible and derives from some gate G hidden by a \fBhide\fP instruction, a character string containing the name of G, its definition file and definition line is returned; if L is not visible and derives from an \fBexit\fP statement, the constant character string \fBexit\fP is returned; if L is not visible and derives from an \fBi; ...\fP statement, the constant character string \fBi\fP is returned.
.IP -
If the current label format is 2: a character string containing the (unique) number of the Petri Net transition corresponding to the edge whose label is pointed to by \fBCAESAR_L\fP is returned. This transition can be found in the \fB.net\fP file generated by \fICAESAR\fP with \fB-network\fP option.
.P
.SH EDGE FEATURES
.P
 ............................................................
.SS \fBCAESAR_START_STATE\fP
 \&
.nf
\fBvoid CAESAR_START_STATE (CAESAR_S)
   CAESAR_TYPE_STATE CAESAR_S;
   { ... }
\fP
.fi
This procedure copies into the state pointed to by \fBCAESAR_S\fP the contents of the initial state of the labelled transition system.
.sp
Note: Parameter \fBCAESAR_S\fP must point to a memory location allocated before procedure \fBCAESAR_START_STATE()\fP is invoked.
.P
 ............................................................
.SS \fBCAESAR_ITERATE_STATE\fP
 \&
.nf
\fBvoid CAESAR_ITERATE_STATE (CAESAR_S1, CAESAR_L, CAESAR_S2, CAESAR_LOOP)
   CAESAR_TYPE_STATE CAESAR_S1;
   CAESAR_TYPE_LABEL CAESAR_L;
   CAESAR_TYPE_STATE CAESAR_S2;
   void (*CAESAR_LOOP) (CAESAR_TYPE_STATE, CAESAR_TYPE_LABEL,
      CAESAR_TYPE_STATE);
   { ... }
\fP
.fi
This procedure provides an iterator which enumerates all successors of the state pointed to by \fBCAESAR_S1\fP. At each iteration, the label pointed to by \fBCAESAR_L\fP and the state pointed to by \fBCAESAR_S2\fP are assigned a new value, such that ``(\fBCAESAR_S1\fP, \fBCAESAR_L\fP, \fBCAESAR_S2\fP)'' is an edge of the labelled transition system. At each iteration, the C function pointed to by \fBCAESAR_LOOP\fP is invoked, with the following parameters:
.TS
center;
l.
 
 \fB(*CAESAR_LOOP) (CAESAR_S1, CAESAR_L, CAESAR_S2)\fP 
 
.TE
.sp
.sp
Therefore, any actual parameter supplied for the formal parameter \fBCAESAR_LOOP\fP must be a pointer to a function, say \fBcaesar_f\fP, whose declaration is:
.sp
 \&
.nf
\fB        void caesar_f (caesar_s1, caesar_l, caesar_s2)
           CAESAR_TYPE_STATE caesar_s1;
           CAESAR_TYPE_LABEL caesar_l;
           CAESAR_TYPE_STATE caesar_s2;
           {...}
\fP
.fi
Note: Parameters \fBCAESAR_S1\fP, \fBCAESAR_L\fP, and \fBCAESAR_S2\fP must point to (distinct) memory locations allocated before procedure \fBCAESAR_ITERATE_STATE()\fP is invoked. In no event will \fBCAESAR_ITERATE_STATE()\fP and \fBCAESAR_LOOP()\fP allocate memory for storing \fBCAESAR_L\fP and \fBCAESAR_S2\fP.
.sp
Note: More often than not, this function will have side-effects. For instance, this function may count the number of successors, or store them in a list, a table, ...
.sp
Note: It is probably a good programming style to keep the body of this function as short as possible.
.sp
Note: The C code that implements \fBCAESAR_ITERATE_STATE()\fP in \fBspec.c\fP may be not reentrant. In such case, nested iterations will not work properly. This implies that any actual parameter \fBcaesar_f\fP supplied to formal parameter \fBCAESAR_LOOP\fP must not call (directly, nor transitively) \fBCAESAR_ITERATE_STATE\fP.
Practically, this restriction has no effect on breadth-first explorations. However, it affects the way of writing depth-first explorations: for a given state S, it is necessary first to compute all successors of S and to store them in some data structure, before starting to explore these successors.
.sp
\fICAESAR\fP-specific note: The C code generated by \fICAESAR\fP for \fBCAESAR_ITERATE_STATE()\fP is not reentrant (at least in the current version).
.SH OBSOLETE FEATURES
.P
 ............................................................
.SS \fBCAESAR_DUMP_LABEL\fP
 \&
.nf
\fBvoid CAESAR_DUMP_LABEL (CAESAR_STRING, CAESAR_L)
   CAESAR_TYPE_STRING CAESAR_STRING;
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }
\fP
.fi
This procedure has been removed from the ``graph module'' application programming interface in October 2002 and should no longer be implemented, nor used in \fIOPEN/CAESAR\fP application programs.
.P
 ............................................................
.SS \fBCAESAR_RANK_LABEL\fP
 \&
.nf
\fBCAESAR_TYPE_NATURAL CAESAR_RANK_LABEL (CAESAR_L)
   CAESAR_TYPE_LABEL CAESAR_L;
   { ... }
\fP
.fi
This function has been removed from the ``graph module'' application programming interface in October 2002 and should no longer be implemented, nor used in \fIOPEN/CAESAR\fP application programs.
.P
 ............................................................
.SH AUTHOR(S)
Hubert Garavel
.SH FILES
.PD 0
.TP 30
.B $CADP/incl/caesar_graph.h
interface of the graph module
.TP
.B $CADP/incl/caesar_*.h
interfaces of the storage module
.TP
.B $CADP/bin.`arch`/libcaesar.a
object code of the storage module
.TP
.B $CADP/src/open_caesar/*.c
source code of various exploration modules
.TP
.B $CADP/com/lotos.open
shell script to run OPEN/CAESAR
.PD
.SH SEE ALSO
Reference Manuals of OPEN/CAESAR, CAESAR, and CAESAR.ADT,
.BR lotos.open (LOCAL),
.BR caesar (LOCAL),
.BR caesar.adt (LOCAL)
.P
Additional information is available from the CADP Web page located at http://cadp.inria.fr
.P
Directives for installation are given in files
.B $CADP/INSTALLATION_*.
.P
Recent changes and improvements to this software are reported
and commented in file
.B $CADP/HISTORY.
.SH BUGS
Known bugs are described in the Reference Manual of OPEN/CAESAR.
Please report new bugs to cadp@inria.fr
