/******************************************************************************
 *   			            C A D P
 *-----------------------------------------------------------------------------
 *   INRIA - Centre de Recherche de Grenoble Rhone-Alpes
 *   655, avenue de l'Europe
 *   38330 Montbonnot Saint Martin
 *   FRANCE
 *-----------------------------------------------------------------------------
 *   Module		:	adt_gate.h
 *   Auteur		:	Hubert GARAVEL
 *   Version		:	1.21
 *   Date		: 	2017/09/26 18:49:05
 *****************************************************************************/

#if defined (ADT_GATE_ADT_ALREADY_INCLUDED)
#undef ADT_GATE_ADT_DEFINITIONS
#elif defined (ADT_X_GATE)
#define ADT_GATE_ADT_ALREADY_INCLUDED
#define ADT_GATE_ADT_DEFINITIONS
#endif

#if defined (ADT_GATE_BCG_ALREADY_INCLUDED)
#undef ADT_GATE_BCG_DEFINITIONS
#elif defined (BCG_PREDEFINED_DECLARATIONS_INTERFACE)
#define ADT_GATE_BCG_ALREADY_INCLUDED
#define ADT_GATE_BCG_DEFINITIONS
#endif

#if defined (ADT_GATE_XTL_ALREADY_INCLUDED)
#undef ADT_GATE_XTL_DEFINITIONS
#elif defined (XTL_STANDARD_INTERFACE)
#define ADT_GATE_XTL_ALREADY_INCLUDED
#define ADT_GATE_XTL_DEFINITIONS
#endif

/*---------------------------------------------------------------------------*/
/* Gate type / Includes and preliminary definitions                          */
/*---------------------------------------------------------------------------*/

#if defined (ADT_GATE_BCG_DEFINITIONS)

#include <ctype.h>		/* for isalpha() and isalnum() */

/*
 * at this point, one assumes that a macro bcg_gate_size is defined, which
 * gives the number of bits with which values of type bcg_type_gate are
 * encoded
 */

/*
 * at this point, one assumes that a macro bcg_nb_gates is defined, which
 * gives the number of different gates; the special gate "i" is always
 * included, even if the BCG file contains no hidden transition; however, in
 * the particular case of a BCG file generated by former versions of CADP
 * between CADP 2008-b included and CADP 2014-l included, this macro is not
 * defined and the present file will remedy this
 */

/*
 * at this point, one also assumes that bcg_gate_size and bcg_nb_gates are
 * both strictly positive; if not, the present file should not be included,
 * as it means that the BCG file does not contain the "gate" type, nor any
 * function attached to this type, nor any value of this type
 */

#include "bcg_compress.h"
#include "bcg_push_pull.h"
#include "bcg_object_2.h"
#include "bcg_structure_2.h"
#include "bcg_name.h"
#include "bcg_read_2.h"

BCG_TYPE_BCG_OBJECT bcg_gate_bcg_object = NULL;
/* cette variable sera initialisee par bcg_gate_init() */

#if !defined (bcg_nb_gates)
/*
 * cas des fichiers produits entre CADP 2008-b inclus et CADP 2014-l inclus :
 * leur zone des inclusions ne comporte aucune information sur le nombre de
 * portes ; on doit recalculer ce dernier dynamiquement
 */
BCG_TYPE_NATURAL bcg_nb_gates;
/* cette variable sera initialisee par bcg_gate_init() */
#endif

void bcg_gate_init (bcg_bcg_object, bcg_file_name)
BCG_TYPE_BCG_OBJECT bcg_bcg_object;
BCG_TYPE_C_STRING bcg_file_name;
{
     BCG_TYPE_BCG_FILE bcg_bcg_file;

     bcg_gate_bcg_object = bcg_bcg_object;
     if (BCG_NAME_1 (bcg_gate_bcg_object) == NULL) {
	  BCG_OPEN (&bcg_bcg_file, bcg_file_name, "r");
	  if (bcg_bcg_file == NULL) {
	       /*
	        * normalement, ce cas ne devrait pas arriver, sauf si le
	        * fichier BCG dont le nom est bcg_file_name a ete supprime,
	        * deplace, corrompu ou rendu illisible entre temps
	        */
	       sprintf (BCG_ASSERT_BUFFER, "file ``%s'' is unreadable\n", bcg_file_name);
	       BCG_ERROR ("adt_gate.h", BCG_ASSERT_BUFFER, BCG_TRUE);
	  }
	  BCG_READ_AREA (bcg_gate_bcg_object, bcg_bcg_file, BCG_NAME_AREA, (BCG_TYPE_READ_PROFILE_FUNCTION) NULL);
	  BCG_CLOSE (bcg_bcg_file);
     }
#if !defined (bcg_nb_gates)
     /*
      * cas des fichiers produits entre CADP 2008-b inclus et CADP 2014-l
      * inclus : le nombre de portes est egal au nombre d'entrees dans la
      * table des noms moins deux (un pour le nom root, un pour le nom GATE)
      */
     bcg_nb_gates = BCG_AN1_NB_NAMES (BCG_NAME_1 (bcg_gate_bcg_object)) - 2;
#endif
}

#endif

/*---------------------------------------------------------------------------*/
/* Gate type / Implementation                                                */
/*---------------------------------------------------------------------------*/

#if defined (ADT_GATE_BCG_DEFINITIONS)

typedef BCG_TYPE_NATURAL bcg_type_gate;
/*
 * values of bcg_type_gate are in the range 0 ... bcg_nb_gates-1; value 0
 * corresponds to the non-observable gate "i"
 */

#endif

/*---------------------------------------------------------------------------*/
/* Gate type / Size in bits                                                  */
/*---------------------------------------------------------------------------*/

#if defined (ADT_GATE_BCG_DEFINITIONS)

/*
 * here, in all possible cases, a macro-definition or a variable named
 * bcg_gate_size must exist in the scope; it gives the number of bits on
 * which values of type bcg_type_gate are encoded
 */

#endif

/*---------------------------------------------------------------------------*/
/* Gate type / Scalarity                                                     */
/*---------------------------------------------------------------------------*/

/* scalar */

/*---------------------------------------------------------------------------*/
/* Gate type / Assignment                                                    */
/*---------------------------------------------------------------------------*/

#if defined (ADT_GATE_BCG_DEFINITIONS)

#define bcg_gate_assign(bcg_1,bcg_2) ((bcg_1) = (bcg_2))

#endif

/*---------------------------------------------------------------------------*/
/* Gate type / Canonicity                                                    */
/*---------------------------------------------------------------------------*/

/* not uncanonical */

/*---------------------------------------------------------------------------*/
/* Gate type / Equality                                                      */
/*---------------------------------------------------------------------------*/

#if defined (ADT_GATE_BCG_DEFINITIONS)

#define bcg_gate_cmp(bcg_1,bcg_2) ((bcg_1) == (bcg_2))

#endif

/*---------------------------------------------------------------------------*/
/* Gate type / Iteration                                                     */
/*---------------------------------------------------------------------------*/

#if defined (ADT_GATE_BCG_DEFINITIONS)

#define bcg_gate_enum(bcg_0) for ((bcg_0) = 0; (bcg_0) < bcg_nb_gates; ++(bcg_0))

#endif

/*---------------------------------------------------------------------------*/
/* Gate type / Print                                                         */
/*---------------------------------------------------------------------------*/

#if defined (ADT_GATE_BCG_DEFINITIONS)
#if defined (BCG_PREDEFINED_DECLARATIONS_SPECIAL_INCLUSION_1)

extern void bcg_gate_print BCG_ARG_2 (BCG_TYPE_STREAM, bcg_type_gate);

#else

void bcg_gate_print (bcg_file, bcg_0)
BCG_TYPE_STREAM bcg_file;
bcg_type_gate bcg_0;
{
     /* the gate number N corresponds to the (N+2)-th entry in the name table */
     /* entry 0 in the name table corresponds to the "root" name */
     /* entry 1 in the name table corresponds to the "GATE" name */
     /* entry 2 in the name table corresponds to gate "i", which has number 0 */
     BCG_PRINT_SIMPLE_NAME ((bcg_file), bcg_gate_bcg_object, (BCG_TYPE_NAME_NUMBER) ((bcg_0) + 2));
}

#endif
#endif

/*---------------------------------------------------------------------------*/
/* Gate type / Scan                                                          */
/*---------------------------------------------------------------------------*/

#if defined (ADT_GATE_BCG_DEFINITIONS)
#if defined (BCG_PREDEFINED_DECLARATIONS_SPECIAL_INCLUSION_1)

extern BCG_TYPE_SCAN_RESULT bcg_gate_scan BCG_ARG_2 (BCG_TYPE_C_STRING, BCG_TYPE_C_STRING *);

#else

BCG_TYPE_SCAN_RESULT bcg_gate_scan (bcg_text, bcg_gate)
BCG_TYPE_C_STRING bcg_text;
BCG_TYPE_C_STRING /* not bcg_type_gate */ * bcg_gate;
{
     char *bcg_g;

     bcg_g = bcg_text;
     if (!isalpha (*bcg_g))
	  return (BCG_SCAN_NOK);

     for (++bcg_g; *bcg_g != '\0'; ++bcg_g)
	  if (!isalnum (*bcg_g) && (*bcg_g != '_'))
	       return (BCG_SCAN_NOK);

     *bcg_gate = bcg_text;
     return (BCG_SCAN_OK);
}

#endif
#endif

/*---------------------------------------------------------------------------*/
/* Gate type / Binary write                                                  */
/*---------------------------------------------------------------------------*/

#if defined (ADT_GATE_BCG_DEFINITIONS)
#if defined (BCG_PREDEFINED_DECLARATIONS_SPECIAL_INCLUSION_1)

extern void bcg_gate_write BCG_ARG_3 (BCG_TYPE_STREAM, bcg_type_gate, BCG_TYPE_NATURAL *);

#else

void bcg_gate_write (bcg_file, bcg_gate, bcg_size)
BCG_TYPE_STREAM bcg_file;
bcg_type_gate bcg_gate;
BCG_TYPE_NATURAL *bcg_size;
{
     /* assert (bcg_gate_size > 0) */
     BCG_PUSH_WRITE_FILE (bcg_file);
     BCG_WRITE_UNSIGNED (bcg_gate, (BCG_TYPE_NATURAL) bcg_gate_size);
     *bcg_size = bcg_gate_size;
     BCG_PULL_WRITE_FILE ();
}

#endif
#endif

/*---------------------------------------------------------------------------*/
/* Gate type / Binary read                                                   */
/*---------------------------------------------------------------------------*/

#if defined (ADT_GATE_BCG_DEFINITIONS)
#if defined (BCG_PREDEFINED_DECLARATIONS_SPECIAL_INCLUSION_1)

extern void bcg_gate_read BCG_ARG_3 (BCG_TYPE_STREAM, bcg_type_gate *, BCG_TYPE_NATURAL *);

#else

void bcg_gate_read (bcg_file, bcg_gate, bcg_size)
BCG_TYPE_STREAM bcg_file;
bcg_type_gate *bcg_gate;
BCG_TYPE_NATURAL *bcg_size;
{
     /* assert (bcg_gate_size > 0) */
     BCG_PUSH_READ_FILE (bcg_file);
     BCG_READ_UNSIGNED (bcg_gate, (BCG_TYPE_NATURAL) bcg_gate_size);
     *bcg_size = bcg_gate_size;
     BCG_PULL_READ_FILE ();
}

#endif
#endif

/*---------------------------------------------------------------------------*/
/* Gate type / End of list                                                   */
/*---------------------------------------------------------------------------*/
