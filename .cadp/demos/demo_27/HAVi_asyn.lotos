specification leader_election
              [ginfo, gUpDown, gBusReset, gDMin, gDMout, gEvent]
              : noexit

library BOOLEAN endlib
library MY_NATURAL endlib


type Message is BOOLEAN, MY_NATURAL
   sorts Message1, Message2, MesFrame
   opns
     init_leader     (*! constructor *),
     final_leader    (*! constructor *),
     bus_reset_start (*! constructor *),
     bus_reset_end   (*! constructor *),
     bus_reset_event (*! constructor *),
     power_change    (*! constructor *),
     GUID_list       (*! constructor *),
     empty           (*! constructor *) : -> Message1

     DMInitRequest (*! constructor *),
     DMInitReply     (*! constructor *) : -> Message2

     _==_ : Message2, Message2 -> Bool
     _<>_ : Message2, Message2 -> Bool

     consm (*! constructor *) : Message2, Nat, Bool -> MesFrame
     mes   : MesFrame -> Message2
     id    : MesFrame -> Nat
     UrlCapable : MesFrame -> Bool

   eqns forall   m,m1,m2: Message2, n:Nat, b:Bool

        ofsort Message2
           mes(consm(m,n,b)) = m
        ofsort Nat
           id(consm(m,n,b)) = n
        ofsort Bool
           UrlCapable(consm(m,n,b)) = b;
           DMInitRequest == DMInitRequest = true;
           DMInitReply == DMInitReply = true;
           DMInitReply == DMInitRequest = false;
           DMInitRequest == DMInitReply = false;
           m1 <> m2 = not(m1 == m2)
endtype

type MessageList is Message
  sorts Buffer
  opns
    emptyb  (*! constructor *) : -> Buffer
    addb    (*! constructor *) : MesFrame, Buffer -> Buffer
    headb   : Buffer -> MesFrame
    tailb   : Buffer -> Buffer

  eqns forall   l : Buffer,
                e : MesFrame

       ofsort MesFrame
          headb(addb(e,l))  = e

       ofsort Buffer
          tailb(emptyb)     = emptyb;
          tailb(addb(e,l))  = l

endtype

type EnrichedMessageList is MessageList
   opns
     append: MesFrame, Buffer -> Buffer
     length: Buffer -> Nat
     MaxBuf: -> Nat
   eqns forall m,m1,m2: MesFrame, buf:Buffer
        ofsort Buffer
           append(m,emptyb) = addb(m,emptyb);
           append(m1,addb(m2,buf)) = addb(m2,append(m1,buf))
        ofsort Nat
           length(emptyb) = 0;
           length(addb(m,buf))= 1 + length(buf);
           MaxBuf = 1
endtype

type Node is BOOLEAN, MY_NATURAL
   sorts Node
   opns
     consn (*! constructor *) : Bool -> Node
     up   : Node -> Bool
     count_up : Node -> Nat
   
   eqns forall n:Node, b1,b2:Bool
        ofsort Bool
           up(consn(b2)) = b2;
        ofsort Nat
           up(n) => count_up(n) = 1;
           not(up(n)) => count_up(n) = 0;

endtype


type NodeTuple is Node
  sorts Network
  opns
    consnet (*! constructor *) : Node, Node -> Network
    firstn  : Network -> Node
    secondn : Network -> Node

  eqns forall   l : Network,
                n1,n2 : Node

       ofsort Node
          firstn(consnet(n1,n2))  = n1;
          secondn(consnet(n1,n2))  = n2;


endtype

type EnrichedNodeTuple is NodeTuple
   opns
     nr_uphosts : Network -> Nat
     flip : Nat, Network -> Network
     i_leader: Network -> Nat
   eqns forall n1,n2,n3,n4: Node
        ofsort Network
           flip(1,consnet(n1,n2))
               = consnet(consn(not(up(n1))),n2);
           flip(2,consnet(n1,n2))
               = consnet(n1,consn(not(up(n2))));
        ofsort Nat
           nr_uphosts(consnet(n1,n2))
               = count_up(n1) + count_up(n2);
           up(n1) => i_leader(consnet(n1,n2)) = 1;
           not(up(n1)) and up(n2) => i_leader(consnet(n1,n2)) = 2;
           not(up(n1)) and not(up(n2)) =>
               i_leader(consnet(n1,n2)) = 0;
endtype 

type Host is BOOLEAN, MY_NATURAL
   sorts Host
   opns
     consh (*! constructor *) : Nat, Bool, Bool -> Host
     id      : Host -> Nat
     UrlCapable   : Host -> Bool
     rec_req : Host -> Bool
   
   eqns forall n:Nat, b1:Bool, b2:Bool
        ofsort Nat
           id(consh(n,b1,b2)) = n
        ofsort Bool
           UrlCapable(consh(n,b1,b2)) = b1;
           rec_req(consh(n,b1,b2)) = b2
endtype

type HostList is Host
  sorts Hosts
  opns
    emptyh  (*! constructor *) : -> Hosts
    addh    (*! constructor *) : Host, Hosts -> Hosts
    headh   : Hosts -> Host
    tailh   : Hosts -> Hosts

  eqns forall   l : Hosts,
                e : Host

       ofsort Host
          headh(addh(e,l))  = e

       ofsort Hosts
          tailh(emptyh)     = emptyh;
          tailh(addh(e,l))  = l

endtype

type EnrichedHostList is HostList, EnrichedNodeTuple
   opns
     _==_: Hosts, Hosts -> Bool
     _<>_: Hosts, Hosts -> Bool
     init_hosts: Network -> Hosts
     chge_rec: Nat, Bool, Hosts -> Hosts
     rec: Nat, Hosts -> Bool
     f_leader: Nat, Hosts -> Nat
   eqns forall host,host1,host2: Host, hosts,hosts1,hosts2: Hosts,
               n1,n2,n3:Node, n:Nat, b:Bool
        ofsort Bool
           emptyh == emptyh = true;
           addh(host,hosts) == emptyh = false;
           emptyh == addh(host,hosts) = false;
           addh(host1,hosts1) == addh(host2,hosts2)
           = ((id(host1)==id(host2)) and ((UrlCapable(host1) iff UrlCapable(host2))
             and ((rec_req(host1) iff rec_req(host2)) and (hosts1==hosts2))));
           hosts1 <> hosts2 = not(hosts1 == hosts2);
        ofsort Hosts
           not(up(n1)) and not(up(n2)) =>
             init_hosts(consnet(n1,n2))
               = emptyh;
           not(up(n1)) and up(n2) =>
             init_hosts(consnet(n1,n2))
               = addh(consh(2,false,false),emptyh);
           up(n1) and not(up(n2)) =>
             init_hosts(consnet(n1,n2))
               = addh(consh(1,false,false),emptyh);
           up(n1) and up(n2) =>
             init_hosts(consnet(n1,n2))
               = addh(consh(1,false,false),
                 addh(consh(2,false,false),emptyh));
           chge_rec(n,b,emptyh) = emptyh;
           (n <> id(host)) =>
               chge_rec(n,b,addh(host,hosts)) = addh(host,chge_rec(n,b,hosts));
           (n == id(host)) =>
               chge_rec(n,b,addh(host,hosts)) = addh(consh(n,b,true),hosts)
        ofsort Bool
               rec(n,emptyh) = true;	
           (n<>id(host)) =>
               rec(n,addh(host,hosts)) = rec(n,hosts);
           (n==id(host)) =>
               rec(n,addh(host,hosts)) = rec_req(host)
        ofsort Nat
           f_leader(n,emptyh) = n;
           not(UrlCapable(host)) =>
               f_leader(n,addh(host,hosts)) = f_leader(n,hosts);
           UrlCapable(host) =>
               f_leader(n,addh(host,hosts)) = id(host)
endtype


behaviour

LE [ ginfo, gUpDown, gBusReset, gDMin, gDMout, gEvent ]
   ( consnet(consn(false), consn(false)) ) (* all dcms down *)

where

    process LE [ gInfo, gUpDown, gBusReset, gDMin, gDMout, gEvent ]
               ( net:Network )
      : noexit :=

      ( BusReset[gUpDown,gBusReset,gEvent] (net)
      )

      |[gUpDown, gBusReset]|

      ( ( DCM [gInfo,gUpDown,gDMin,gDMout,gEvent](1)
          |||
          DCM [gInfo,gUpDown,gDMin,gDMout,gEvent](2)
        )
        |[gInfo,gUpDown,gDMin,gDMout]|
        ( ( CMM[gInfo,gUpDown,gBusReset](1)
            |[gBusReset]|
            CMM[gInfo,gUpDown,gBusReset](2)
          )
          |[gUpDown,gBusReset]|
          ( MS[gUpDown,gBusReset,gDMout,gDMin](1)	(* DM's out is MS's in and vv *)
            |[gBusReset]|
            MS[gUpDown,gBusReset,gDMout,gDMin](2)	(* DM's out is MS's in and vv *)
          )
        )
      )
    endproc (* LE *)

    process BusReset [ gUpDown, gBusReset , gEvent ]
            ( net: Network )

      : noexit :=
      
      gBusReset ! bus_reset_start 
      ; BusReset2[gUpDown,gBusReset,gEvent]
        (net,1)

      where

        process BusReset2 [ gUpDown, gBusReset, gEvent ]
                (net: Network, j:Nat)

          : noexit :=

        ( [j==0]
            -> ( gBusReset !  bus_reset_end ! net
                 ; BusReset[gUpDown,gBusReset,gEvent](net)
               )
        )
        []
        ( [j<>0]
            -> ( ( gUpDown ! j ! power_change
                   ; BusReset2[gUpDown,gBusReset,gEvent]
                     (flip(j,net),j+1)
                 )
                 []
                 ( i
                   ; BusReset2[gUpDown,gBusReset,gEvent]
                     (net,j+1)
                 )
               )
        )
        endproc (* BusReset2 *)

    endproc (* BusReset *)

    process FlushBusReset[gBusReset]
      : noexit :=

      ( gBusReset ! bus_reset_start
        ; FlushBusReset[gBusReset] )
      []
      ( choice b1,b2:Bool
        [] ( gBusReset ! bus_reset_end ! consnet(consn(b1),consn(b2))
             ; FlushBusReset[gBusReset] ) )

    endproc (* FlushBusReset *)

    process CMM[ gInfo, gUpDown, gBusReset ]
            ( Id: Nat ) 
      : noexit :=

      CMMDown[gInfo,gUpDown,gBusReset](Id)

    where

      process CMMDown[ gInfo, gUpDown, gBusReset ]
              ( Id: Nat ) 
        : noexit :=

        FlushBusReset[gBusReset]
        [> ( gUpDown ! Id ! power_change
             ; ( choice b1,b2:Bool
                 [] gBusReset ! bus_reset_end ! consnet(consn(b1),consn(b2))
                 ; CMMUp[gInfo,gUpDown,gBusReset]
                   (Id,consnet(consn(b1),consn(b2))) ) )
      endproc (* CMMDown *)

      process CMMUp[ gInfo, gUpDown, gBusReset ]
              ( Id: Nat , net: Network ) 
        : noexit :=

        CMMReady[gInfo,gUpDown,gBusReset](Id,net)
        [> ( gUpDown ! Id ! power_change
             ; CMMDown[gInfo,gUpDown,gBusReset](Id) )

      where
        process CMMReady[ gInfo, gUpDown, gBusReset ]
              ( Id: Nat , net: Network )
        : noexit :=

        ( gInfo ! Id ! GUID_list ! net
          ; CMMReady[gInfo,gUpDown,gBusReset](Id,net) )
        []
        ( gBusReset ! bus_reset_start
          ; CMMDeliver[gInfo,gUpDown,gBusReset](Id) )

        endproc (* CMMReady *)

        process CMMDeliver[ gInfo, gUpDown, gBusReset ]
              ( Id: Nat )
        : noexit :=

        ( gInfo ! Id ! bus_reset_event
          ; ( choice b1,b2:Bool
              [] (gBusReset ! bus_reset_end ! consnet(consn(b1),consn(b2))
                  ; CMMReady[gInfo,gUpDown,gBusReset]
                    (Id,consnet(consn(b1),consn(b2))))))
        []
        ( choice b1,b2:Bool
                 [] (gBusReset ! bus_reset_end ! consnet(consn(b1),consn(b2))
                     ; CMMDeliver2 [gInfo,gUpDown,gBusReset]
                       (Id,consnet(consn(b1),consn(b2))) 
                    )
        )
        endproc (* CMMDeliver *)

        process CMMDeliver2[ gInfo, gUpDown, gBusReset ]
              ( Id: Nat , net: Network )
        : noexit :=

        ( gInfo ! Id ! GUID_list ! net
          ; CMMDeliver2[gInfo,gUpDown,gBusReset] (Id,net) )
        []
        ( gInfo ! Id ! bus_reset_event
          ; CMMReady[gInfo,gUpDown,gBusReset] (Id,net) )
        []
        ( gBusReset ! bus_reset_start
          ; CMMDeliver[gInfo,gUpDown,gBusReset](Id) )
        endproc (* CMMDeliver2 *)

      endproc (* CMMUp *)

    endproc (* CMM *)

    process MS[ gUpDown, gBusReset, gin, gout ]
            ( Id: Nat ) 
      : noexit :=

      MSDown[gUpDown,gBusReset,gin,gout](Id)

    where

      process MSDown[ gUpDown, gBusReset, gin, gout ]
              ( Id: Nat ) 
        : noexit :=

        FlushBusReset[gBusReset]
        [> ( gUpDown ! Id ! power_change
             ; MsUp[gUpDown,gBusReset,gin,gout](Id,emptyb) )

      endproc (* MSDown *)

      process MSUp[ gUpDown, gBusReset, gin, gout ]
              ( Id: Nat, buf: Buffer ) 
        : noexit :=

        MSSuspend[gUpDown,gBusReset,gin,gout](Id,buf)
        [> gUpDown ! Id ! power_change
             ; MSDown[gUpDown,gBusReset,gin,gout](Id)

        where

        process MSSuspend[ gUpDown, gBusReset, gin, gout ]
                ( Id: Nat, buf: Buffer ) 
          : noexit :=

          ( gin ! Id ! empty
            ; MSSuspend[gUpDown,gBusReset,gin,gout] (Id,emptyb) )
          []
          ( [length(buf)>0]
             -> ( gout ! Id ! headb(buf)
                  ; MSSuspend[gUpDown,gBusReset,gin,gout] (Id,tailb(buf)) ) )
          []
          ( choice b1,b2:Bool
            [] (gBusReset ! bus_reset_end ! consnet(consn(b1),consn(b2))
                ; MSReady[gUpDown,gBusReset,gin,gout](Id,buf)) )

        endproc (* MSSuspend *)

        process MSReady[ gUpDown, gBusReset, gin, gout ]
                ( Id: Nat, buf: Buffer ) 
          : noexit :=

          ( [length(buf)<maxBuf]
            -> ( choice m:Message2,j:Nat,b:Bool
                 [] gin ! Id ! consm(m,j,b)
                    ; MSReady[gUpDown,gBusReset,gin,gout]
                      (Id,append(consm(m,j,b),buf)) ) )
          []
          ( gin ! Id ! empty
            ; MSReady[gUpDown,gBusReset,gin,gout] (Id,emptyb) )
          []
          ( [length(buf)>0]
            -> ( gout ! Id ! headb(buf)
                 ; MSReady[gUpDown,gBusReset,gin,gout] (Id,tailb(buf)) ) )
          []
          ( gBusReset ! bus_reset_start
            ; MSSuspend[gUpDown,gBusReset,gin,gout](Id,buf) )
        endproc (* MSReady *)

      endproc (* MSUp *)

    endproc (* MS *)

    process DCM_Manager[ ginfo, gUpDown, gDMin, gDMout, gEvent ]
            ( Id: Nat , UrlCapable: Bool ) 

      : noexit :=

      downDM[ginfo,gUpDown,gDMin,gDMout,gEvent](Id,UrlCapable)

      where

        process downDM[ ginfo, gUpDown, gDMin, gDMout, gEvent ]
                ( Id: Nat , UrlCapable: Bool )
          : noexit :=

          stop
          [> (gUpDown! Id ! power_change		(* Disrupt !! *)
              ; leDM[ginfo,gUpDown,gDMin,gDMout,gEvent]
                (Id,UrlCapable) )

        endproc (* downDM *)

        process leDM[ ginfo, gUpDown, gDMin, gDMout, gEvent ]
                ( Id: Nat , UrlCapable: Bool )
          : noexit :=

          ( choice b1,b2:Bool 
            [] gInfo ! Id ! GUID_list ! consnet(consn(b1),consn(b2))
               ; ( [i_leader(consnet(consn(b1),consn(b2)))==Id]
                     -> gEvent ! init_leader ! Id
                        ; ilDM[gDMin,gDMout,gEvent]
                          (Id,UrlCapable,consnet(consn(b1),consn(b2)))
                   []
                   [i_leader(consnet(consn(b1),consn(b2)))<>Id]
                     -> ifDM[gDMin,gDMout,gEvent]
                        (Id,UrlCapable,consnet(consn(b1),consn(b2)),
                         i_leader(consnet(consn(b1),consn(b2))))
               )
          )
          [> ( ( gInfo ! Id ! bus_reset_event		(* Disrupt !! *)
                 ; ( gDMout ! Id ! empty
                     ; leDM[ginfo,gUpDown,gDMin,gDMout,gEvent](Id,UrlCapable))
                   []
                   ( gUpDown ! Id ! power_change
                     ; downDM[ginfo,gUpDown,gDMin,gDMout,gEvent](Id,UrlCapable))
               )
               []
               ( gUpDown ! Id ! power_change
                 ; downDM[ginfo,gUpDown,gDMin,gDMout,gEvent](Id,UrlCapable))
             )
        endproc (* leDM *)

        process ifDM[ gDMin, gDMout, gEvent ]
                ( Id: Nat , UrlCapable: Bool , net: Network , leader: Nat )
          : noexit :=

          DeclareCapability[ gDMin, gDMout, gEvent](Id,UrlCapable,leader)

          [> ( choice j:Nat, b:Bool
               [] gDMin ! Id ! consm(DMInitReply,j,b)
                  ; ( [j==Id]
                        -> gEvent ! final_leader ! Id ! UrlCapable
                           ; flDM[gDMin,gDMout,gEvent]
                              (Id,UrlCapable,net)
                      []
                      [j<>Id]
                        -> ffDM[gDMin,gDMout,gEvent]
                               (Id,UrlCapable,net,j)
                 )
              )

          where
            process DeclareCapability[ gDMin, gDMout, gEvent ]
                    ( Id:Nat , UrlCapable: Bool , leader: Nat )
            : noexit :=
              (gDMout ! leader ! consm(DMInitRequest,Id,UrlCapable)
               ; DeclareCapability[gDMin,gDMout,gEvent](Id,UrlCapable,leader))
              []
              (choice j:Nat, b:Bool
               [] gDMin ! Id ! consm(DMInitRequest,j,b)
                  ; DeclareCapability[gDMin,gDMout,gEvent](Id,UrlCapable,leader))
            
            endproc (* DeclareCapability *)
        endproc (* ifDM *)

        process ilDM[ gDMin, gDMout, gEvent ]
                ( Id: Nat , UrlCapable: Bool , net: Network )
          : noexit :=

          Elect[gDMin,gDMout,gEvent]
               (Id,UrlCapable,net,init_hosts(net),nr_uphosts(net))

          where
            process Elect[ gDMin, gDMout, gEvent ]
                    ( Id: Nat , UrlCapable: Bool , net: Network ,
                      hosts: Hosts, nr: Nat)
              : noexit :=
                ([nr==1]
                  -> DeclareLeader[gDMin,gDMout,gEvent]
                     (Id,UrlCapable,net,hosts,f_leader(Id,chge_rec(Id,UrlCapable,hosts))))
                []
                ([nr>1]
                  -> ( choice m:Message2,j:Nat,b:Bool
                       [] gDMin ! Id ! consm(m,j,b)
                       ; ( ([m==DMInitRequest and not(rec(j,hosts))]
                           -> Elect[gDMin,gDMout,gEvent]
                              (Id,UrlCapable,net,chge_rec(j,b,hosts),nr-1))
                           []
                           ([m<>DMInitRequest or rec(j,hosts)]
                           -> Elect[gDMin,gDMout,gEvent]
                              (Id,UrlCapable,net,hosts,nr))
                         )
                     ))
            endproc (* Elect *)

            process DeclareLeader[ gDMin, gDMout, gEvent ]
                    ( Id: Nat , UrlCapable: Bool , net: Network ,
                      hosts: hosts , leader: Nat )
              : noexit :=
                ([hosts==emptyh]
                  -> ( [leader==Id]
                         -> (gEvent ! final_leader ! Id ! UrlCapable
                             ; fliDM[gDMin,gDMout,gEvent]
                               (Id,UrlCapable,net))
                       []
                       [leader<>Id]
                         -> (gDMout ! leader ! consm(DMInitReply,leader,false)
                             ; ffiDM[gDMin,gDMout,gEvent]
                               (Id,UrlCapable,net,leader))
                     ))
                []
                ([hosts<>emptyh] -> [(id(headh(hosts))==Id)or(id(headh(hosts))==leader)]
                  -> DeclareLeader[gDMin,gDMout,gEvent]
                     (Id,UrlCapable,net,tailh(hosts),leader))
                []
                ([hosts<>emptyh] -> [(id(headh(hosts))<>Id)and(id(headh(hosts))<>leader)]
                  -> (gDMout ! id(headh(hosts)) ! consm(DMInitReply,leader,false)
                     ; DeclareLeader[gDMin,gDMout,gEvent]
                       (Id,UrlCapable,net,tailh(hosts),leader)))
            endproc (* DeclareLeader *)

        endproc (* ilDM *)

        process ffDM[ gDMin, gDMout, gEvent ]
                ( Id: Nat , UrlCapable: Bool , net: Network , leader: Nat )
          : noexit :=

            choice m:Message2,j:Nat,b:Bool
            [] gDMin ! Id ! consm(m,j,b)
               ; ffDM[gDMin,gDMout,gEvent] (Id,UrlCapable,net,leader)

        endproc (* flDM *)

        process ffiDM[ gDMin, gDMout, gEvent ]
                ( Id: Nat , UrlCapable: Bool , net: Network , leader: Nat )
          : noexit :=

          ( choice m:Message2,j:Nat,b:Bool
            [] gDMin ! Id ! consm(m,j,b)
               ; ( ([m==DMInitRequest]
                    -> (gDMout ! j ! consm(DMInitReply,leader,false)
                        ; ffiDM[gDMin,gDMout,gEvent]
                          (Id,UrlCapable,net,leader)))
                 []
                   ([m<>DMInitRequest]
                    -> ffiDM[gDMin,gDMout,gEvent]
                       (Id,UrlCapable,net,leader))
                 )
          )

        endproc (* ffiDM *)

        process flDM[ gDMin, gDMout, gEvent ]
                ( Id: Nat , UrlCapable: Bool , net: Network )
          : noexit :=

            choice m:Message2,j:Nat,b:Bool
            [] gDMin ! Id ! consm(m,j,b)
               ; flDM[gDMin,gDMout,gEvent] (Id,UrlCapable,net)

        endproc (* flDM *)

        process fliDM[ gDMin, gDMout, gEvent ]
                ( Id: Nat , UrlCapable: Bool , net: Network )
          : noexit :=

          ( choice m:Message2,j:Nat,b:Bool
            [] gDMin ! Id ! consm(m,j,b)
               ; ( ([m==DMInitRequest]
                    -> (gDMout ! j ! consm(DMInitReply,Id,false)
                        ; fliDM[gDMin,gDMout,gEvent]
                          (Id,UrlCapable,net)))
                 []
                   ([m<>DMInitRequest]
                    -> fliDM[gDMin,gDMout,gEvent]
                       (Id,UrlCapable,net))
                 )
          )

        endproc (* fliDM *)

    endproc (* DCM_Manager *)

    process DCM [gInfo, gUpDown, gDMin, gDMout, gEvent] (Id : Nat) : noexit :=
       DCM_Manager [gInfo, gUpDown, gDMin, gDMout, gEvent] (Id, true)
       []
       DCM_Manager [gInfo, gUpDown, gDMin, gDMout, gEvent] (Id, false)
    endproc (* DCM *)

endspec (* leader_election *)

