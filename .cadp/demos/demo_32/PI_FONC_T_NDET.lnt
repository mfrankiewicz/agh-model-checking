(******************************************************************************
 *             Sequentially consistent, distributed cache memory
 *-----------------------------------------------------------------------------
 *   INRIA - Unite de Recherche Rhone-Alpes
 *   655, avenue de l'Europe
 *   38330 Montbonnot Saint Martin
 *   FRANCE
 *-----------------------------------------------------------------------------
 *   Module       :       PI_FONC_T_NDET.lnt
 *   Authors      :       A. Kriouile, W. Serwe, and H. Garavel
 *   Version      :       1.2
 *   Date         :       2016/01/08 11:47:23
 *****************************************************************************)

-- contains the functional version with non-deterministic tail on buffer Inn

-- on buffer Out, tail (dequeue) is always deterministic as every element can
-- be written at most once

module PI_fonc_T_NDET (TYPES_COMMON) is

process PI [diag                 : BUF_NAT_CHANNEL, 
            sync                 : NONE, 
            w, r, mw, cu, mr, cl : INDEX_ELEM_CHANNEL] (ind : INDEX) is
   var el          : ELEM, 
       j           : INDEX, 
       AD          : SET_OF_ELEM, 
       C           : MEM_OF_ELEM, 
       Output, Inn : BUF_OF_ELEM
   in
      AD := empt_s;
      C := empt_m;
      Output := empt_b;
      Inn := empt_b;
      loop
         sync;
         select
            -- for DEBUGGING
            only if Inn == overflow then 
               diag (overflow, 1 of NAT)
            end if
          []
            only if Output == overflow then
               diag (overflow, 2 of NAT)
            end if
            -- end DEBUGGING
          []
            el := any ELEM;
            w (ind, el) where notIsIn (AD, el) and datum (ind, el);
            AD := Insert (AD, el);
            Output := Enqueue (Output, el, false)
          []
            el := any ELEM; 
            r (ind, el)
               where ok (C, el) and (empty (Output) and empty_true (Inn))
          []
            el := any ELEM;
            select
               mw (ind, el)
                  where first (Output, el) and
                        not (((el == eps) or empty (Output)) or
                             (Output == overflow));
               Output := Dequeue (Output);
               Inn := Enqueue (Inn, el, true)
             []
               mw (ind, el)
                  where first (Output, el) and
                        ((Output == overflow) or (el == eps));
               Inn := Enqueue (Inn, el, true)
            end select
          []
            mw (?j, ?el) where not (j == ind);
            Inn := Enqueue (Inn, el, false)
          []
            el := any ELEM;
            select 
               cu (ind, el) where first (Inn, el);
               C := Insert (C, el)
             []
               cu (ind, el)
                  where first (Inn, el) and
                        not (((el == eps) or (Inn == overflow)) or empty (Inn));
               C := Insert (C, el);
               Inn := Dequeue (Inn)
            end select
          []
            -- the condition "not (ok (C, el)) and NotIn (Inn, el)" is added
            -- in order to have a bit less idle transitions
            mr (ind, ?el) where not (ok (C, el)) and NotIn (Inn, el);
            Inn := Enqueue (Inn, el, false)
          []
            -- the condition "not (el == eps)" is only added to have a bit less
            -- idle transitions
            el := any ELEM;
            cl (ind, el) where ok (C, el) and not (el == eps);
            C := cl (C, el)
          []
            -- passive synchros when other processes are active
            r (?j, ?any ELEM) where not (j == ind)
          []
            w (?j, ?any ELEM) where not (j == ind)
          []
            cu (?j, ?any ELEM) where not (j == ind)
          []
            mr (?j, ?any ELEM) where not (j == ind)
          []
            cl (?j, ?any ELEM) where not (j == ind)
         end select
      end loop
   end var
end process (* PI *)

end module
