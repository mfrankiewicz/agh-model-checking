#-----------------------------------------------------------------------------
#                        S V L
#-----------------------------------------------------------------------------
#   INRIA Rhone-Alpes / VASY
#   655, avenue de l'Europe
#   38330 MONTBONNOT ST MARTIN cedex
#-----------------------------------------------------------------------------
#   Module             :       standard
#   Auteur             :       Frederic Lang
#   Version            :       1.369
#   Date               :       2020/02/12 14:06:52
#-----------------------------------------------------------------------------

##################################################
# TO BE INCLUDED IN ALL SCRIPTS GENERATED BY SVL #
##################################################

# The following sets the order of file lists obtained by pathname expansion
# to be independent from the architecture
LC_COLLATE=POSIX
export LC_COLLATE

###############
# SVL OPTIONS #
###############

SVL_SILENT=""  # If other than "" then writes less on the output
SVL_DEBUG=""   # If other than "" then do not remove temporary generated files
SVL_IGNORE=""  # If other than "" then do not stop on error

# Exit code when no error
SVL_EXIT_CODE=0

###############################################
# TOOL OPTIONS UPDATEABLE IN THE USER'S SHELL #
###############################################

ALDEBARAN_OPTIONS=""
BCG_OPTIONS=""
BCG_CMP_OPTIONS=""
BCG_GRAPH_OPTIONS=""
BCG_IO_OPTIONS_INPUT=""
BCG_IO_OPTIONS_OUTPUT=""
BCG_LABELS_OPTIONS=""
BCG_MIN_OPTIONS=""
BCG_OPEN_OPTIONS=""
BISIMULATOR_OPTIONS=""
CAESAR_ADT_OPTIONS=""
CAESAR_OPTIONS=""
EVALUATOR_OPTIONS=""
EVALUATOR4_OPTIONS=""
EVALUATOR5_OPTIONS=""
EXHIBITOR_OPTIONS=""
EXP_OPEN_OPTIONS=""
FSP_OPEN_OPTIONS=""
GENERATOR_OPTIONS=""
LNT_OPEN_OPTIONS=""
LOTOS_OPEN_OPTIONS=""		# replaces obsolete $CAESAR_OPEN_OPTIONS
PROJECTOR_OPTIONS=""
REDUCTOR_OPTIONS=""
SEQ_OPEN_OPTIONS=""
XTL_OPTIONS=""

BCG_OPEN_CC_OPTIONS=""
EXP_OPEN_CC_OPTIONS=""
FSP_OPEN_CC_OPTIONS=""
LNT_OPEN_CC_OPTIONS=""
LOTOS_OPEN_CC_OPTIONS=""	# replaces obsolete $CAESAR_OPEN_CC_OPTIONS
SEQ_OPEN_CC_OPTIONS=""

###############
# EXECUTABLES #
###############

ALDEBARAN_EXECUTABLE="aldebaran"
BCG_CMP_EXECUTABLE="bcg_cmp"
BCG_GRAPH_EXECUTABLE="bcg_graph"
BCG_IO_EXECUTABLE="bcg_io"
BCG_LABELS_EXECUTABLE="bcg_labels"
BCG_MIN_EXECUTABLE="bcg_min"
BCG_OPEN_EXECUTABLE="bcg_open"
BISIMULATOR_EXECUTABLE="bisimulator"
CAESAR_ADT_EXECUTABLE="caesar.adt"
CAESAR_EXECUTABLE="caesar"
EVALUATOR_EXECUTABLE="evaluator"
EVALUATOR3_EXECUTABLE="evaluator3"
EVALUATOR4_EXECUTABLE="evaluator4"
EVALUATOR5_EXECUTABLE="evaluator5"
EXHIBITOR_EXECUTABLE="exhibitor"
EXP_OPEN_EXECUTABLE="exp.open"
EXP2C_EXECUTABLE="exp2c"
FSP_OPEN_EXECUTABLE="fsp.open"
GENERATOR_EXECUTABLE="generator"
LNT_DEPEND_EXECUTABLE="lnt_depend"
LNT_OPEN_EXECUTABLE="lnt.open"
LOTOS_OPEN_EXECUTABLE="lotos.open"	# replaces obsolete $CAESAR_OPEN_EXECUTABLE
PROJECTOR_EXECUTABLE="projector"
REDUCTOR_EXECUTABLE="reductor"
SEQ_OPEN_EXECUTABLE="seq.open"
XTL_EXECUTABLE="xtl"

#################################################
# DEFAULT SVL VALUES UPDATEABLE IN USER'S SHELL #
#################################################

DEFAULT_REDUCTION_TOOL="default"	# One of aldebaran, bcg_min, or default
DEFAULT_COMPARISON_TOOL="default"  	# One of bisimulator, bcg_cmp, aldebaran, or default
DEFAULT_LIVELOCK_TOOL="evaluator"	# One of aldebaran, evaluator, evaluator3, evaluator4, or evaluator5
DEFAULT_DEADLOCK_TOOL="exhibitor"	# One of aldebaran, exhibitor
DEFAULT_VERIFY_TOOL="evaluator"		# One of evaluator, evaluator3, evaluator4, or evaluator5
DEFAULT_REDUCTION_METHOD="default"      # One of std, bdd, fly
DEFAULT_COMPARISON_METHOD="default"    	# One of std, bdd, fly, dfs, bfs, or default
DEFAULT_VERIFY_METHOD="dfs"		# One of dfs, bfs, acyclic
DEFAULT_REDUCTION_RELATION="strong"  	# One of strong, trace, observational, 
DEFAULT_COMPARISON_RELATION="strong" 	# branching, tau*.a, safety, weak trace 
DEFAULT_PROCESS_FILE=""			# A lotos/lnt/lts (FSP) file or nothing
# this variable replaces DEFAULT_LOTOS_FILE, which is now obsolete

DEFAULT_MAX_INDENT=80			# Max indent for SVL generated files
DEFAULT_SMART_LIMIT=4			# Default 1st parameter for exp2c -smart

DEFAULT_MCL_LIBRARIES=			# comma-separated list of MCL libs
DEFAULT_EVALUATOR3_LIBRARIES=		# comma-separated list of MCL libs
DEFAULT_EVALUATOR4_LIBRARIES=		# comma-separated list of MCL libs
DEFAULT_EVALUATOR5_LIBRARIES=		# comma-separated list of MCL libs
DEFAULT_XTL_LIBRARIES=			# comma-separated list of XTL libs

##############
# PROPERTIES #
##############
PROPERTY_DISPLAY_MODE="0"		# != "0" to display verification details

PROPERTY_COMMENT_PRINT=1		# set to 0 for not printing
PROPERTY_COMMENT_OPEN=""
PROPERTY_COMMENT_MIDDLE=" | "
PROPERTY_COMMENT_CLOSE=""

############
# LOG FILE #
############

SVL_LOG_FILE="`basename "$0"`.log"
2>>"$SVL_LOG_FILE" rm -f "$SVL_LOG_FILE"
touch "$SVL_LOG_FILE"

SVL_CADP_ARCH=`"$CADP"/com/arch`
SVL_TMP_PREFIX="svl000"

SVL_ERROR_FILE_COUNT=0

SVL_DISPLAY_FILE=
SVL_INDENTING=

ECHO="$CADP"/src/com/cadp_echo
export ECHO

# to avoid stdin/stdout mess up
PAGER="cat"
export PAGER

SVL_PROPERTY_CURRENT_DEPTH=0
SVL_PROPERTY_UNIT_INDENTING="     "
SVL_PROPERTY_EXPECT_VALUE=ANY

SVL_GLOBAL_VERSION=`svl -version`

#############################################
# SVL MACROS CALLED FROM THE CURRENT PROLOG #
#############################################

SVL_TIME () {
    ####
    # using `SVL_TIME`<command> instead of "$CADP_TIME" <command> avoids
    # superflouous space characters in the .log file when $CADP_TIME is
    # unset
    ####
    if test "$CADP_TIME" != ""
    then
	# return the value of $CADP_TIME followed by a space
	"$ECHO" "$CADP_TIME "
    fi
}

#-----------------------------------------------------------------------------

SVL_EXPR () {
    ####
    # expr can return a non-zero value even if the evaluation succeeds, in
    # particular if the expression is 0 ; this has svl fail in debug mode,
    # due to the positionning of "set -e" ; this macro circumvents the
    # problem
    ####
    expr "$@" || true
}

#-----------------------------------------------------------------------------

SVL_GREP () {
    ####
    # grep can return a non-zero value even if the evaluation succeeds, in
    # particular if the searched regular expression does not match any line
    # in the input
    ####
    grep "$@" || true
}

#-----------------------------------------------------------------------------

SVL_EGREP () {
    ####
    # egrep can return a non-zero value even if the evaluation succeeds, in
    # particular if the searched regular expression does not match any line
    # in the input
    ####
    egrep "$@" || true
}

#-----------------------------------------------------------------------------

SVL_BASENAME_OPEN_CAESAR_TOOL () {
    ####
    # $1 is the name of an Open/Caesar back-end (extension .c, .o, .a, or none)
    ####
    case "$1" in
    *.o)
	"$CADP"/src/com/cadp_basename "$1" .o
	;;
    *.a)
	"$CADP"/src/com/cadp_basename "$1" .a
	;;
    *.c)
	"$CADP"/src/com/cadp_basename "$1" .c
	;;
    *)
	"$CADP"/src/com/cadp_basename "$1"
    esac
}

#-----------------------------------------------------------------------------

SVL_EXECUTE () {
    ####
    # $1 is the command to execute
    # $2 is either empty or a filter that must be applied to $1's stdout
    # stdout is redirected to $SVL_LOG_FILE and then the filtered output is
    # redirected to stdout (i.e., stdout is empty if $2 = "")
    # $3 is either empty or a filter that must be applied to $1 output
    # when writing it to the log file
    # if $4 is set, then no error message is issued in case of failure
    ####
    SVL_PRINT_LOG_MESSAGE ""
    SVL_PRINT_LOG_MESSAGE "% $1"

    if test "$2" = ""
    then
	# $1's stdout and stderr are directly written to the log file
	eval "$1" 1>> "$SVL_LOG_FILE" 2>&1
	SVL_LOCAL_COMMAND_EXIT_STATUS=$?
    else
	# $1's stdout cannot be piped to $2 immediately, because we
	# need to get $1's exit status first ; so $1's stdout is
	# first written to a temporary file that will be processed
	# afterwards
	SVL_LOCAL_STDOUT_REDIRECT_FILE="${SVL_TMP_PREFIX}_stdout"
	rm -f "$SVL_LOCAL_STDOUT_REDIRECT_FILE"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_STDOUT_REDIRECT_FILE"
	eval "$1" 1>> "$SVL_LOCAL_STDOUT_REDIRECT_FILE" 2>> "$SVL_LOG_FILE"
	SVL_LOCAL_COMMAND_EXIT_STATUS=$?
    fi

    if test "$3" = ""
    then
	SVL_LOCAL_LOG_FILTER=tee
    else
	SVL_LOCAL_LOG_FILTER="$3"
    fi

    if test "$2" != ""
    then
	# processing $1's stdout stored in temporary file
	cat "$SVL_LOCAL_STDOUT_REDIRECT_FILE" |
		$SVL_LOCAL_LOG_FILTER >> "$SVL_LOG_FILE"
	if test "$SVL_DISPLAY_FILE" != ""
	then
	    cat "$SVL_LOCAL_STDOUT_REDIRECT_FILE" | $2
	    SVL_LAST_RESULT=`cat "$SVL_DISPLAY_FILE" |
		tr -d '\015' |
		sed -e '/^[ ]*$/d' |
		$CADP/src/com/cadp_tail -n 1`
	else
	    cat "$SVL_LOCAL_STDOUT_REDIRECT_FILE" | $2 |
		tee "${SVL_LOCAL_STDOUT_REDIRECT_FILE}_2"
	    SVL_LAST_RESULT=`cat "${SVL_LOCAL_STDOUT_REDIRECT_FILE}_2" |
		tr -d '\015' |
		sed -e '/^[ ]*$/d' |
		$CADP/src/com/cadp_tail -n 1`
	    # we do not use SVL_REMOVE to remove the following file
	    # but "rm -f" so that it is removed even in debug mode
	    rm -f "${SVL_LOCAL_STDOUT_REDIRECT_FILE}_2"
	fi
	# we do not use SVL_REMOVE to remove the following file
	# but "rm -f" so that it is removed even in debug mode
	rm -f "$SVL_LOCAL_STDOUT_REDIRECT_FILE"
    fi

    SVL_PRINT_LOG_MESSAGE "command exit with status $SVL_LOCAL_COMMAND_EXIT_STATUS"

    if test "$SVL_LOCAL_COMMAND_EXIT_STATUS" != "0"
    then
        if test "$4" != ""
        then
	    SVL_FAILED_FLAG="1"
	else
	    SVL_ERROR "command failed"
	fi
    fi
}

#-----------------------------------------------------------------------------

SVL_FILTER_ALDEBARAN () {
    SVL_GREP -v diagnostic |
	tr -d '\015' |
	sed -e 's/No livelock/FALSE/' |
	sed -e 's/There are livelocks/TRUE/' |
	sed -e 's/list of deadlock state(s):/TRUE/' |
	sed -e 's/no deadlock state/FALSE/' |
	sed -e 's/\*\*\* no sequence found/FALSE/' |
	sed -e 's/\*\*\* sequence found .*/TRUE/' |
	SVL_FILTER_BOOLEAN_GENERIC |
	tee -a "$SVL_LOG_FILE"
}

#-----------------------------------------------------------------------------

SVL_FILTER_EXHIBITOR () {
    {
	if test "$1" != ""
	then
	    SVL_EGREP -v '^bcg_open[ ]*:' |
	    SVL_EGREP -v '^exp.open[ ]*:' |
	    SVL_EGREP -v '^fsp.open[ ]*:' |
	    SVL_EGREP -v '^lnt.open[ ]*:' |
	    SVL_EGREP -v '^lotos.open[ ]*:' |
	    SVL_EGREP -v '^seq.open[ ]*:' |
	    SVL_EGREP -v '^exp2c[ ]*:' |
	    SVL_EGREP -v "cadp_cc" |
            grep -v '^$' |
	    tee "$1"
	else
	    tee
	fi
    } | sed -e 's/\*\*\* no sequence found/FALSE/' |
	sed -e 's/\*\*\* sequence found .*/TRUE/' |
	SVL_FILTER_BOOLEAN_GENERIC |
	tee -a "$SVL_LOG_FILE"
}

#-----------------------------------------------------------------------------

SVL_FILTER_EXHIBITOR_LOG () {
    tr -d '\015' | sed -e '/^[ ]*$/d'
}

#-----------------------------------------------------------------------------

SVL_FILTER_XTL () {
    tr -d '\015' | SVL_EGREP -v '^xtl[ ]*:' | sed -e '/^$/d' | SVL_FILTER_FINAL
}

#-----------------------------------------------------------------------------

SVL_FILTER_EVALUATOR5 () {
    tr -d '\015' | SVL_EGREP -e '^(TRUE|FALSE|[0-9.Ee+-]*)$' | sed -e '/^$/d' | SVL_FILTER_FINAL
}

#-----------------------------------------------------------------------------

SVL_FILTER_BOOLEAN_GENERIC () {
    tr -d '\015' | SVL_EGREP -e '^(TRUE|FALSE)$' | head -n 1 | SVL_FILTER_FINAL
}

#-----------------------------------------------------------------------------

SVL_FILTER_FINAL () {
    if test "$SVL_DISPLAY_FILE" = ""
    then
	# no expected value: display on screen without indenting after an
	# empty line
	{ "$ECHO"; tee ;}
    else
	# an expected value was set
	if test "$PROPERTY_DISPLAY_MODE" = 0
	then
	    # do not show verification result, just redirect to display file
	    tee > "$SVL_DISPLAY_FILE"
	else
	    # show verification result with indenting and copy to display file
	    tee "$SVL_DISPLAY_FILE" | { "$ECHO"; sed -e "s/^/$SVL_INDENTING/";}
	fi
    fi
}

#-----------------------------------------------------------------------------

SVL_COMMAND_FOR_CLEAN () {
    ####
    # $1 is a command to record to $SVL_LOG_FILE
    # this command will be executed by svl -clean
    ####
    SVL_PRINT_LOG_MESSAGE
    SVL_PRINT_LOG_MESSAGE "svl clean command: $1"
}

#-----------------------------------------------------------------------------

SVL_RECORD_FOR_CLEAN () {
    ####
    # $1 is a file to record to $SVL_LOG_FILE
    ####
    SVL_PRINT_LOG_MESSAGE
    SVL_PRINT_LOG_MESSAGE "svl clean info: [persistent] $1"
}

#-----------------------------------------------------------------------------

SVL_RECORD_FOR_SWEEP () {
    ####
    # $1 is a file to record to $SVL_LOG_FILE
    ####
    SVL_PRINT_LOG_MESSAGE
    SVL_PRINT_LOG_MESSAGE "svl clean info: [temporary] $1"
}

#-----------------------------------------------------------------------------

SVL_PRINT_LOG_MESSAGE () {
    ####
    # $1 is the message to print in the log file
    ####
    "$ECHO" "$1" >> "$SVL_LOG_FILE"
}

#-----------------------------------------------------------------------------

SVL_PRINT_MESSAGE () {
    ####
    # $1 is the message to print in non silent mode
    ####
    if test "$SVL_SILENT" = ""
    then
	# Non silent mode
	"$ECHO" "$SVL_INDENTING$1" | tee -a "$SVL_LOG_FILE"
    else
	# Silent mode
	"$ECHO" "$SVL_INDENTING$1" >> "$SVL_LOG_FILE"
    fi
}

#-----------------------------------------------------------------------------

SVL_PRINT_NEWLINE () {
    SVL_PRINT_MESSAGE ""
}

#-----------------------------------------------------------------------------

SVL_EXTENSION () {
    ####
    # $1 is a file name whose extension is recognized by SVL
    # echo the extension
    ####
    case "$1" in
    *.seq)    "$ECHO" "seq";;
    *.fc2)    "$ECHO" "fc2";;
    *.bcg)    "$ECHO" "bcg";;
    *.exp)    "$ECHO" "exp";;
    *.sync)   "$ECHO" "sync";;
    *.aut)    "$ECHO" "aut";;
    *.hide)   "$ECHO" "hide";;
    *.hid)    "$ECHO" "hid";;
    *.lotos)  "$ECHO" "lotos";;
    *.lot)    "$ECHO" "lot";;
    *.lnt)    "$ECHO" "lnt";;
    *.lts)    "$ECHO" "lts";;
    *.rename) "$ECHO" "rename";;
    *.ren)    "$ECHO" "ren";;
    *.cut)    "$ECHO" "cut";;
    *.mcl)    "$ECHO" "mcl";;
    *.xtl)    "$ECHO" "xtl";;
    esac
}

#-----------------------------------------------------------------------------

SVL_PREFIX () {
    ####
    # $1 is a file name whose extension is recognized by SVL
    # echo the prefix of the file
    ####
    "$CADP"/src/com/cadp_basename "$1" .`SVL_EXTENSION "$1"`
}

#-----------------------------------------------------------------------------

SVL_TYPE () {
    ####
    # $1 is the name of a file whose extension is known by SVL
    # echo the type of the file
    # Types are seq, fc2, bcg, exp, sync, aut, hid, lot, lnt, lts, ren
    ####
    SVL_LOCAL_ARG_EXTENSION=`SVL_EXTENSION "$1"`
    case "$SVL_LOCAL_ARG_EXTENSION" in 
    hide) 
	"$ECHO" "hid";;
    lotos)
	"$ECHO" "lot";;
    rename)
	"$ECHO" "ren";;
    *) 
	"$ECHO" "$SVL_LOCAL_ARG_EXTENSION";;
    esac
}

#-----------------------------------------------------------------------------

SVL_ALDEBARAN_OPTION_RELATION () {
    ####
    # $1 is the relation strong, observational, branching, tau*.a or safety
    # echo the option required by aldebaran to use this relation
    # or "" if none available
    ####
    case "$1" in
    "strong") 
	"$ECHO" "-b";;
    "observational") 
	"$ECHO" "-o";;
    "branching") 
	"$ECHO" "-p";;
    "tau*.a") 
	"$ECHO" "-i";;
    "safety") 
	"$ECHO" "-s";;
    esac
}

#-----------------------------------------------------------------------------

SVL_BISIMULATOR_OPTION_RELATION () {
    ####
    # $1 is the relation strong, observational, branching, tau*.a, safety,
    # trace, or weak trace
    # echo the option required by bisimulator to use this relation
    ####
    case "$1" in
    "tau*.a")
	"$ECHO" "-taustar";;
    "weak trace")
	"$ECHO" "-weaktrace";;
    *)
	"$ECHO" "-$1";;
    esac
}

#-----------------------------------------------------------------------------

SVL_BCG_MIN_BCG_CMP_REDUCTOR_OPTION_RELATION () {
    ####
    # $1 is the relation 
    # echo the option required by bcg_min or reductor
    # to use this relation or "" if none available
    ####
    case "$1" in
    "strong")
	"$ECHO" "-strong";;
    "branching")
	"$ECHO" "-branching";;
    "divbranching")
	"$ECHO" "-divbranching";;
    "observational")
	"$ECHO" "-observational";;
    "weak trace")
	"$ECHO" "-weaktrace";;
    trace)
	"$ECHO" "-trace";;
    tau*.a)
	"$ECHO" "-taustar";;
    safety)
	"$ECHO" "-safety";;
    tau-confluence)
	"$ECHO" "-tauconfluence";;
    tau-compression)
	"$ECHO" "-taucompression";;
    tau-divergence)
	"$ECHO" "-taudivergence";;
    esac
}

#-----------------------------------------------------------------------------

SVL_WARNING () {
    ####
    # Warnings issued by svl
    # $* is the warning message, one argument per line
    ####
    "$ECHO" | tee -a "$SVL_LOG_FILE"
    "$ECHO" "svl: WARNING $1" | tee -a "$SVL_LOG_FILE"
    shift
    while [ "$1" ]
    do
	"$ECHO" "     $1" | tee -a "$SVL_LOG_FILE"
	shift
    done
}

#-----------------------------------------------------------------------------

SVL_CHECK_EXIT () {
    ####
    # To propagate exit codes from sub-shells
    # $1 contains the exit status to propagate
    ####
    if test "$1" != 0
    then
	SVL_EXIT_CODE="$1"
    	if test "$SVL_IGNORE" = ""
    	then
	    SVL_EXIT
	fi
    fi
}

#-----------------------------------------------------------------------------

SVL_ERROR () {
    ####
    # Errors issued by svl
    # $* is the error message, one argument per line
    ####
    "$ECHO" | tee -a "$SVL_LOG_FILE"
    "$ECHO" "svl: ERROR $1" | tee -a "$SVL_LOG_FILE"
    shift
    while [ "$1" ]
    do
	"$ECHO" "     $1" | tee -a "$SVL_LOG_FILE"
	shift
    done
    "$ECHO"
    SVL_EXIT_CODE=1
    if test "$SVL_IGNORE" = ""
    then
	"$ECHO" "svl: see $SVL_LOG_FILE for a detailed diagnostic of the verification"
	"$ECHO"
	SVL_EXIT
    fi
}

#-----------------------------------------------------------------------------

SVL_EXIT () {
    ####
    # The only way to exit from an svl shell script
    ####
    exit "$SVL_EXIT_CODE"
}

#-----------------------------------------------------------------------------

SVL_UPPERCASE () {
    "$ECHO" "$1" | tr '[:lower:]' '[:upper:]'
}

#-----------------------------------------------------------------------------

SVL_DISTINCT_FILENAMES () {
    if test "$SVL_CADP_ARCH" = "win32"
    then
	# Windows is case-insensitive
	test `SVL_UPPERCASE "$1"` != `SVL_UPPERCASE "$2"`
    else
	# Other OSs are case-sensitive
	test "$1" != "$2"
    fi
}

#-----------------------------------------------------------------------------

SVL_APPLY_REDUCTION () {
    ####
    # $1 is the tool (aldebaran, bcg_min, or default) chosen 
    # to perform reduction; there may be two tools in case of total reduction;
    # in this case the tools are separated by a space
    # $2 is the relation (strong, observational, branching, divbranching,
    # tau*.a, safety, tau-divergence, tau-compression, tau-confluence, trace,
    # or weak trace)
    # $3 is a possible option for bcg_min (-prob, -rate)
    # $4 is the method (std, bdd, fly)
    # $5 is the behaviour to reduce (any type)
    # $6 is the possible root process (if $5 is a FSP/LOTOS/LNT file)
    # $7 is the output (any type)
    # $8 is either "partial" (partial reduction) or "" (total reduction)
    # $9 is an intermediate prefix used in case the generation of $5 is needed
    # The combination of tool/method/relation is assumed to be correct
    # and if $5 has format exp, tool/method/relation can handle it
    # This function is called by SVL_REDUCTION
    ####
    # we first put $5 in a format that can be processed by the tool $1
    SVL_LOCAL_INPUT_PREFIX="`SVL_PREFIX "$5"`"
    SVL_LOCAL_INPUT_TYPE="`SVL_TYPE "$5"`"
    SVL_LOCAL_MESSAGE_INPUT="$5"
    SVL_LOCAL_MESSAGE_ROOT="$6"
    SVL_LOCAL_PRIMARY_TOOL=`SVL_GET_FIRST_ARG $1`
    SVL_LOCAL_SECONDARY_TOOL=`SVL_GET_SECOND_ARG $1`
    case "$SVL_LOCAL_PRIMARY_TOOL" in
    aldebaran)
	if test "$SVL_LOCAL_INPUT_TYPE" != "aut" -a "$SVL_LOCAL_INPUT_TYPE" != "bcg" -a "$SVL_LOCAL_INPUT_TYPE" != "exp"
	then
	    # $5 type is not recognized by aldebaran, it has to be converted
	    if test "$SVL_LOCAL_INPUT_TYPE" = "lot" -o "$SVL_LOCAL_INPUT_TYPE" = "lnt" -o "$SVL_LOCAL_INPUT_TYPE" = "lts"
	    then
		# FSP, LOTOS, and LNT files have to be generated into
		# a bcg file
		SVL_LOCAL_TMP_INPUT="$9.bcg"
		SVL_LOCAL_MESSAGE_INPUT="$SVL_LOCAL_TMP_INPUT"
		SVL_LOCAL_MESSAGE_ROOT=""
		SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_INPUT"
		SVL_COMPILE "$5" "bcg" "$6" "$9"
	    else
		SVL_LOCAL_TMP_INPUT="${SVL_TMP_PREFIX}_input.bcg"
		SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_INPUT"
		SVL_CONVERT "$5" "$SVL_LOCAL_TMP_INPUT"
	    fi
	else 
	    # Otherwise, no conversion has to be done
	    SVL_LOCAL_TMP_INPUT="$5"
	fi
	;;
    bcg_min)
	if test "$SVL_LOCAL_INPUT_TYPE" != "bcg"
	then
	    if test "$SVL_LOCAL_INPUT_TYPE" = "lot" -o "$SVL_LOCAL_INPUT_TYPE" = "lnt" -o "$SVL_LOCAL_INPUT_TYPE" = "lts"
	    then
		# FSP, LOTOS, and LNT files have to be generated into
		# a bcg file
		SVL_LOCAL_TMP_INPUT="$9.bcg"
		SVL_LOCAL_MESSAGE_INPUT="$SVL_LOCAL_TMP_INPUT"
		SVL_LOCAL_MESSAGE_ROOT=""
		SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_INPUT"
		SVL_COMPILE "$5" "bcg" "$6" "$9"
	    elif test "$SVL_LOCAL_INPUT_TYPE" = "exp"
	    then
		# we check whether the reduction is "stochastic branching" or
		# "stochastic divbranching", in which case the -rate -branching
		# options of Exp.Open might be useful
		if test \( "$2" = "branching" -o "$2" = "divbranching" \) -a "$3" = "-rate"
		then
			SVL_LOCAL_PARTIAL_ORDER_REDUCTION="ratebranching"
		elif test "$2" = "divbranching"
		then
			# the branching partial order reduction cannot be used
			# for divbranching bisimulation because it removes
			# divergences
			SVL_LOCAL_PARTIAL_ORDER_REDUCTION="strong"
		else
			SVL_LOCAL_PARTIAL_ORDER_REDUCTION="$2"
		fi
		SVL_LOCAL_TMP_INPUT="$9.bcg"
		SVL_LOCAL_MESSAGE_INPUT="$SVL_LOCAL_TMP_INPUT"
		SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_INPUT"
		SVL_GENERATOR "$5" "$SVL_LOCAL_TMP_INPUT" "$SVL_LOCAL_PARTIAL_ORDER_REDUCTION"
	    else
		SVL_LOCAL_TMP_INPUT="${SVL_TMP_PREFIX}_input.bcg"
		SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_INPUT"
		SVL_CONVERT "$5" "$SVL_LOCAL_TMP_INPUT"
	    fi
	else
	    SVL_LOCAL_TMP_INPUT="$5"
	fi
	;;
    reductor)
	if test "`SVL_IS_OPEN "$5"`" != "yes" 
	then
	    SVL_LOCAL_TMP_INPUT="${SVL_TMP_PREFIX}_input.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_INPUT"
	    SVL_CONVERT "$5" "$SVL_LOCAL_TMP_INPUT"
	else
	    SVL_LOCAL_TMP_INPUT="$5"
	fi
	;;
    fc2tools)
	SVL_ERROR "fc2tools are no longer supported"
	;;
    esac
    if test "$8" != ""
    then
	SVL_LOCAL_REDUCTION_TYPE="$8 $2"
    else
	SVL_LOCAL_REDUCTION_TYPE="$2"
    fi
    if test "$3" = "-prob"
    then
        SVL_LOCAL_REDUCTION_TYPE="$SVL_LOCAL_REDUCTION_TYPE probabilistic"
    elif test "$3" = "-rate"
    then
        SVL_LOCAL_REDUCTION_TYPE="$SVL_LOCAL_REDUCTION_TYPE stochastic"
    fi
    SVL_PRINT_NEWLINE
    if test "$SVL_LOCAL_MESSAGE_ROOT" != ""
    then
	SVL_PRINT_MESSAGE "\"$7\" = $SVL_LOCAL_REDUCTION_TYPE reduction of \"$SVL_LOCAL_MESSAGE_INPUT\":\"$SVL_LOCAL_MESSAGE_ROOT\""
    else
	SVL_PRINT_MESSAGE "\"$7\" = $SVL_LOCAL_REDUCTION_TYPE reduction of \"$SVL_LOCAL_MESSAGE_INPUT\""
    fi
    SVL_LOCAL_OUTPUT_PREFIX="`SVL_PREFIX "$7"`"
    SVL_LOCAL_OUTPUT_TYPE="`SVL_TYPE "$7"`"
    SVL_FAILED_FLAG=""
    case "$SVL_LOCAL_PRIMARY_TOOL" in
    aldebaran)
	if test "$SVL_LOCAL_OUTPUT_TYPE" = "aut" -o  "$SVL_LOCAL_OUTPUT_TYPE" = "bcg"
	then
	    SVL_LOCAL_TMP_OUTPUT="$7"
	else
	    SVL_LOCAL_TMP_OUTPUT="${SVL_TMP_PREFIX}_output.bcg"
	fi
	# Getting options for aldebaran
	SVL_LOCAL_METH="-$4"
	SVL_LOCAL_REL=`SVL_ALDEBARAN_OPTION_RELATION "$2"`
	# Reducing
	SVL_EXECUTE "`SVL_TIME`$ALDEBARAN_EXECUTABLE $SVL_LOCAL_METH ${SVL_LOCAL_REL}min $ALDEBARAN_OPTIONS -output \"$SVL_LOCAL_TMP_OUTPUT\" \"$SVL_LOCAL_TMP_INPUT\"" "" "" "reduction"
	;;
    bcg_min|reductor)
	SVL_LOCAL_REL=`SVL_BCG_MIN_BCG_CMP_REDUCTOR_OPTION_RELATION "$2"`
	# bcg_min and reductor produce only .bcg
	if test "$SVL_LOCAL_OUTPUT_TYPE" != "bcg"
	then
	    SVL_LOCAL_TMP_OUTPUT="${SVL_TMP_PREFIX}_output.bcg"
	else
	    SVL_LOCAL_TMP_OUTPUT="$7"
	fi
	if test "$SVL_LOCAL_PRIMARY_TOOL" = "bcg_min"
	then
	    SVL_EXECUTE "`SVL_TIME`$BCG_MIN_EXECUTABLE $BCG_OPTIONS $BCG_MIN_OPTIONS $SVL_LOCAL_REL $3 \"$SVL_LOCAL_TMP_INPUT\" \"$SVL_LOCAL_TMP_OUTPUT\"" "" "" "reduction"
	else
	    SVL_LOCAL_BASENAME=`SVL_BASENAME_OPEN_CAESAR_TOOL "$REDUCTOR_EXECUTABLE"`
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME.o"
	    if test "$8" = "" -a "$SVL_LOCAL_SECONDARY_TOOL" = ""
	    then
		# total reduction without secondary tool
		SVL_LOCAL_REDUCTOR_OPTION="-total"
	    else
		SVL_LOCAL_REDUCTOR_OPTION="-partial"
	    fi
	    if test "$SVL_LOCAL_MESSAGE_ROOT" != ""
	    then
		SVL_LOCAL_ROOT_OPTION="-root '$SVL_LOCAL_MESSAGE_ROOT'"
	    else
		SVL_LOCAL_ROOT_OPTION=
	    fi
	    SVL_SET_OPEN_TOOL "$SVL_LOCAL_TMP_INPUT"
	    SVL_SET_OPEN_CC_OPTIONS "$SVL_LOCAL_TMP_INPUT"
	    SVL_EXECUTE "`SVL_TIME`$SVL_OPEN_TOOL $SVL_LOCAL_ROOT_OPTION \"$SVL_LOCAL_TMP_INPUT\" $SVL_OPEN_CC_OPTIONS $REDUCTOR_EXECUTABLE $REDUCTOR_OPTIONS $SVL_LOCAL_REDUCTOR_OPTION $SVL_LOCAL_REL \"$SVL_LOCAL_TMP_OUTPUT\""
	    SVL_CHECK_COMPILER_ERROR "$SVL_LOCAL_TMP_INPUT"
	    SVL_REMOVE "reductor"
	    if test "$8" = "" -a "$SVL_LOCAL_SECONDARY_TOOL" != ""
	    then
		# total reduction with secondary tool
		case "$SVL_LOCAL_SECONDARY_TOOL" in
		bcg_min)
		    SVL_EXECUTE "`SVL_TIME`$BCG_MIN_EXECUTABLE $BCG_OPTIONS $BCG_MIN_OPTIONS -strong \"$SVL_LOCAL_TMP_OUTPUT\"" "" "" "reduction"
		    ;;
		reductor)
		    SVL_EXECUTE "`SVL_TIME`$BCG_OPEN_EXECUTABLE $BCG_OPTIONS $BCG_OPEN_OPTION \"$SVL_LOCAL_TMP_OUTPUT\" $BCG_OPEN_CC_OPTIONS $REDUCTOR_EXECUTABLE $REDUCTOR_OPTIONS -total -strong \"$SVL_LOCAL_TMP_OUTPUT\"" "" "" "reduction"
		    ;;
		aldebaran)
		    SVL_EXECUTE "`SVL_TIME`$ALDEBARAN_EXECUTABLE $ALDEBARAN_OPTIONS -bmin -output \"$SVL_LOCAL_TMP_OUTPUT\" \"$SVL_LOCAL_TMP_OUTPUT\"" "" "" "reduction"
		    ;;
		fc2tools)
		    SVL_ERROR "fc2tools are no longer supported"
		    ;;
		esac
	    fi
	fi
	;;
    fc2tools)
	SVL_ERROR "fc2tools are no longer supported"
	;;
    esac
    if test "$SVL_FAILED_FLAG" = ""
    then
	if SVL_DISTINCT_FILENAMES "$SVL_LOCAL_TMP_INPUT" "$5"
	then
		# We had to create an intermediate file for input
		# which we now remove
		SVL_REMOVE "$SVL_LOCAL_TMP_INPUT"
	fi
        # SVL_LOCAL_TMP_OUTPUT is converted to the required type and removed
        SVL_CONVERT_AND_REMOVE "$SVL_LOCAL_TMP_OUTPUT" "$7"
        SVL_INFO "$7"
    fi
}

#-----------------------------------------------------------------------------

SVL_INVERT_COMPARISON_OPERATOR () {
    # invert the comparison operator $1 within EQUAL, LESS_OR_EQUAL, and 
    # GREATER_OR_EQUAL
    case $1 in
    EQUAL)
	"$ECHO" EQUAL;;
    LESS_OR_EQUAL)
	"$ECHO" GREATER_OR_EQUAL;;
    GREATER_OR_EQUAL)
	"$ECHO" LESS_OR_EQUAL;;
    esac
}

#-----------------------------------------------------------------------------

SVL_APPLY_COMPARISON () {
    ####
    # $1 is the tool bisimulator, bcg_cmp, or aldebaran
    # $2 is the equivalence relation : strong, observational, branching, 
    # tau*.a, safety, trace, or weak trace
    # $3 is a possible option for bcg_cmp (-prob, -rate)
    # $4 is the method : std, fly, bdd, dfs, bfs
    # $5 is the first input file (any type)
    # $6 is the possible root process associated to $5 if lotos/lnt/lts (FSP)
    # $7 is the second input file (any type)
    # $8 is the possible root process associated to $7 if lotos/lnt/lts (FSP)
    # $9 is an optional diagnostic file
    # ${10} is the operation : EQUAL, LESS_OR_EQUAL, GREATER_OR_EQUAL
    ####
    # all parameters are named and shift is used to access the tenth parameter,
    # because ${10} is not portable (it cannot be used under Solaris) 
    SVL_LOCAL_TOOL="$1"
    SVL_LOCAL_EQUIVALENCE="$2"
    SVL_LOCAL_PROB_RATE="$3"
    SVL_LOCAL_METHOD="$4"
    SVL_LOCAL_FIRST_INPUT="$5"
    SVL_LOCAL_FIRST_ROOT="$6"
    SVL_LOCAL_SECOND_INPUT="$7"
    SVL_LOCAL_SECOND_ROOT="$8"
    SVL_LOCAL_DIAG_OUTPUT="$9"
    shift
    SVL_LOCAL_CMP_OPERATOR="$9"

    case "$SVL_LOCAL_PROB_RATE" in
    -prob )
    	SVL_LOCAL_RELATION_TYPE=" probabilistic"
    	;;
    -rate )
     	SVL_LOCAL_RELATION_TYPE=" stochastic"
   	;;
    * )
	SVL_LOCAL_RELATION_TYPE=""
    esac
    case "$SVL_LOCAL_CMP_OPERATOR" in
    EQUAL)
	SVL_LOCAL_OP="==" ;;
    LESS_OR_EQUAL)
	SVL_LOCAL_OP="<=" ;;
    GREATER_OR_EQUAL)
	SVL_LOCAL_OP=">=" ;;
    esac
    SVL_PRINT_NEWLINE
    if test "$SVL_LOCAL_DIAG_OUTPUT" != ""
    then
	SVL_PRINT_MESSAGE "\"$SVL_LOCAL_DIAG_OUTPUT\" = $SVL_LOCAL_EQUIVALENCE$SVL_LOCAL_RELATION_TYPE comparison"
    else
	SVL_PRINT_MESSAGE "$SVL_LOCAL_EQUIVALENCE$SVL_LOCAL_RELATION_TYPE comparison"
    fi
    if test "$SVL_LOCAL_FIRST_ROOT" != ""
    then
	SVL_PRINT_MESSAGE "    \"$SVL_LOCAL_FIRST_INPUT\":\"$SVL_LOCAL_FIRST_ROOT\" $SVL_LOCAL_OP \"$SVL_LOCAL_SECOND_INPUT\""
    elif test "$SVL_LOCAL_SECOND_ROOT" != ""
    then
	SVL_PRINT_MESSAGE "    \"$SVL_LOCAL_FIRST_INPUT\" $SVL_LOCAL_OP \"$SVL_LOCAL_SECOND_INPUT\":\"$SVL_LOCAL_SECOND_ROOT\""
    else
	SVL_PRINT_MESSAGE "    \"$SVL_LOCAL_FIRST_INPUT\" $SVL_LOCAL_OP \"$SVL_LOCAL_SECOND_INPUT\""
    fi
    SVL_FAILED_FLAG=""

    # gestion du fichier diagnostic
    if test "$SVL_LOCAL_DIAG_OUTPUT" != ""
    then
	if test `SVL_TYPE "$SVL_LOCAL_DIAG_OUTPUT"` != bcg
	then
	    SVL_LOCAL_TMP_OUTPUT="${SVL_TMP_PREFIX}_output.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_OUTPUT"
	else
	    SVL_LOCAL_TMP_OUTPUT="$SVL_LOCAL_DIAG_OUTPUT"
	fi
	SVL_LOCAL_DIAG_OPTION=" -diag \"$SVL_LOCAL_TMP_OUTPUT\""
    else
	SVL_LOCAL_TMP_OUTPUT=
	SVL_LOCAL_DIAG_OPTION=
    fi

    # comparaison
    case "$SVL_LOCAL_TOOL" in
    bisimulator)
	# Choix de l'ordre des arguments et conversion des inputs si necessaire
	SVL_LOCAL_INPUT_TYPE_2="`SVL_TYPE "$SVL_LOCAL_SECOND_INPUT"`"
	if test "$SVL_LOCAL_INPUT_TYPE_2" = "exp" -o "$SVL_LOCAL_INPUT_TYPE_2" = "lot" -o "$SVL_LOCAL_INPUT_TYPE_2" = "lnt" -o "$SVL_LOCAL_INPUT_TYPE_2" = "lts"
	then
	     SVL_LOCAL_TMP_INPUT_1="$SVL_LOCAL_SECOND_INPUT"
	     SVL_LOCAL_ROOT_1="$SVL_LOCAL_SECOND_ROOT"
	     SVL_LOCAL_TMP_INPUT_2="$SVL_LOCAL_FIRST_INPUT"
	     SVL_LOCAL_CMP_OPERATOR=`SVL_INVERT_COMPARISON_OPERATOR $SVL_LOCAL_CMP_OPERATOR`
	else
	     SVL_LOCAL_TMP_INPUT_1="$SVL_LOCAL_FIRST_INPUT"
	     SVL_LOCAL_ROOT_1="$SVL_LOCAL_FIRST_ROOT"
	     SVL_LOCAL_TMP_INPUT_2="$SVL_LOCAL_SECOND_INPUT"
	fi
	SVL_LOCAL_INPUT_TYPE_1=`SVL_TYPE "$SVL_LOCAL_TMP_INPUT_1"`
	if test "$SVL_LOCAL_INPUT_TYPE_1" != "exp" -a "$SVL_LOCAL_INPUT_TYPE_1" != "lot" -a "$SVL_LOCAL_INPUT_TYPE_1" != "lnt" -a "$SVL_LOCAL_INPUT_TYPE_1" != "lts" -a "$SVL_LOCAL_INPUT_TYPE_1" != "bcg" -a "$SVL_LOCAL_INPUT_TYPE_1" != "seq"
	then
	    SVL_LOCAL_TMP_ARG_1="${SVL_TMP_PREFIX}_input_1.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_ARG_1"
	    SVL_CONVERT "$SVL_LOCAL_TMP_INPUT_1" "$SVL_LOCAL_TMP_ARG_1"
	else
	    SVL_LOCAL_TMP_ARG_1="$SVL_LOCAL_TMP_INPUT_1"
	fi
	SVL_LOCAL_INPUT_TYPE_2=`SVL_TYPE "$SVL_LOCAL_TMP_INPUT_2"`
	if test "$SVL_LOCAL_INPUT_TYPE_2" != "bcg"
	then
	    SVL_LOCAL_TMP_ARG_2="${SVL_TMP_PREFIX}_input_2.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_ARG_2"
	    SVL_CONVERT "$SVL_LOCAL_TMP_INPUT_2" "$SVL_LOCAL_TMP_ARG_2"
	else
	    SVL_LOCAL_TMP_ARG_2="$SVL_LOCAL_TMP_INPUT_2"
	fi
	SVL_SET_OPEN_TOOL "$SVL_LOCAL_TMP_ARG_1"
	SVL_SET_OPEN_CC_OPTIONS "$SVL_LOCAL_TMP_ARG_1"
	case $SVL_LOCAL_CMP_OPERATOR in
	EQUAL)
	    SVL_LOCAL_COMPARISON_OPTION="-equal";;
	LESS_OR_EQUAL)
	    SVL_LOCAL_COMPARISON_OPTION="-smaller";;
	GREATER_OR_EQUAL)
	    SVL_LOCAL_COMPARISON_OPTION="-greater";;
	esac
	SVL_LOCAL_REL=`SVL_BISIMULATOR_OPTION_RELATION "$SVL_LOCAL_EQUIVALENCE"`
	if test "$SVL_LOCAL_ROOT_1" != ""
	then
	    SVL_LOCAL_ROOT_1="-root '$SVL_LOCAL_ROOT_1'"
	fi
	SVL_LOCAL_BASENAME=`SVL_BASENAME_OPEN_CAESAR_TOOL "$BISIMULATOR_EXECUTABLE"`
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME.o"
	# on efface le fichier de diagnostic $SVL_LOCAL_TMP_OUTPUT s'il existe
	# deja, car sinon on risque un clash, notamment lorsque SVL est appele
	# avec l'option -debug, car bisimulator ne genere pas systematiquement
	# ce fichier
	rm -f "$SVL_LOCAL_TMP_OUTPUT"
	SVL_EXECUTE "`SVL_TIME`$SVL_OPEN_TOOL $SVL_LOCAL_ROOT_1 \"$SVL_LOCAL_TMP_ARG_1\" $SVL_OPEN_CC_OPTIONS $BISIMULATOR_EXECUTABLE -$SVL_LOCAL_METHOD $BISIMULATOR_OPTIONS $SVL_LOCAL_COMPARISON_OPTION $SVL_LOCAL_REL$SVL_LOCAL_DIAG_OPTION \"$SVL_LOCAL_TMP_ARG_2\"" "SVL_FILTER_BOOLEAN_GENERIC"
	SVL_CHECK_COMPILER_ERROR "$SVL_LOCAL_TMP_ARG_1"
	;;
    bcg_cmp )
	SVL_LOCAL_TMP_INPUT_1="$SVL_LOCAL_FIRST_INPUT"
	SVL_LOCAL_TMP_INPUT_2="$SVL_LOCAL_SECOND_INPUT"
	# Conversion des inputs si necessaire
	SVL_LOCAL_INPUT_TYPE_1=`SVL_TYPE "$SVL_LOCAL_FIRST_INPUT"`
	if test "$SVL_LOCAL_INPUT_TYPE_1" = "bcg"
	then
	    SVL_LOCAL_TMP_ARG_1="$SVL_LOCAL_FIRST_INPUT"
	else
	    SVL_LOCAL_TMP_ARG_1="${SVL_TMP_PREFIX}_input_1.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_ARG_1"
	    SVL_CONVERT "$SVL_LOCAL_FIRST_INPUT" "$SVL_LOCAL_TMP_ARG_1"
	fi
	SVL_LOCAL_INPUT_TYPE_2=`SVL_TYPE "$SVL_LOCAL_SECOND_INPUT"`
	if test "$SVL_LOCAL_INPUT_TYPE_2" = "bcg"
	then
	    SVL_LOCAL_TMP_ARG_2="$SVL_LOCAL_SECOND_INPUT"
	else
	    SVL_LOCAL_TMP_ARG_2="${SVL_TMP_PREFIX}_input_2.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_ARG_2"
	    SVL_CONVERT "$SVL_LOCAL_SECOND_INPUT" "$SVL_LOCAL_TMP_ARG_2"
	fi
	SVL_LOCAL_REL=`SVL_BCG_MIN_BCG_CMP_REDUCTOR_OPTION_RELATION "$SVL_LOCAL_EQUIVALENCE"`
	SVL_EXECUTE "`SVL_TIME`$BCG_CMP_EXECUTABLE $SVL_LOCAL_REL $SVL_LOCAL_PROB_RATE $BCG_CMP_OPTIONS$SVL_LOCAL_DIAG_OPTION \"$SVL_LOCAL_TMP_ARG_1\" \"$SVL_LOCAL_TMP_ARG_2\"" "SVL_FILTER_BOOLEAN_GENERIC"
	;;
    aldebaran)
	case "$SVL_LOCAL_CMP_OPERATOR" in
	EQUAL)
	    SVL_LOCAL_COMM="equ"
	    SVL_LOCAL_TMP_INPUT_1="$SVL_LOCAL_FIRST_INPUT"
	    SVL_LOCAL_TMP_INPUT_2="$SVL_LOCAL_SECOND_INPUT"
	    ;;
        LESS_OR_EQUAL)
	    SVL_LOCAL_COMM="ord"
	    SVL_LOCAL_TMP_INPUT_1="$SVL_LOCAL_FIRST_INPUT"
	    SVL_LOCAL_TMP_INPUT_2="$SVL_LOCAL_SECOND_INPUT"
	    ;;
	GREATER_OR_EQUAL)
	    SVL_LOCAL_COMM="ord"
	    SVL_LOCAL_TMP_INPUT_1="$SVL_LOCAL_SECOND_INPUT"
	    SVL_LOCAL_TMP_INPUT_2="$SVL_LOCAL_FIRST_INPUT"
	    ;;
	esac
	# Conversion des inputs si necessaire
	SVL_LOCAL_INPUT_TYPE_1=`SVL_TYPE "$SVL_LOCAL_TMP_INPUT_1"`
	if test "$SVL_LOCAL_INPUT_TYPE_1" = "exp" -o "$SVL_LOCAL_INPUT_TYPE_1" = "aut" -o "$SVL_LOCAL_INPUT_TYPE_1" = "bcg"
	then
	    SVL_LOCAL_TMP_ARG_1="$SVL_LOCAL_TMP_INPUT_1"
	else
	    SVL_LOCAL_TMP_ARG_1="${SVL_TMP_PREFIX}_input_1.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_ARG_1"
	    SVL_CONVERT "$SVL_LOCAL_FIRST_INPUT" "$SVL_LOCAL_TMP_ARG_1"
	fi
	SVL_LOCAL_INPUT_TYPE_2=`SVL_TYPE "$SVL_LOCAL_TMP_INPUT_2"`
	if test "$SVL_LOCAL_INPUT_TYPE_2" = "exp" -o "$SVL_LOCAL_INPUT_TYPE_2" = "aut" -o "$SVL_LOCAL_INPUT_TYPE_2" = "bcg"
	then
	    SVL_LOCAL_TMP_ARG_2="$SVL_LOCAL_SECOND_INPUT"
	else
	    SVL_LOCAL_TMP_ARG_2="${SVL_TMP_PREFIX}_input_2.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_ARG_2"
	    SVL_CONVERT "$SVL_LOCAL_SECOND_INPUT" "$SVL_LOCAL_TMP_ARG_2"
	fi
	SVL_LOCAL_REL=`SVL_ALDEBARAN_OPTION_RELATION "$SVL_LOCAL_EQUIVALENCE"`
	# on pipe la sortie avec tr pour supprimer les eventuels ^M sous
	# windows et on supprime les lignes vides
	SVL_EXECUTE "`SVL_TIME`$ALDEBARAN_EXECUTABLE -$SVL_LOCAL_METHOD ${SVL_LOCAL_REL}${SVL_LOCAL_COMM} ${ALDEBARAN_OPTIONS} \"$SVL_LOCAL_TMP_ARG_1\" \"$SVL_LOCAL_TMP_ARG_2\"" "SVL_FILTER_ALDEBARAN"
	# if a diagnostic was generated by aldebaran, then move this 
	# diagnostic into the expected output, if any
	if test -f "aldebaran.bcg"
	then
	    if test "$SVL_LOCAL_TMP_OUTPUT" != ""
	    then
		SVL_MOVE "aldebaran.bcg" "$SVL_LOCAL_TMP_OUTPUT"
	    else
		SVL_REMOVE "aldebaran.bcg"
	    fi
	fi;;
    fc2tools)
	SVL_ERROR "fc2tools are no longer supported"
	;;
    esac
    if SVL_DISTINCT_FILENAMES "$SVL_LOCAL_TMP_ARG_1" "$SVL_LOCAL_TMP_INPUT_1" 
    then
	SVL_REMOVE "$SVL_LOCAL_TMP_ARG_1"
    fi
    if SVL_DISTINCT_FILENAMES "$SVL_LOCAL_TMP_ARG_2" "$SVL_LOCAL_TMP_INPUT_2" 
    then
	SVL_REMOVE "$SVL_LOCAL_TMP_ARG_2"
    fi
    if test "$SVL_LOCAL_DIAG_OUTPUT" != "" -a \
	    -f "$SVL_LOCAL_TMP_OUTPUT" && \
       SVL_DISTINCT_FILENAMES "$SVL_LOCAL_TMP_OUTPUT" "$SVL_LOCAL_DIAG_OUTPUT"
    then
	SVL_CONVERT "$SVL_LOCAL_TMP_OUTPUT" "$SVL_LOCAL_DIAG_OUTPUT"
	SVL_REMOVE "$SVL_LOCAL_TMP_OUTPUT"
    fi
}

#-----------------------------------------------------------------------------

SVL_GET_FILE_SIZE () {
    ####
    # $1 is the LTS file name
    # Echo size of $1 in kB
    ####
    SVL_LOCAL_FILE_SIZE=`wc -c "$1" | sed -e 's/[ ]*//' | cut -d ' ' -f 1`
    SVL_LOCAL_FILE_SIZE_UNITS=`SVL_EXPR "$SVL_LOCAL_FILE_SIZE" / 1024`
    SVL_LOCAL_FILE_SIZE_DEC=`SVL_EXPR "$SVL_LOCAL_FILE_SIZE" % 1024 \* 10 / 1024`
    "$ECHO" ${SVL_LOCAL_FILE_SIZE_UNITS}.${SVL_LOCAL_FILE_SIZE_DEC}
}

#-----------------------------------------------------------------------------

SVL_GET_FIRST_ARG () {
    "$ECHO" $1
}

#-----------------------------------------------------------------------------

SVL_GET_SECOND_ARG () {
    "$ECHO" $2
}

#-----------------------------------------------------------------------------

SVL_INFO () {
    ####
    # $1 is an automaton
    # Print info about the size of $1 if option silent not set
    ####
    SVL_LOCAL_INFO=
    case `SVL_TYPE "$1"` in
    bcg)
	SVL_LOCAL_INFO=`bcg_info $BCG_OPTIONS -size "$1"`;;
    aut)
	SVL_LOCAL_INFO=`$ALDEBARAN_EXECUTABLE -info "$1" | tr '\011' ' ' | SVL_EGREP 'transitions|states'`;;
    fc2)
	SVL_LOCAL_TEMP="${SVL_TMP_PREFIX}_fc2.bcg"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TEMP"
	SVL_CONVERT "$1" "$SVL_LOCAL_TEMP"
	SVL_LOCAL_INFO=`bcg_info $BCG_OPTIONS -size "$SVL_LOCAL_TEMP"`
	SVL_REMOVE "$SVL_LOCAL_TEMP"
	;;
    esac
    SVL_DISPLAY_INFO "$SVL_LOCAL_INFO" "$1"
}

#-----------------------------------------------------------------------------

SVL_DISPLAY_INFO () {
    ####
    # $1 is the state and transition info about an LTS
    # $2 is LTS file name
    # Display info about LTS on standard output and log file
    ####
    SVL_LOCAL_NB_STATES=
    SVL_LOCAL_NB_TRANS=
    for SVL_LOCAL_WORD_INFO in $1
    do
	case "$SVL_LOCAL_WORD_INFO" in
	state*)
	    SVL_LOCAL_NB_STATES="$SVL_LOCAL_LAST_READ";;
	transition*)
	    SVL_LOCAL_NB_TRANS="$SVL_LOCAL_LAST_READ";;
	esac
	if test "$SVL_LOCAL_NB_STATES" != "" -a "$SVL_LOCAL_NB_TRANS" != ""
	then
	    break
	else
	    SVL_LOCAL_LAST_READ="$SVL_LOCAL_WORD_INFO"
    	fi
    done
    SVL_PRINT_LOG_MESSAGE ""
    SVL_PRINT_LOG_MESSAGE "info about $2:"
    if test "$SVL_LOCAL_NB_STATES" != ""
    then
    	SVL_PRINT_MESSAGE "    (* $SVL_LOCAL_NB_STATES states, $SVL_LOCAL_NB_TRANS transitions, `SVL_GET_FILE_SIZE "$2"` Kbytes *)"
    else
	SVL_PRINT_MESSAGE "    (* `SVL_GET_FILE_SIZE "$2"` Kbytes *)"
    fi
}

#-----------------------------------------------------------------------------

SVL_IS_SMALLER () {
    ####
    # $1 is an LTS in an explicit LTS format (bcg, aut, or fc2)
    # $2 is an LTS in any format
    # echo something if $1 has less states than $2 or if $2 is not in an
    # explicit format
    ####
    case `SVL_TYPE "$2"` in
    bcg | aut | fc2 )
	SVL_LOCAL_NUM_STATES_FIRST=`SVL_INFO "$1" | sed -e 's/\((\* \)\(.*\) states.*/\2/'`
	SVL_LOCAL_NUM_STATES_SECOND=`SVL_INFO "$2" | sed -e 's/\((\* \)\(.*\) states.*/\2/'`
	if test `SVL_EXPR "$SVL_LOCAL_NUM_STATES_FIRST" \< "$SVL_LOCAL_NUM_STATES_SECOND"` = 1
	then
	    "$ECHO" "true"
	fi
	;;
    * )
	"$ECHO" "true"
	;;
    esac
}

#-----------------------------------------------------------------------------

SVL_REMOVE () {
    ####
    # args are files to remove
    # Post: $* are removed
    ####
    if test "$SVL_DEBUG" = ""
    then
	for SVL_LOCAL_FILE in "$@"
	do
	    case "$SVL_LOCAL_FILE" in
	    *.bcg)
		# On efface les librairies dynamiques des .bcg
		rm -f "`SVL_PREFIX "$SVL_LOCAL_FILE"`@1.o";;
	    esac
	    rm -f "$SVL_LOCAL_FILE"
	done
    fi
}

#-----------------------------------------------------------------------------

SVL_CONVERT_AND_REMOVE () {
    ####
    # $1 is the temporary file to convert and then remove
    # $2 is the output file
    # if $2 = $1, nothing is done
    # Similar to SVL_CONVERT, except the source is removed
    ####
    if SVL_DISTINCT_FILENAMES "$1" "$2"
    then
	SVL_RECORD_FOR_SWEEP "$1"
	SVL_CONVERT "$1" "$2"
	SVL_REMOVE "$1"
    fi
}

#-----------------------------------------------------------------------------

SVL_MOVE () {
    ####
    # $1 is the source (the file may be unexisting)
    # $2 is the destination
    # Pre: $1 and $2 have the same type
    # Post: $1 is moved to $2
    ####
    if test ! -f "$1"
    then
	SVL_ERROR "attempt to move non existing $1"
    else
        if SVL_DISTINCT_FILENAMES "$1" "$2"
        then
    	    SVL_EXECUTE "mv \"$1\" \"$2\""
	    if test "$3" != ""
	    then
		SVL_PRINT_NEWLINE
	    	SVL_PRINT_MESSAGE "\"$2\" = \"$1\""
	    fi
        fi
    fi
}

#-----------------------------------------------------------------------------

SVL_ALIAS () {
    ####
    # $1 is the source (may not exist)
    # $2 is the destination
    # link $1 to $2 if $1 exists. Copy under win32.
    ####
    if test -f "$1"
    then
	if test -f "$2" -a ! -h "$2"
	then
	    SVL_ERROR "cannot create \"$2\" needed to generate \""`SVL_PREFIX "$2"`".bcg\": file exists"
	fi
	SVL_RECORD_FOR_SWEEP "$2"
	SVL_EXECUTE "rm -f \"$2\""
    	if test "$SVL_CADP_ARCH" = "win32"
    	then
	    # The CADP tools cannot read Cygwin symbolic links; we use "cp -p"
	    # to preserve file dates and avoid useless re-generations of files
	    # that depend on copied files
	    SVL_EXECUTE "cp -p \"$1\" \"$2\""
     	else
	    SVL_EXECUTE "ln -s \"$1\" \"$2\""
    	fi
    fi
}

#-----------------------------------------------------------------------------

SVL_SET_SPACES () {
    ####
    # $1 is the number of blank spaces to generate
    ####
    if test "$1" = "0"
    then 
	SVL_SPACES=
    elif test $1 -ge 8
    then
	SVL_SET_SPACES `SVL_EXPR "$1" - 8`
	SVL_SPACES="        $SVL_SPACES"
    else
	SVL_SET_SPACES `SVL_EXPR "$1" - 1`
	SVL_SPACES=" $SVL_SPACES"
    fi
}

#-----------------------------------------------------------------------------

SVL_SET_HIDE_RENAME_SYNC () {
    ####
    # $1 is the name of the file
    # $2 is either "userfile", "items", or the name of the source file
    # in case $1 was obtained by negation of this user-given file
    # (abstraction), according to the origin of $1
    # sets variable SVL_HIDE_RENAME_SYNC to a list of labels as
    # in the syntax of SVL
    # adds quotes around labels that are not already enclosed in quotes
    ####
    if test "$2" = "userfile"
    then
	SVL_HIDE_RENAME_SYNC="using \"$1\""
    elif test "$2" = "items"
    then
	case `SVL_TYPE "$1"` in
	hid)
	    SVL_HIDE_RENAME_SYNC=`cat "$1" | tr -d '\015' | sed -e 's/^/, /;s/,[ ]*$//;1s/, hide[ ]*//;s/^\(, \)\([^\"]\)/\1\"\2/;s/\([^ \"]\)[ ]*$/\1\"/;2s/^, //;1s/all[ ]*but\"/all but /' | tr -d '\012'`;;
	ren)
	    SVL_HIDE_RENAME_SYNC=`cat "$1" | tr -d '\015' | sed -e 's/^/, /;s/,[ ]*$//;1s/, rename[ ]*//;s/^\(, \)\([^\"]\)/\1\"\2/;s/\([^ \"]\)[ ]*->/\1\" ->/;s/->[ ]*\([^ \"]\)/-> \"\1/;s/\([^\"]\)[ ]*$/\1\"/;2s/^, //' | tr -d '\012'`;;
	sync)
	    SVL_HIDE_RENAME_SYNC=`cat "$1" | tr -d '\015' | sed -e 's/^/, /;s/,[ ]*$//;1s/, Sync[ ]*//;s/^\(, \)\([^\"]\)/\1\"\2/;s/\([^ \"]\)[ ]*$/\1\"/;2s/^, //;1s/all[ ]*but\"/all but /' | tr -d '\012'`;;
	esac
    else
	SVL_HIDE_RENAME_SYNC="(* all labels but these in \"$2\" *)"
    fi
}

#-----------------------------------------------------------------------------

SVL_CHECK_DEFAULT_PROGRAM () {
    ####
    # check that the variables $DEFAULT_LOTOS_FILE and $DEFAULT_PROCESS_FILE
    # are used consistently, if needed
    ####
    if test "$DEFAULT_LOTOS_FILE" != ""
    then
	SVL_LOCAL_DEFAULT_LOTOS_FILE_TYPE=`SVL_TYPE "$DEFAULT_LOTOS_FILE"`
	case "$SVL_LOCAL_DEFAULT_LOTOS_FILE_TYPE" in
	lot)
	    if test "$DEFAULT_PROCESS_FILE" != ""
	    then
		SVL_WARNING "both \$DEFAULT_LOTOS_FILE and \$DEFAULT_PROCESS_FILE are defined" "define variable DEFAULT_PROCESS_FILE only"
	    fi
	    ;;
	lts)
	    SVL_WARNING "\$DEFAULT_LOTOS_FILE ($DEFAULT_LOTOS_FILE) contains an FSP program" "define variable DEFAULT_PROCESS_FILE instead of DEFAULT_LOTOS_FILE"
	    ;;
	lnt)
	    SVL_WARNING "\$DEFAULT_LOTOS_FILE ($DEFAULT_LOTOS_FILE) contains an LNT program" "define variable DEFAULT_PROCESS_FILE instead of DEFAULT_LOTOS_FILE"
	    ;;
	*)
	    SVL_ERROR "\$DEFAULT_LOTOS_FILE ($DEFAULT_LOTOS_FILE) has invalid extension ($SVL_LOCAL_DEFAULT_LOTOS_FILE_TYPE)"
	    ;;
	esac
    elif test "$DEFAULT_PROCESS_FILE" != ""
    then
	SVL_LOCAL_DEFAULT_PROCESS_FILE_TYPE=`SVL_TYPE "$DEFAULT_PROCESS_FILE"`
	case "$SVL_LOCAL_DEFAULT_PROCESS_FILE_TYPE" in
	lot|lts|lnt)
	    ;;
	*)
	    SVL_ERROR "\$DEFAULT_PROCESS_FILE ($DEFAULT_PROCESS_FILE) has invalid extension ($SVL_LOCAL_DEFAULT_PROCESS_FILE_TYPE)"
	    ;;
	esac
    fi
}

#-----------------------------------------------------------------------------

SVL_WARNING_OBSOLETE_VARIABLE () {
    ####
    # $1 is the name of a obsolete shell variable
    # $2 is the name of new shell variables
    # display a warning message requiring to change variable names
    ####
    SVL_WARNING "variable $1 is obsolete and ignored" "use $2 instead"
}

#-----------------------------------------------------------------------------

SVL_SET_OPEN_TOOL () {
    ####
    # $1 is the name of a LTS of type bcg, exp, seq, lnt, lotos. or lts (FSP)
    # set the value of SVL_OPEN_TOOL to the tool and tool options
    # required to manipulate $1
    ####
    SVL_LOCAL_INPUT_TYPE=`SVL_TYPE "$1"`
    case "$SVL_LOCAL_INPUT_TYPE" in
    bcg) 
	SVL_OPEN_TOOL="$BCG_OPEN_EXECUTABLE $BCG_OPTIONS $BCG_OPEN_OPTIONS" 
	;;
    lot)
	SVL_CHECK_DEFAULT_PROGRAM
	SVL_LOCAL_PREFIX=`SVL_PREFIX "$1"`
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_PREFIX.h"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_PREFIX.c"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_PREFIX.o"
	if [ "$CAESAR_OPEN_EXECUTABLE" != "" ]
	then
		SVL_WARNING_OBSOLETE_VARIABLE "\$CAESAR_OPEN_EXECUTABLE" "\$LOTOS_OPEN_EXECUTABLE"
	fi
	if [ "$CAESAR_OPEN_OPTIONS" != "" ]
	then
		SVL_WARNING_OBSOLETE_VARIABLE "\$CAESAR_OPEN_OPTIONS" "\$LOTOS_OPEN_OPTIONS"
	fi
	SVL_OPEN_TOOL="$LOTOS_OPEN_EXECUTABLE $LOTOS_OPEN_OPTIONS" 
	;;
    lnt)
	SVL_CHECK_DEFAULT_PROGRAM
	SVL_LOCAL_PREFIX=`SVL_PREFIX "$1"`
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_PREFIX.o"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_PREFIX.err"
	SVL_OPEN_TOOL="$LNT_OPEN_EXECUTABLE $LNT_OPEN_OPTIONS" 
	;;
    lts)
	SVL_CHECK_DEFAULT_PROGRAM
	SVL_OPEN_TOOL="$FSP_OPEN_EXECUTABLE $FSP_OPEN_OPTIONS"
	;;
    exp)
	SVL_OPEN_TOOL="$EXP_OPEN_EXECUTABLE $SVL_USER_INTERFACE $EXP_OPEN_OPTIONS" 
	;;
    seq)
	SVL_OPEN_TOOL="$SEQ_OPEN_EXECUTABLE $SEQ_OPEN_OPTIONS" 
	;;
    esac
}

#-----------------------------------------------------------------------------

SVL_SET_OPEN_CC_OPTIONS () {
    ####
    # $1 is the name of a LTS of type bcg, exp, seq, lnt, lotos, or lts (FSP)
    # set the value of SVL_OPEN_CC_OPTIONS to the cc tool options
    # required to manipulate $1
    ####

    case `SVL_TYPE "$1"` in
    bcg)
	SVL_OPEN_CC_OPTIONS="$BCG_OPEN_CC_OPTIONS"
	;;
    lot)
	if [ "$CAESAR_OPEN_CC_OPTIONS" != "" ]
	then
		SVL_WARNING_OBSOLETE_VARIABLE "\$CAESAR_OPEN_CC_OPTIONS" "\$LOTOS_OPEN_CC_OPTIONS"
	fi
	SVL_OPEN_CC_OPTIONS="$LOTOS_OPEN_CC_OPTIONS"
	;;
    lnt)
	SVL_OPEN_CC_OPTIONS="$LNT_OPEN_CC_OPTIONS"
	;;
    lts)
	SVL_OPEN_CC_OPTIONS="$FSP_OPEN_CC_OPTIONS"
	;;
    exp)
	SVL_OPEN_CC_OPTIONS="$EXP_OPEN_CC_OPTIONS"
	;;
    seq)
	SVL_OPEN_CC_OPTIONS="$SEQ_OPEN_CC_OPTIONS"
	;;
    esac
}

#-----------------------------------------------------------------------------

SVL_IS_OPEN () {
    ####
    # $1 is a file 
    # Returns a string if file is exp, bcg, lnt, lotos, or lts (FSP)
    # (for which an open tool exist)
    ####
    case `SVL_TYPE "$1"` in
    bcg | lot | lnt | lts | exp | seq)
	"$ECHO" "yes" ;;
    esac 
}

#-----------------------------------------------------------------------------

SVL_IS_EXPLICIT () {
    ####
    # $1 is a file 
    # Returns a string if file is bcg, aut, or seq
    # (which are explicit LTS formats)
    ####
    case `SVL_TYPE "$1"` in
    aut | bcg | seq)
	"$ECHO" "yes" ;;
    esac 
}

#-----------------------------------------------------------------------------

##########################################
# MACROS CALLED FROM THE GENERATED SHELL #
##########################################

SVL_CHECK_FILE () {
    ####
    # Issue error message if $1 is not a readable file
    ####
    if test ! -r "$1"
    then
	SVL_ERROR "cannot open file \"$1\""
    fi
}

#-----------------------------------------------------------------------------

SVL_COPY () {
    ####
    # $1 is the source
    # $2 is the destination
    # print message if $3 is set
    ####
    if SVL_DISTINCT_FILENAMES "$1" "$2"
    then
    	if test -f "$1"
    	then
    	    if test -f "$2"
    	    then
	    	rm -f "$2"
    	    fi
	    if test "$3" != ""
	    then
	        SVL_PRINT_NEWLINE
	        SVL_PRINT_MESSAGE "\"$2\" = \"$1\""
	    fi
    	    SVL_EXECUTE "cp \"$1\" \"$2\""
        fi
    fi
}

#-----------------------------------------------------------------------------

SVL_TRANSLATE () {
    ####
    # $1 is the input (.bcg, .seq, .fc2, or .aut)
    # $2 is the required type for output
    # if $3 is set, print message
    # output has the same prefix as $1, and extension $2
    # Post: Both $1 and the generated file represent the same automaton
    # in different formats
    ####
    SVL_LOCAL_PREFIX="`SVL_PREFIX "$1"`"
    if test "$3" != ""
    then
	SVL_PRINT_NEWLINE
	SVL_PRINT_MESSAGE "\"${SVL_LOCAL_PREFIX}.$2\" = \"$1\""
    fi
    SVL_LOCAL_EXTENSION=`SVL_EXTENSION "$1"`
    if test "$SVL_LOCAL_EXTENSION" != "$2"
    then
	SVL_CONVERT "$1" "${SVL_LOCAL_PREFIX}.$2"
    fi
}

#-----------------------------------------------------------------------------

SVL_CONVERT () {
    ####
    # $1 is the input (.bcg, .seq, .fc2, or .aut)
    # $2 is the output (.bcg, .seq, .fc2, or .aut)
    # if $3 is set, print message
    # Post: $1 and $2 represent the same automaton in different formats
    ####
    if test `SVL_TYPE "$1"` = "fc2" -a ! -n "`SVL_GREP '^N1' $1`" -a ! -n "`SVL_GREP '^nets 1' $1`"
    then
	SVL_ERROR "\"$1\" is in parallel fc2 format\n     this format is no longer supported"
    fi
    if test "$3" != ""
    then
	SVL_PRINT_NEWLINE
	SVL_PRINT_MESSAGE "\"$2\" = \"$1\""
    fi
    SVL_EXECUTE "`SVL_TIME`$BCG_IO_EXECUTABLE $BCG_OPTIONS ${BCG_IO_OPTIONS_INPUT} \"$1\" $BCG_OPTIONS ${BCG_IO_OPTIONS_OUTPUT} \"$2\""
}

#-----------------------------------------------------------------------------

SVL_INIT_FILE () {
    ####
    # $1 is the name of the file to initialize
    ####
    SVL_EXECUTE "2>>\"$SVL_LOG_FILE\" rm -f \"$1\" ; touch \"$1\""
}

#-----------------------------------------------------------------------------

SVL_WRITE_FILE () {
    ####
    # $1 is the name of the file to write in
    # $2 is the string to write in $1
    # $3 is the indentation in number of blank spaces
    # $4 is a comment to insert after $2
    # if $5 then $2 is a file name, write it between quotes
    ####
    SVL_LOCAL_SPACE_NUMBER="$3"
    if test "$SVL_LOCAL_SPACE_NUMBER" -gt "$DEFAULT_MAX_INDENT"
    then
	SVL_LOCAL_SPACE_NUMBER="$DEFAULT_MAX_INDENT"
    fi
    SVL_SET_SPACES "$SVL_LOCAL_SPACE_NUMBER"
    if test "$5" != ""
    then
	"$ECHO" "${SVL_SPACES}\""$2"\"""$4" >> "$1"
    else
    	"$ECHO" "${SVL_SPACES}""$2""$4" >> "$1"
    fi
}

#-----------------------------------------------------------------------------

SVL_WRITE_SPLIT_IN_LINES () {
    ####
    # $1 is the name of the file to write in
    # $2 is the string to write in $1
    # $3 is the indentation in number of blank spaces
    # it is a list of items separated by comas; each item must be written
    # on one separate line in $1; there can be parenthesis in items, the 
    # comas embedded in which are not considered as item separators
    ####
    SVL_CDR="$2"
    SVL_CURRENT_LINE=""
    SVL_OPEN_PAR="0"
    SVL_START_LINE=true
    while test "$SVL_CDR" != ""
    do
	SVL_CAR=`"$ECHO" "$SVL_CDR" | cut -b 1`
	SVL_CDR=`"$ECHO" "$SVL_CDR" | cut -b 2-`
	case "$SVL_CAR" in
	" ")
	    if test "$SVL_START_LINE" = "true"
	    then
		continue
	    else
		SVL_CURRENT_LINE="$SVL_CURRENT_LINE$SVL_CAR"
	    fi;;
	",")
	    if test "$SVL_OPEN_PAR" = "0"
	    then
	    	SVL_WRITE_FILE "$1" "$SVL_CURRENT_LINE" "$3"
	    	SVL_CURRENT_LINE=""
		SVL_START_LINE=true
		continue
	    else
	    	SVL_CURRENT_LINE="$SVL_CURRENT_LINE$SVL_CAR"
		SVL_START_LINE=false
	    fi;;
	*)
	    SVL_CURRENT_LINE="$SVL_CURRENT_LINE$SVL_CAR"
	    SVL_START_LINE=false
	    case "$SVL_CAR" in
	    "(")
		SVL_OPEN_PAR=`SVL_EXPR $SVL_OPEN_PAR + 1`;;
	    ")")
		if test "$SVL_OPEN_PAR" != 0
		then
		    SVL_OPEN_PAR=`SVL_EXPR $SVL_OPEN_PAR - 1`
		fi;;
	    esac
	esac
    done
    SVL_WRITE_FILE "$1" "$SVL_CURRENT_LINE" "$3"
}

#-----------------------------------------------------------------------------

SVL_SHOW_FILE () {
    ####
    # $1 is the name of the file to show
    ####
    SVL_PRINT_NEWLINE
    SVL_PRINT_MESSAGE "\"$1\" ="
    SVL_LOCAL_EXTENSION=`SVL_EXTENSION "$1"`
    if test "$SVL_LOCAL_EXTENSION" = "mcl" -o "$SVL_LOCAL_EXTENSION" = "xtl"
    then
	# MCL or XTL file containing a formula written by the user; all
	# comments are kept
	if test "$SVL_SILENT" = ""
	then
	    cat "$1" | tr -d '\015' | sed -e "s/^/    $SVL_INDENTING/" | tee -a "$SVL_LOG_FILE"
	else
	    cat "$1" | tr -d '\015' | sed -e "s/^/    $SVL_INDENTING/" >> "$SVL_LOG_FILE"
	fi
    else
	# automatically generated file from which comments (which are
	# annotations for SVL) are removed
	if test "$SVL_SILENT" = ""
	then
	    cat "$1" | tr -d '\015' | sed -e 's/ (\*.*\*)//;/^(\*.*\*)$/d' | sed -e "s/^/    $SVL_INDENTING/" | tee -a "$SVL_LOG_FILE"
	else
	    cat "$1" | tr -d '\015' | sed -e 's/ (\*.*\*)//;/^(\*.*\*)$/d' | sed -e "s/^/    $SVL_INDENTING/" >> "$SVL_LOG_FILE"
	fi
    fi
}

#-----------------------------------------------------------------------------

SVL_SHOW_FILE_IN_LOG () {
    ####
    # $1 is the name of the file to show in LOG
    # show it on a single line
    ####
    SVL_PRINT_LOG_MESSAGE ""
    SVL_PRINT_LOG_MESSAGE "\"$1\" ="
    cat "$1" | sed -e 's/^/    /' >> "$SVL_LOG_FILE"
}

#-----------------------------------------------------------------------------

SVL_SYNC_TO_HIDE () {
    ####
    # $1 is the name of the existing sync file
    # $2 is the name of the hide file to create with a negation of the hide matching mode
    ####
    SVL_EXECUTE "{ cat \"$1\" ; "$ECHO" ;} | sed -e '1s/[Ss]ync[ ]*all[ ]*but/hide/' | sed -e '1s/[Ss]ync/hide all but/' > \"$2\""
}

#-----------------------------------------------------------------------------

SVL_GET_PARTIAL_ORDER_REDUCTION_OPTION () {
    ####
    # $1 is a reduction relation among strong, branching, ..., ratebranching
    # echo the Exp.Open partial order reduction option most adapted to 
    # preserve the equivalence relation $1
    ####
    case "$1" in
    strong|trace|tau-compression|tau-divergence|divbranching)
	"$ECHO" "-strong"
	;;
    ratebranching)
	"$ECHO" "-rate -branching"
	;;
    weaktrace)
	"$ECHO" "-weaktrace"
	;;
    *)
	# all other reductions are weaker or equal to branching or to
	# the -branching partial order reduction performed by exp.open in the 
	# case of tau-confluence
	"$ECHO" "-branching"
	;;
    esac
}

#-----------------------------------------------------------------------------

SVL_CHECK_EXP_OPEN_OPTIONS () {
    ####
    # check that the options defined by the user in $EXP_OPEN_OPTIONS
    # are consistent, i.e., that partial order reduction options are
    # mutually exclusive
    ####
    SVL_LOCAL_FOUND=
    for SVL_LOCAL_OPTION in "branching" \
			    "deadpreserving" \
			    "strong" \
			    "weaktrace" \
			    "ratebranching"
    do
	SVL_LOCAL_TMP=`"$ECHO" "$EXP_OPEN_OPTIONS" | SVL_GREP "\-$SVL_LOCAL_OPTION"`
	if test "$SVL_LOCAL_TMP" != ""
	then
	    # option -$SVL_LOCAL_OPTION is present in $EXP_OPEN_OPTIONS
	    if test "$SVL_LOCAL_OPTION" = "ratebranching"
	    then
		SVL_WARNING "option -ratebranching is deprecated, use \"-rate -branching\" instead"
		SVL_LOCAL_OPTION="branching"
	    fi
	    if test "$SVL_LOCAL_FOUND" != "" -a \
		    "$SVL_LOCAL_FOUND" != "$SVL_LOCAL_OPTION"
	    then
		SVL_ERROR "variable \$EXP_OPEN_OPTIONS contains mutually exclusive options -$SVL_LOCAL_FOUND and -$SVL_LOCAL_OPTION"
		return
	    fi
	    SVL_LOCAL_FOUND="$SVL_LOCAL_OPTION"
	fi
    done
}

#-----------------------------------------------------------------------------

SVL_EXTRACT_EXP_OPEN_PARTIAL_ORDER_OPTION () {
    ####
    # extract from $EXP_OPEN_OPTIONS a possible partial order reduction
    # option for exp.open
    ####
    for SVL_LOCAL_OPTION in "branching" \
			    "deadpreserving" \
			    "strong" \
			    "weaktrace" \
			    "ratebranching"
    do
	SVL_LOCAL_TMP=`"$ECHO" "$EXP_OPEN_OPTIONS" | SVL_GREP "\-$SVL_LOCAL_OPTION"`
	if test "$SVL_LOCAL_TMP" != ""
	then
	    if test "$SVL_LOCAL_OPTION" = "ratebranching"
	    then
		"$ECHO" "-branching"
	    else
		"$ECHO" "-$SVL_LOCAL_OPTION"
	    fi
	    return
	fi
    done
    "$ECHO" ""
}

#-----------------------------------------------------------------------------

SVL_GENERATOR () {
    ####
    # $1 is the input (.exp)
    # $2 is the output (any type)
    # $3 is a possible equivalence relation modulo which $2 can be reduced
    # (using partial order reduction)
    # if $4 is set then do not print messages
    # Post: $2 is an automaton generated from $1
    ####
    if test "$4" = ""
    then
	SVL_PRINT_NEWLINE
	SVL_PRINT_MESSAGE "\"$2\" = generation of \"$1\"" 
    fi
    SVL_LOCAL_BASENAME=`SVL_BASENAME_OPEN_CAESAR_TOOL "$GENERATOR_EXECUTABLE"`
    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME"
    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME.o"
    SVL_LOCAL_PREFIX="`SVL_PREFIX "$1"`"
    SVL_RECORD_FOR_SWEEP "${SVL_LOCAL_PREFIX}.c"
    SVL_RECORD_FOR_SWEEP "${SVL_LOCAL_PREFIX}.o"
    if test `SVL_TYPE "$2"` != "bcg"
    then
	SVL_LOCAL_GENERATOR_OUTPUT="${SVL_TMP_PREFIX}_output.bcg"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_GENERATOR_OUTPUT"
    else
	SVL_LOCAL_GENERATOR_OUTPUT="$2"
    fi
    SVL_CHECK_EXP_OPEN_OPTIONS
    # check whether partial order reduction must be used
    if test "`SVL_EXTRACT_EXP_OPEN_PARTIAL_ORDER_OPTION`" != ""
    then
	# partial order reduction option is already defined by the user, we
	# do not add one
	SVL_LOCAL_PARTIAL_ORDER_REDUCTION_OPTION=
    else
	# partial order reduction option is inferred from the context
	SVL_LOCAL_PARTIAL_ORDER_REDUCTION_OPTION=`SVL_GET_PARTIAL_ORDER_REDUCTION_OPTION "$3"`
    fi
    # call exp.open
    SVL_EXECUTE "`SVL_TIME`$EXP_OPEN_EXECUTABLE $SVL_LOCAL_PARTIAL_ORDER_REDUCTION_OPTION $SVL_USER_INTERFACE $EXP_OPEN_OPTIONS \"$1\" $EXP_OPEN_CC_OPTIONS $GENERATOR_EXECUTABLE $GENERATOR_OPTIONS \"$SVL_LOCAL_GENERATOR_OUTPUT\""
    SVL_CONVERT_AND_REMOVE "$SVL_LOCAL_GENERATOR_OUTPUT" "$2"
    "$CADP"/src/com/cadp_rm "generator"
    SVL_REMOVE "generator.o" "${SVL_LOCAL_PREFIX}.c" "${SVL_LOCAL_PREFIX}.o"
    if test "$4" = ""
    then
	SVL_INFO "$2"
    fi
    SVL_CHECK_COMPILER_ERROR "$1"
}

#-----------------------------------------------------------------------------

SVL_CHECK_COMPILER_ERROR () {
    ####
    # $1 is the name of an open/caesar input file
    # if this is an EXP, LOTOS, or LNT file, check whether a .err file was
    # created
    # if this is the case, then save the .err file and issue a warning
    # message
    ####
    SVL_LOCAL_TYPE=`SVL_TYPE "$1"`
    SVL_LOCAL_PREFIX=
    if test "$SVL_LOCAL_TYPE" = ""
    then
	SVL_LOCAL_PREFIX="$1"
    elif test "$SVL_LOCAL_TYPE" = "exp" -o "$SVL_LOCAL_TYPE" = "lot" -o "$SVL_LOCAL_TYPE" = "lnt"
    then
	SVL_LOCAL_PREFIX=`SVL_PREFIX "$1"`
    fi
    if test "$SVL_LOCAL_PREFIX" != "" -a -f "$SVL_LOCAL_PREFIX.err"
    then
	SVL_LOCAL_SAVED_ERROR_FILE="$SVL_LOCAL_PREFIX.err#$SVL_ERROR_FILE_COUNT"
	mv "$SVL_LOCAL_PREFIX.err" "$SVL_LOCAL_SAVED_ERROR_FILE"
	SVL_ERROR_FILE_COUNT=`SVL_EXPR $SVL_ERROR_FILE_COUNT + 1`
	SVL_RECORD_FOR_CLEAN "$SVL_LOCAL_SAVED_ERROR_FILE"
	SVL_WARNING "compiling \"$1\" generated errors or warnings" "messages are reported in file \"$SVL_LOCAL_SAVED_ERROR_FILE\""
    fi
}

#-----------------------------------------------------------------------------

SVL_COMPILE () {
    ####
    # $1 is the name of the FSP/LOTOS/LNT file to compile
    # $2 is the required type of the output, one of those 
    # accepted as output of bcg_io
    # $3 is the name of the root, or "" if none specified
    # $4 is the prefix of the generated automaton
    # if $5 is set, do not print messages
    # Generates $4.$2 representing automaton of $1 rooted in $3.
    ####
    SVL_CHECK_DEFAULT_PROGRAM
    if test "$5" = ""
    then
    	SVL_PRINT_NEWLINE
    	if test "$3" != ""
    	then
	    SVL_PRINT_MESSAGE "\"$4.$2\" = generation of \"$1\":\"$3\""
    	else 
	    SVL_PRINT_MESSAGE "\"$4.$2\" = generation of \"$1\""
        fi
    fi
    SVL_LOCAL_INPUT_TYPE=`SVL_TYPE "$1"`
    if test "$SVL_LOCAL_INPUT_TYPE" = "lts"
    then
	SVL_LOCAL_BASENAME=`SVL_BASENAME_OPEN_CAESAR_TOOL "$GENERATOR_EXECUTABLE"`
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME.o"
	if test "$3" != ""
	then
	    SVL_LOCAL_FSP_OPEN_OPTIONS="-root '$3'"
	else
	    SVL_LOCAL_FSP_OPEN_OPTIONS=
	fi
	if test "$2" != "bcg"
	then
	    SVL_LOCAL_TMP_OUTPUT="${SVL_TMP_PREFIX}_$4.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_OUTPUT"
	else
	    SVL_LOCAL_TMP_OUTPUT="$4.bcg"
	fi
	SVL_EXECUTE "`SVL_TIME`$FSP_OPEN_EXECUTABLE $FSP_OPEN_OPTIONS $SVL_LOCAL_FSP_OPEN_OPTIONS \"$1\" $FSP_OPEN_CC_OPTIONS $GENERATOR_EXECUTABLE $GENERATOR_OPTIONS \"$SVL_LOCAL_TMP_OUTPUT\""
	if test "$5" = ""
	then
	    SVL_INFO "$SVL_LOCAL_TMP_OUTPUT"
	fi
	if test "$2" != "bcg"
	then
	    SVL_CONVERT_AND_REMOVE "$SVL_LOCAL_TMP_OUTPUT" "$4.$2"
	fi
    elif test "$SVL_LOCAL_INPUT_TYPE" = "lnt"
    then
	SVL_LOCAL_PREFIX=`SVL_PREFIX "$1"`
	SVL_LOCAL_BASENAME=`SVL_BASENAME_OPEN_CAESAR_TOOL "$GENERATOR_EXECUTABLE"`
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME.o"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_PREFIX.o"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_PREFIX.err"
	if test "$3" != ""
	then
	    SVL_LOCAL_LNT_OPEN_OPTIONS="-root '$3'"
	else
	    SVL_LOCAL_LNT_OPEN_OPTIONS=
	fi
	if test "$2" != "bcg"
	then
	    SVL_LOCAL_TMP_OUTPUT="${SVL_TMP_PREFIX}_$4.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_OUTPUT"
	else
	    SVL_LOCAL_TMP_OUTPUT="$4.bcg"
	fi
	SVL_EXECUTE "`SVL_TIME`$LNT_OPEN_EXECUTABLE $LNT_OPEN_OPTIONS $SVL_LOCAL_LNT_OPEN_OPTIONS \"$1\" $LNT_OPEN_CC_OPTIONS $GENERATOR_EXECUTABLE $GENERATOR_OPTIONS \"$SVL_LOCAL_TMP_OUTPUT\""
	if test "$5" = ""
	then
	    SVL_INFO "$SVL_LOCAL_TMP_OUTPUT"
	fi
	if test "$2" != "bcg"
	then
	    SVL_CONVERT_AND_REMOVE "$SVL_LOCAL_TMP_OUTPUT" "$4.$2"
	fi
    else
	# "$SVL_LOCAL_INPUT_TYPE" = "lot"
    # To avoid name clashes, alias $1 to $4.lotos
    # Needed because otherwise compilation would overwrite $1.bcg
    # while $1.bcg might be useful (compilation of the same .lotos
    # with a different root...). This would be useless if caesar had a
    # -output option.
    SVL_LOCAL_PREFIX="`SVL_PREFIX "$1"`"
    if SVL_DISTINCT_FILENAMES "$SVL_LOCAL_PREFIX" "$4"
    then
	SVL_RECORD_FOR_SWEEP "$4.h"
	SVL_ALIAS "$1" "$4.lotos"
	# Also link possible .t and .f files
	SVL_ALIAS "${SVL_LOCAL_PREFIX}.t" "$4.t"
	SVL_ALIAS "${SVL_LOCAL_PREFIX}.f" "$4.f"
    fi
    # compile ADT, generate .h
    SVL_RECORD_FOR_SWEEP "${SVL_LOCAL_PREFIX}.h"
    SVL_EXECUTE "`SVL_TIME`$CAESAR_ADT_EXECUTABLE $CAESAR_ADT_OPTIONS \"$1\""
    SVL_MOVE "${SVL_LOCAL_PREFIX}.h" "$4.h"
    # Then choose options for caesar according to required output type
    if test "$2" = "aut"
    then
	SVL_LOCAL_CAESAR_OPTIONS="-aldebaran"
	SVL_LOCAL_OUTPUT_EXTENSION="aut"
    else
	SVL_LOCAL_CAESAR_OPTIONS="-bcg"
	SVL_LOCAL_OUTPUT_EXTENSION="bcg"
    fi
    if test "$3" != ""
    then
	SVL_LOCAL_CAESAR_OPTIONS="$SVL_LOCAL_CAESAR_OPTIONS -root '$3'"
    fi
    # Then call caesar, generate .aut or .bcg
    SVL_EXECUTE "`SVL_TIME`$CAESAR_EXECUTABLE $CAESAR_OPTIONS $SVL_LOCAL_CAESAR_OPTIONS \"$4\""
    SVL_LOCAL_CAESAR_ERROR_FILE="$4.err"
    if test -f "$SVL_LOCAL_CAESAR_ERROR_FILE"
    then
	SVL_LOCAL_ADT_ERROR_FILE="`SVL_PREFIX "$1"`.err"
	if test -f "$SVL_LOCAL_ADT_ERROR_FILE"
	then
	    2>/dev/null cat "$SVL_LOCAL_CAESAR_ERROR_FILE" >> "$SVL_LOCAL_ADT_ERROR_FILE"
	else
	    mv "$SVL_LOCAL_CAESAR_ERROR_FILE" "$SVL_LOCAL_ADT_ERROR_FILE"
	fi
    fi
    if test "$2" != "aut" 
    then 
	SVL_CONVERT_AND_REMOVE "$4.bcg" "$4.$2"
    fi
    if test "$5" = ""
    then
        SVL_INFO "$4.$2"
    fi
    SVL_CHECK_COMPILER_ERROR "$1"
    if SVL_DISTINCT_FILENAMES "$SVL_LOCAL_PREFIX" "$4"
    then
        SVL_REMOVE "$4.lotos"
	SVL_REMOVE "$4.t"
	SVL_REMOVE "$4.f"
    fi
    SVL_MOVE "$4.h" "${SVL_LOCAL_PREFIX}.h"
    fi
}

#-----------------------------------------------------------------------------

SVL_SAFE_OVERWRITE () {
    ####
    # $1 is the name of a LIB or LOTOS file, or a C file with extension .f
    # or .t
    # if $1 does not exist, then nothing happens
    # if $1 exists and cannot be safely overwritten, then an error is issued;
    # otherwise, nothing happens
    ####
    # see SVL_UPDATE_GENERATEDBY_COMMENT() below for a meaning of comments of
    # the form
    #		(* generated by svl ... and lnt2lotos ... *)
    #		/* generated by svl ... and lnt2lotos ... */
    if [ -f "$1" ]
    then
	# $1 exists, we check whether it can be safely removed
	SVL_LOCAL_FIRST_LINE=`head -n 1 "$1"`
	case "$1" in
	*.lot | *.lotos | *.lib )
	    case "$SVL_LOCAL_FIRST_LINE" in
	    "(* generated by svl "* | "(* generated by lnt2lotos "* )
		;;
	    * )
		SVL_ERROR "file \"$1\" cannot be safely overwritten"
		;;
	    esac
	    ;;
	*.f | *.t )
	    case "$SVL_LOCAL_FIRST_LINE" in
	    "/* generated by svl "* | "/* generated by lnt2lotos "* )
		;;
	    * )
		SVL_ERROR "file \"$1\" cannot be safely overwritten"
		;;
	    esac
	    ;;
	esac
    fi
}

#-----------------------------------------------------------------------------

SVL_UPDATE_GENERATEDBY_COMMENT () {
    ####
    # $1 is the name of an existing LIB or LOTOS file, or a C file with
    # extension .f or .t, generated by lnt.open/ lnt2lotos, which must be
    # kept during the script execution, except if an assignment statement
    # explicitly overwrites it; this procedure changes the comment of the
    # form
    #		(* generated by lnt2lotos ... *)
    #		/* generated by lnt2lotos ... */
    # inserted by lnt.open/lnt2lotos into
    #		(* generated by svl ... and lnt2lotos ... *)
    #		/* generated by svl ... and lnt2lotos ... */
    # to remember that the file was generated by an explicit SVL assignment
    # statement; see SVL_LNT_TO_LOTOS() below for details
    ####
    if [ -f "$1" ]
    then
	case "$1" in
	*.lot | *.lotos | *.lib )
	    cat "$1" |
		sed -e "1s/(\* generated by lnt2lotos \([0-9\.]*\) \*)/(\* generated by svl $SVL_GLOBALVERSION and lnt2lotos \1 \*)/" > "$SVL_TMP_PREFIX"
	    ;;
	*.f | *.t )
	    cat "$1" |
		sed -e "1s/\/\* generated by lnt2lotos \([0-9\.]*\) \*\//\/\* generated by svl $SVL_GLOBAL_VERSION and lnt2lotos \1 \*\//" > "$SVL_TMP_PREFIX"
	    ;;
	esac
	mv "$SVL_TMP_PREFIX" "$1"
    fi
}

#-----------------------------------------------------------------------------

SVL_LNT_TO_LOTOS () {
    ####
    # $1 is the name of the LOTOS file to be generated
    # $2 is the name of the LNT file to be translated into LOTOS
    # $3 is the root process, if any
    ####
    LNT_PREFIX=`"$CADP"/src/com/cadp_basename "$2" .lnt`
    case "$1" in
    *.lotos )
	LOTOS_PREFIX=`"$CADP"/src/com/cadp_basename "$1" .lotos`
	;;
    *.lot )
	LOTOS_PREFIX=`"$CADP"/src/com/cadp_basename "$1" .lot`
	;;
    esac
    SVL_PRINT_NEWLINE
    if [ "$3" != "" ]
    then
	SVL_PRINT_MESSAGE "\"$1\" = \"$2\":\"$3\""
	ROOT_INFO=" -root \"$3\""
    else
	SVL_PRINT_MESSAGE "\"$1\" = \"$2\""
	ROOT_INFO=
    fi

    # We compute the list of LNT files on which $2 depends, and we record
    # the list of generated LIB, LOTOS, and C files for cleaning, making sure
    # that they can be safely overwritten if they exist.
    SVL_LOCAL_DEPEND_FILES=
    for SVL_LOCAL_PREFIX in `$LNT_DEPEND_EXECUTABLE -modlist "$2"`
    do
	SVL_LOCAL_DEPEND_FILES="$SVL_LOCAL_DEPEND_FILES $SVL_LOCAL_PREFIX.lib $SVL_LOCAL_PREFIX.t $SVL_LOCAL_PREFIX.f"
    done
    for SVL_LOCAL_FILE in "$1" $SVL_LOCAL_DEPEND_FILES \
			  "$LOTOS_PREFIX.t" "$LOTOS_PREFIX.f"
    do
	SVL_SAFE_OVERWRITE "$SVL_LOCAL_FILE"
	SVL_REMOVE "$SVL_LOCAL_FILE"
	SVL_RECORD_FOR_CLEAN "$SVL_LOCAL_FILE"
    done

    # Translation of $2 into LOTOS
    SVL_EXECUTE "`SVL_TIME`$LNT_OPEN_EXECUTABLE$ROOT_INFO $2 -"
    SVL_CHECK_COMPILER_ERROR "$2"

    # The comments
    #		(* generated by lnt2lotos <version> *)
    #		/* generated by lnt2lotos <version> */
    # (first form) written by lnt.open/lnt2lotos at the very first line of the
    # generated LIB, LOTOS, and C files depending on "$LNT_PREFIX.lotos" are
    # changed into
    #		(* generated by svl <version> and lnt2lotos <version> *)
    #		/* generated by svl <version> and lnt2lotos <version> */
    # (second form). This guarantees that lnt.open/lnt2lotos will not
    # overwrite these files in subsequent verification statements, as not
    # finding a comment of the first form has lnt.open/lnt2lotos stop with an
    # error message. This is sound, because these files should remain available
    # to the user until the end of the script execution. Comments of the second
    # form will be checked by SVL (see below) to prevent itself from
    # overwriting a LIB, LOTOS, or C file generated using the current
    # procedure.
    for SVL_LOCAL_FILE in "$LNT_PREFIX.lotos" $SVL_LOCAL_DEPEND_FILES \
			  "$LOTOS_PREFIX.t" "$LOTOS_PREFIX.f"
    do
	SVL_UPDATE_GENERATEDBY_COMMENT "$SVL_LOCAL_FILE"
    done

    # If "$1" and "$LNT_PREFIX.lotos" differ, we now move the latter to the
    # former. We have already made sure earlier that "$1" cannot be an
    # existing user-defined file.
    if SVL_DISTINCT_FILENAMES "$1" "$LNT_PREFIX.lotos"
    then
	SVL_MOVE "$LNT_PREFIX.lotos" "$1"
	if SVL_DISTINCT_FILENAMES "$LOTOS_PREFIX" "$LNT_PREFIX"
	then
	    # We also have to move possibly existing .t and .f files
	    if [ -f "$LNT_PREFIX.t" ]
	    then
		SVL_MOVE "$LNT_PREFIX.t" "$LOTOS_PREFIX.t"
	    fi
	    if [ -f "$LNT_PREFIX.f" ]
	    then
		SVL_MOVE "$LNT_PREFIX.f" "$LOTOS_PREFIX.f"
	    fi
	fi
    fi
}

#-----------------------------------------------------------------------------

SVL_CLEAN_LNT_DEPEND () {
    ####
    # $1 is the name of an LNT file
    # remove its .lotos, .t, .f, .lib generated dependencies
    ####
    for SVL_LOCAL_DEPENDENCY in `$LNT_DEPEND_EXECUTABLE -modlist "$1"`
    do
	SVL_REMOVE "$SVL_LOCAL_DEPENDENCY.lib"
	SVL_REMOVE "$SVL_LOCAL_DEPENDENCY.f"
	SVL_REMOVE "$SVL_LOCAL_DEPENDENCY.t"
    done
    SVL_LOCAL_PREFIX=`SVL_PREFIX "$1"`
    SVL_REMOVE "$SVL_LOCAL_PREFIX.lotos"
    SVL_REMOVE "$SVL_LOCAL_PREFIX.f"
    SVL_REMOVE "$SVL_LOCAL_PREFIX.t"
}

#-----------------------------------------------------------------------------

SVL_CHECK_LABELS_IN_GATE_MODE () {
    ####
    # $1 is the file containing the renaming, hiding, cutting, or sync rules 
    # check whether the renamed, hidden, or cut labels have offers; if so,
    # issue a warning because labels with offers make no sense in gate mode
    ####
    SVL_LOCAL_KEY=`SVL_TYPE "$1"`
    case "$SVL_LOCAL_KEY" in
    "ren")
	SVL_LOCAL_KEY="rename"
	;;
    "hid")
	SVL_LOCAL_KEY="hide"
	;;
    esac
    case "$SVL_LOCAL_KEY" in
    "hide"|"cut"|"sync")
        SVL_LOCAL_SUSPICIOUS_OFFER=`cat "$1" | SVL_GREP -i -v "$SVL_LOCAL_KEY" | SVL_GREP '\([^ 	]\{1,\}\)\([ 	]\{1,\}\)\([^ 	]\{1,\}\)'`
	if test "$SVL_LOCAL_SUSPICIOUS_OFFER" = ""
	then
	    SVL_LOCAL_SUSPICIOUS_OFFER=`SVL_GREP '!' "$1"`
	fi
	;;
    "rename")
	SVL_LOCAL_SUSPICIOUS_OFFER=`cat "$1" | SVL_GREP -i -v "$SVL_LOCAL_KEY" | SVL_GREP '\([^ 	]\{1,\}\)\([ 	]\{1,\}\)\([^ 	]\{1,\}\(.*\)\)->\(.*\)'`
	if test "$SVL_LOCAL_SUSPICIOUS_OFFER" = ""
	then
	    SVL_LOCAL_SUSPICIOUS_OFFER=`SVL_GREP '!.*->' "$1"`
	fi
	;;
    esac
    if test "$SVL_LOCAL_SUSPICIOUS_OFFER" != ""
    then
	case "$SVL_LOCAL_KEY" in
	"hide")
	    SVL_WARNING "hiding labels with offers is incompatible with the gate" "(default) hiding attribute - you might want to specify a hiding" "with attribute total or partial"
	    ;;
	"cut")
	    SVL_WARNING "cutting labels with offers is incompatible with the gate" "(default) cutting attribute - you might want to specify a cut" "with attribute total or partial"
	    ;;
	"sync")
	    SVL_WARNING "synchronizing labels with offers is incompatible with the" "gate (default) synchronization attribute - you might want to specify a" "synchronization with attribute total or partial"
	    ;;
	"rename")
	    SVL_WARNING "renaming labels with offers is incompatible with the gate" "(default) renaming attribute - you might want to specify a renaming" "with attribute total, single, or multiple"
	    ;;
	esac
    fi
}

#-----------------------------------------------------------------------------

SVL_LABEL () {
    ####
    # $1 is -rename or -hide, according to the action to perform on $4
    # $2 is matching option (-gate, -total, etc., see man bcg_labels)
    # $3 is the name of the hide or rename file
    # $4 is the name of the behaviour we want to hide or rename gates of (.bcg)
    # $5 is the name of the resulting behaviour (any type output of bcg_io)
    # $6 is either "userfile", or "items" according to the origin of $3
    ####
    if test `SVL_TYPE "$5"` != "bcg"
    then
	SVL_LOCAL_LABEL_OUTPUT="${SVL_TMP_PREFIX}_input.bcg"
    else
	SVL_LOCAL_LABEL_OUTPUT="$5"
    fi
    SVL_LOCAL_MSG="`"$ECHO" "$2" | cut -d '-' -f 2`"
    if test "$SVL_LOCAL_MSG" = "gate"
    then
	# gate is default matching option, not printed on the output
	SVL_LOCAL_MSG=
    else
	SVL_LOCAL_MSG="${SVL_LOCAL_MSG} "
    fi
    SVL_LOCAL_MSG="${SVL_LOCAL_MSG}`"$ECHO" "$1" | cut -d '-' -f 2`"
    SVL_SET_HIDE_RENAME_SYNC "$3" "$6" 
    SVL_PRINT_NEWLINE
    SVL_PRINT_MESSAGE "\"$5\" = ${SVL_LOCAL_MSG} ${SVL_HIDE_RENAME_SYNC}"
    SVL_PRINT_MESSAGE "    in \"$4\""
    if test "$2" = "-gate"
    then
	SVL_CHECK_LABELS_IN_GATE_MODE "$3"
    fi
    SVL_EXECUTE "`SVL_TIME`$BCG_LABELS_EXECUTABLE $BCG_OPTIONS ${BCG_LABELS_OPTIONS} $1 $2 \"$3\" \"$4\" \"$SVL_LOCAL_LABEL_OUTPUT\""
    SVL_CONVERT_AND_REMOVE  "$SVL_LOCAL_LABEL_OUTPUT" "$5"
}

#-----------------------------------------------------------------------------

SVL_REDUCTION () {  
    ####
    # $1 is the tool (aldebaran, bcg_min, or default) chosen 
    # to perform reduction
    # $2 is the reduction relation : strong, observational, branching, 
    # divbranching, tau*.a, safety, trace, or weak trace
    # $3 is either "-prob" or "-rate" (used for bcg_min only), or ""
    # $4 is the method : std, fly, bdd, dfs, bfs, acyclic
    # or default
    # $5 is the file to reduce (any type)
    # $6 is the possible root process (if $5 is a FSP/LOTOS/LNT file)
    # $7 is the output, of any type output of bcg_io
    # $8 is either "partial" (partial reduction) or "" (total reduction)
    # $9 is an intermediate prefix used in case the generation of $5 is needed
    # if present, $10 is an equivalence relation (strong or branching) with
    # respect to which $5 is already minimal
    ####
    # we first test whether the script sets obsolete variables, in which
    # case the user is warned
    if test "$SVL_DEFAULT_REDUCTION_TOOL_LTS" != "" 
    then
	SVL_WARNING_OBSOLETE_VARIABLE "\$SVL_DEFAULT_REDUCTION_TOOL_LTS" "\$SVL_DEFAULT_REDUCTION_TOOL"
    fi
    if test "$SVL_DEFAULT_REDUCTION_TOOL_EXP" != ""
    then
	SVL_WARNING_OBSOLETE_VARIABLE "\$SVL_DEFAULT_REDUCTION_TOOL_EXP" "\$SVL_DEFAULT_REDUCTION_TOOL"
    fi
    if test "$SVL_DEFAULT_REDUCTION_METHOD_LTS" != "" 
    then
	SVL_WARNING_OBSOLETE_VARIABLE "\$SVL_DEFAULT_REDUCTION_METHOD_LTS" "\$SVL_DEFAULT_REDUCTION_METHOD"
    fi
    if test "$SVL_DEFAULT_REDUCTION_METHOD_EXP" != "" 
    then
	SVL_WARNING_OBSOLETE_VARIABLE "\$SVL_DEFAULT_REDUCTION_METHOD_EXP" "\$SVL_DEFAULT_REDUCTION_METHOD"
    fi
    # extraction of the primary reduction tool and initialization of the
    # possible secondary tool (bcg_min)
    SVL_LOCAL_PRIMARY_TOOL="$1"
    SVL_LOCAL_SECONDARY_TOOL=""
    SVL_LOCAL_RELATION="$2"
    SVL_LOCAL_PROB_RATE="$3"
    SVL_LOCAL_METHOD="$4"
    SVL_LOCAL_REDUCE_FILE="$5"
    SVL_LOCAL_ROOT="$6"
    SVL_LOCAL_OUTPUT="$7"
    SVL_LOCAL_PARTIAL_REDUCTION_FLAG="$8"
    SVL_LOCAL_INTERMEDIATE_PREFIX="$9"
    shift
    SVL_LOCAL_ALREADY_REDUCED="$9"
    # if $SVL_LOCAL_PRIMARY_TOOL has the "default", then the primary and
    # secondary tools are chosen accordingly with the the reduction to implement
    if test "$SVL_LOCAL_PRIMARY_TOOL" = "default"
    then
	if test "$SVL_LOCAL_PARTIAL_REDUCTION_FLAG" != ""
	then
	    # partial reduction => reductor
	    SVL_LOCAL_PRIMARY_TOOL="reductor"
	elif test "$SVL_LOCAL_PROB_RATE" != ""
	then
	    # prob/rate reduction => bcg_min
	    SVL_LOCAL_PRIMARY_TOOL="bcg_min"
	else
	    # neither prob/rate nor partial => inspect the relation
	    case "$SVL_LOCAL_RELATION" in
	    strong|branching|divbranching|observational)
	        SVL_LOCAL_PRIMARY_TOOL="bcg_min"
	        ;;
	    "tau*.a"|safety|tau-compression|tau-divergence|tau-confluence|trace|"weak trace")
		SVL_LOCAL_PRIMARY_TOOL="reductor"
		SVL_LOCAL_SECONDARY_TOOL="bcg_min"
		;;
	    *)
	        SVL_LOCAL_PRIMARY_TOOL="aldebaran"
	        ;;
	    esac
	fi
    fi
    # if the reduction is partial, the first tool must be reductor
    if test "$SVL_LOCAL_PARTIAL_REDUCTION_FLAG" != "" -a "$SVL_LOCAL_PRIMARY_TOOL" != "reductor"
    then
	SVL_WARNING "$SVL_LOCAL_PRIMARY_TOOL cannot be used for partial reduction" "using reductor instead"
	SVL_LOCAL_PRIMARY_TOOL="reductor"
    fi
    # setting the method
    if test "$SVL_LOCAL_METHOD" = "default"
    then
	SVL_LOCAL_METHOD="std"
    fi
    # First check valid combinations of tool/method/relation
    # in case it is invalid, change parameters so as to choose a valid one
    # trying to preserve first the type of reduction (probabilistic or
    # stochastic), the relation, the tool, and at last the method
    if test "$SVL_LOCAL_PARTIAL_REDUCTION_FLAG" != ""
    then
        # observational, branching, and divbranching partial reduction not
	# available
	if test "$SVL_LOCAL_RELATION" = "observational" -o "$SVL_LOCAL_RELATION" = "branching" -o "$SVL_LOCAL_RELATION" = "divbranching"
	then
	    SVL_WARNING "partial $SVL_LOCAL_RELATION reduction is not available" "performing total reduction instead"
	    SVL_LOCAL_PARTIAL_REDUCTION_FLAG=""
	fi
        # prob/rate partial reduction not available
	if test "$SVL_LOCAL_PROB_RATE" != ""
	then
	    SVL_WARNING "partial stochastic/probabilistic reduction is not available" "performing total reduction instead"
	    SVL_LOCAL_PARTIAL_REDUCTION_FLAG=""
	fi
	# other relations require reductor
	if test \( "$SVL_LOCAL_RELATION" = "strong" -o "$SVL_LOCAL_RELATION" = "tau*.a" -o "$SVL_LOCAL_RELATION" = "safety" -o "$SVL_LOCAL_RELATION" = "tau-compression" -o "$SVL_LOCAL_RELATION" = "tau-divergence" -o "$SVL_LOCAL_RELATION" = "tau-confluence" -o "$SVL_LOCAL_RELATION" = "trace" -o "$SVL_LOCAL_RELATION" = "weak trace" \) -a "$SVL_LOCAL_PRIMARY_TOOL" != "reductor"
	then
	    SVL_WARNING "$SVL_LOCAL_PRIMARY_TOOL cannot perform partial $SVL_LOCAL_RELATION reduction" "using reductor instead"
	    SVL_LOCAL_PRIMARY_TOOL="reductor"
	fi
    fi
    if test "$SVL_LOCAL_PROB_RATE" != ""
    then
        # prob/rate reduction requires bcg_min
	if test "$SVL_LOCAL_PRIMARY_TOOL" != "bcg_min"
	then
	    SVL_WARNING "$SVL_LOCAL_PRIMARY_TOOL cannot perform stochastic/probabilistic reduction" "using bcg_min instead"
	    SVL_LOCAL_PRIMARY_TOOL="bcg_min"
	fi
        # prob/rate reduction requires strong, branching, or divbranching
	# equivalence
	if test "$SVL_LOCAL_RELATION" != "strong" -a "$SVL_LOCAL_RELATION" != "branching" -a "$SVL_LOCAL_RELATION" != "divbranching"
	then
	    SVL_WARNING "bcg_min cannot perform stochastic/probabilistic $SVL_LOCAL_RELATION reduction" "using branching reduction instead"
	    SVL_LOCAL_RELATION="branching"
	fi
    fi
    if test \( "$SVL_LOCAL_RELATION" = "tau-confluence" -o "$SVL_LOCAL_RELATION" = "tau-compression" -o "$SVL_LOCAL_RELATION" = "tau-divergence" -o "$SVL_LOCAL_RELATION" = "trace" -o "$SVL_LOCAL_RELATION" = "weak trace" \) -a "$SVL_LOCAL_PRIMARY_TOOL" != "reductor"
    then
        # only reductor can do these relations
	SVL_WARNING "$SVL_LOCAL_PRIMARY_TOOL cannot perform $SVL_LOCAL_RELATION reduction" "using reductor instead"
	SVL_LOCAL_PRIMARY_TOOL="reductor"
    fi
    # now checking that $SVL_LOCAL_PRIMARY_TOOL implements the required
    # relation
    if test "$SVL_LOCAL_RELATION" = "branching" -a "$SVL_LOCAL_PRIMARY_TOOL" != "bcg_min" -a "$SVL_LOCAL_PRIMARY_TOOL" != "aldebaran"
    then
	SVL_WARNING "$SVL_LOCAL_PRIMARY_TOOL cannot perform $SVL_LOCAL_RELATION reduction" "using bcg_min instead"
	SVL_LOCAL_PRIMARY_TOOL="bcg_min"
    fi
    if test "$SVL_LOCAL_RELATION" = "divbranching" -a "$SVL_LOCAL_PRIMARY_TOOL" != "bcg_min"
    then
	SVL_WARNING "$SVL_LOCAL_PRIMARY_TOOL cannot perform $SVL_LOCAL_RELATION reduction" "using bcg_min instead"
	SVL_LOCAL_PRIMARY_TOOL="bcg_min"   
    fi
    if test \( "$SVL_LOCAL_RELATION" = "safety" -o "$SVL_LOCAL_RELATION" = "tau*.a" \) -a \( "$SVL_LOCAL_PRIMARY_TOOL" != "aldebaran" -a "$SVL_LOCAL_PRIMARY_TOOL" != "reductor" \)
    then
	SVL_WARNING "$SVL_LOCAL_PRIMARY_TOOL cannot perform $SVL_LOCAL_RELATION reduction" "using reductor instead"
	SVL_LOCAL_PRIMARY_TOOL="reductor"
    fi
    # now checking the method
    if test "$SVL_LOCAL_PRIMARY_TOOL" = "bcg_min" -a "$SVL_LOCAL_METHOD" != "std"
    then
	SVL_WARNING "$SVL_LOCAL_PRIMARY_TOOL cannot perform reduction using method $SVL_LOCAL_METHOD" "on explicit LTS - using method std instead"
	SVL_LOCAL_METHOD="std"
    fi
    if test "$SVL_LOCAL_PRIMARY_TOOL" = "aldebaran"
    then
	if test "$SVL_LOCAL_METHOD" = "fly"
	then
	    SVL_WARNING "aldebaran cannot perform reduction using method fly" "on explicit LTS - using method std instead"
	    SVL_LOCAL_METHOD="std"
        elif test "$SVL_LOCAL_METHOD" = "bdd" -a \( "$SVL_LOCAL_RELATION" = "observational" -o "$SVL_LOCAL_RELATION" = "safety" \)
	then
	    SVL_WARNING "aldebaran cannot perform $SVL_LOCAL_RELATION reduction using method bdd" "on explicit LTS - using method std instead"
	    SVL_LOCAL_METHOD="std"
	fi
    fi
    # No total trace/weak trace reduction with reductor only
    # bcg_min must be used as secondary tool 
    if test \( "$SVL_LOCAL_PARTIAL_REDUCTION_FLAG" = "" -a "$SVL_LOCAL_SECONDARY_TOOL" = "" \) -a \( "$SVL_LOCAL_RELATION" = "trace" -o "$SVL_LOCAL_RELATION" = "weak trace" \)
    then
	SVL_WARNING "total $SVL_LOCAL_RELATION reduction cannot be done by reductor" "doing partial $SVL_LOCAL_RELATION reduction with $SVL_LOCAL_PRIMARY_TOOL" "then total strong reduction with bcg_min instead"
	SVL_LOCAL_SECONDARY_TOOL="bcg_min"
    fi
    # Now the combination tool/method/relation/prob_rate is valid
    if test "$SVL_LOCAL_SECONDARY_TOOL" != ""
    then
	SVL_LOCAL_TOOLS="$SVL_LOCAL_PRIMARY_TOOL $SVL_LOCAL_SECONDARY_TOOL"
    else
	SVL_LOCAL_TOOLS="$SVL_LOCAL_PRIMARY_TOOL"
    fi
    SVL_APPLY_REDUCTION "$SVL_LOCAL_TOOLS" "$SVL_LOCAL_RELATION" "$SVL_LOCAL_PROB_RATE" "$SVL_LOCAL_METHOD" "$SVL_LOCAL_REDUCE_FILE" "$SVL_LOCAL_ROOT" "$SVL_LOCAL_OUTPUT" "$SVL_LOCAL_PARTIAL_REDUCTION_FLAG" "$SVL_LOCAL_INTERMEDIATE_PREFIX"
    # SVL_APPLY_REDUCTION set variable SVL_FAILED_FLAG if reduction failed
    if test "$SVL_FAILED_FLAG" != ""
    then
	SVL_LOCAL_RECOVER_FILE="$SVL_LOCAL_REDUCE_FILE"
	if test `SVL_TYPE "$SVL_LOCAL_REDUCE_FILE"` = exp
	then
	    if test -f "$SVL_LOCAL_INTERMEDIATE_PREFIX.bcg"
	    then
		# intermediate file $SVL_LOCAL_INTERMEDIATE_PREFIX.bcg was
		# generated by SVL_APPLY_REDUCTION
		SVL_LOCAL_RECOVER_FILE="$SVL_LOCAL_INTERMEDIATE_PREFIX.bcg"
	    fi
	fi
	SVL_LOCAL_WARNING_MESSAGE="$SVL_LOCAL_RELATION reduction with $SVL_LOCAL_PRIMARY_TOOL failed"
	case "$SVL_LOCAL_RELATION" in
	"strong")
	    if test "$SVL_LOCAL_PRIMARY_TOOL" != "bcg_min"
	    then
		SVL_WARNING "$SVL_LOCAL_WARNING_MESSAGE" "trying bcg_min instead"
		(SVL_REDUCTION "bcg_min" "$SVL_LOCAL_RELATION" "$SVL_LOCAL_PROB_RATE" "$SVL_LOCAL_METHOD" "$SVL_LOCAL_RECOVER_FILE" "$SVL_LOCAL_ROOT" "$SVL_LOCAL_OUTPUT" "$SVL_LOCAL_PARTIAL_REDUCTION_FLAG" "$SVL_LOCAL_INTERMEDIATE_PREFIX" "$SVL_LOCAL_ALREADY_REDUCED")
		SVL_CHECK_EXIT "$?"
	    elif SVL_DISTINCT_FILENAMES "$SVL_LOCAL_RECOVER_FILE" "$SVL_LOCAL_REDUCE_FILE"
	    then
		SVL_WARNING "$SVL_LOCAL_WARNING_MESSAGE" "resuming with $SVL_LOCAL_RECOVER_FILE instead"
		SVL_CONVERT "$SVL_LOCAL_RECOVER_FILE" "$SVL_LOCAL_OUTPUT" "msg"
	    else
		SVL_ERROR "$SVL_LOCAL_WARNING_MESSAGE" "cannot resume"
	    fi ;;
	"branching")
	    if test "$SVL_LOCAL_PRIMARY_TOOL" != "bcg_min"
	    then
		SVL_WARNING "$SVL_LOCAL_WARNING_MESSAGE" "trying bcg_min instead"
		(SVL_REDUCTION "bcg_min" "$SVL_LOCAL_RELATION" "$SVL_LOCAL_PROB_RATE" "$SVL_LOCAL_METHOD" "$SVL_LOCAL_RECOVER_FILE" "$SVL_LOCAL_ROOT" "$SVL_LOCAL_OUTPUT" "$SVL_LOCAL_PARTIAL_REDUCTION_FLAG" "$SVL_LOCAL_INTERMEDIATE_PREFIX" "$SVL_LOCAL_ALREADY_REDUCED")
		SVL_CHECK_EXIT "$?"
	    else
		if test "$SVL_LOCAL_ALREADY_REDUCED" = ""
		then
		    SVL_WARNING "$SVL_LOCAL_WARNING_MESSAGE" "trying strong reduction of $SVL_LOCAL_RECOVER_FILE first"
		    SVL_LOCAL_AUX_FILE="`SVL_PREFIX "$SVL_LOCAL_REDUCE_FILE"`_str.bcg"
		    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_AUX_FILE"
		    (SVL_REDUCTION "bcg_min" "strong" "$SVL_LOCAL_PROB_RATE" "$SVL_LOCAL_METHOD" "$SVL_LOCAL_RECOVER_FILE" "$SVL_LOCAL_ROOT" "$SVL_LOCAL_AUX_FILE" "$SVL_LOCAL_PARTIAL_REDUCTION_FLAG" "$SVL_LOCAL_INTERMEDIATE_PREFIX" "$SVL_LOCAL_ALREADY_REDUCED")
		    SVL_CHECK_EXIT "$?"
		    if test `SVL_IS_SMALLER "$SVL_LOCAL_AUX_FILE" "$SVL_LOCAL_RECOVER_FILE"`
		    then
			(SVL_REDUCTION "bcg_min" "branching" "$SVL_LOCAL_PROB_RATE" "$SVL_LOCAL_METHOD" "$SVL_LOCAL_AUX_FILE" "" "$SVL_LOCAL_OUTPUT" "$SVL_LOCAL_PARTIAL_REDUCTION_FLAG" "$SVL_LOCAL_INTERMEDIATE_PREFIX" "strong")
			SVL_CHECK_EXIT "$?"
		    else
			SVL_WARNING "strong reduction did not reduce the number of states of $SVL_LOCAL_RECOVER_FILE" "resuming with $SVL_LOCAL_AUX_FILE instead"
			SVL_CONVERT "$SVL_LOCAL_AUX_FILE" "$SVL_LOCAL_OUTPUT" "msg"
		    fi
		    SVL_REMOVE "$SVL_LOCAL_AUX_FILE"
		else
		    SVL_WARNING "$SVL_LOCAL_WARNING_MESSAGE" "resuming with $SVL_LOCAL_RECOVER_FILE instead"
		    SVL_CONVERT "$SVL_LOCAL_RECOVER_FILE" "$SVL_LOCAL_OUTPUT" "msg"
		fi
	    fi ;;
	"divbranching")
	    if test "$SVL_LOCAL_ALREADY_REDUCED" = ""
	    then
		SVL_WARNING "$SVL_LOCAL_WARNING_MESSAGE" "trying strong reduction of $SVL_LOCAL_RECOVER_FILE first"
		SVL_LOCAL_AUX_FILE="`SVL_PREFIX "$SVL_LOCAL_REDUCE_FILE"`_str.bcg"
		SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_AUX_FILE"
		(SVL_REDUCTION "bcg_min" "strong" "$SVL_LOCAL_PROB_RATE" "$SVL_LOCAL_METHOD" "$SVL_LOCAL_RECOVER_FILE" "$SVL_LOCAL_ROOT" "$SVL_LOCAL_AUX_FILE" "$SVL_LOCAL_PARTIAL_REDUCTION_FLAG" "$SVL_LOCAL_INTERMEDIATE_PREFIX" "$SVL_LOCAL_ALREADY_REDUCED")
		SVL_CHECK_EXIT "$?"
		if test `SVL_IS_SMALLER "$SVL_LOCAL_AUX_FILE" "$SVL_LOCAL_RECOVER_FILE"`
		then
	            (SVL_REDUCTION "bcg_min" "divbranching" "$SVL_LOCAL_PROB_RATE" "$SVL_LOCAL_METHOD" "$SVL_LOCAL_AUX_FILE" "" "$SVL_LOCAL_OUTPUT" "$SVL_LOCAL_PARTIAL_REDUCTION_FLAG" "$SVL_LOCAL_INTERMEDIATE_PREFIX" "strong")
		    SVL_CHECK_EXIT "$?"
		else
		    SVL_WARNING "strong reduction did not reduce the number of states of $SVL_LOCAL_RECOVER_FILE" "resuming with $SVL_LOCAL_AUX_FILE instead"
		    SVL_CONVERT "$SVL_LOCAL_AUX_FILE" "$SVL_LOCAL_OUTPUT" "msg"
		fi
		SVL_REMOVE "$SVL_LOCAL_AUX_FILE"
	    else
		SVL_WARNING "$SVL_LOCAL_WARNING_MESSAGE" "resuming with $SVL_LOCAL_RECOVER_FILE instead"
                SVL_CONVERT "$SVL_LOCAL_RECOVER_FILE" "$SVL_LOCAL_OUTPUT" "msg"
            fi
	    ;;
	"observational" | "safety" | "tau*.a" | "trace" | "weak trace")
	    if test "$SVL_LOCAL_ALREADY_REDUCED" != "branching"
	    then
		SVL_WARNING "$SVL_LOCAL_WARNING_MESSAGE" "trying branching reduction of $SVL_LOCAL_RECOVER_FILE first"
		SVL_LOCAL_AUX_FILE="`SVL_PREFIX "$SVL_LOCAL_REDUCE_FILE"`_bra.bcg"
		SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_AUX_FILE"
		(SVL_REDUCTION "bcg_min" "branching" "$SVL_LOCAL_PROB_RATE" "$SVL_LOCAL_METHOD" "$SVL_LOCAL_RECOVER_FILE" "$SVL_LOCAL_ROOT" "$SVL_LOCAL_AUX_FILE" "$SVL_LOCAL_PARTIAL_REDUCTION_FLAG" "$SVL_LOCAL_INTERMEDIATE_PREFIX" "$SVL_LOCAL_ALREADY_REDUCED")
		SVL_CHECK_EXIT "$?"
		if test `SVL_IS_SMALLER "$SVL_LOCAL_AUX_FILE" "$SVL_LOCAL_RECOVER_FILE"`
		then
		    if test "$SVL_LOCAL_RELATION" = "observational"
		    then
			SVL_LOCAL_PRIMARY_TOOL="bcg_min"
		    else
			SVL_LOCAL_PRIMARY_TOOL="reductor"
		    fi
		    (SVL_REDUCTION "$SVL_LOCAL_TOOLS" "$SVL_LOCAL_RELATION" "$SVL_LOCAL_PROB_RATE" "$SVL_LOCAL_METHOD" "$SVL_LOCAL_AUX_FILE" "" "$SVL_LOCAL_OUTPUT" "$SVL_LOCAL_PARTIAL_REDUCTION_FLAG" "$SVL_LOCAL_INTERMEDIATE_PREFIX" "branching")
		    SVL_CHECK_EXIT "$?"
		else
		    SVL_WARNING "branching reduction did not reduce the number of states of $SVL_LOCAL_RECOVER_FILE" "resuming with $SVL_LOCAL_AUX_FILE instead"
		    SVL_CONVERT "$SVL_LOCAL_AUX_FILE" "$SVL_LOCAL_OUTPUT" "msg"
		fi
		SVL_REMOVE "$SVL_LOCAL_AUX_FILE"
	    else
		SVL_WARNING "$SVL_LOCAL_WARNING_MESSAGE" "resuming with $SVL_LOCAL_RECOVER_FILE instead"
                SVL_CONVERT "$SVL_LOCAL_RECOVER_FILE" "$SVL_LOCAL_OUTPUT" "msg"
	    fi;;
	esac
    fi
}

#-----------------------------------------------------------------------------

SVL_PRETTY_PRINT_SMART_EXP () {

    sed -e "/^[ ]*\-\-.*$/d" |
    sed -e "s/(\* V_1 \*).*/	... (\* see $SVL_LOG_FILE for the synchronization rules \*)/;s/(\* P_1 \*).*/	... (\* see $SVL_LOG_FILE for the priority rules of maximal progress \*)/" |
    sed -e "/(\* V_[0-9]* \*).*/d;/(\* P_[0-9]* \*).*/d"
}

#-----------------------------------------------------------------------------

SVL_ADD_EXP_OPEN_RATE_PROB_OPTIONS_FOR_EXP2C () {
    ####
    # extract from $EXP_OPEN_OPTION options that must be passed to exp2c and
    # add them to the option list $1
    ####
    SVL_LOCAL_RESULT="$1"
    for SVL_LOCAL_OPTION in "rate" "prob"
    do
	SVL_LOCAL_TMP=`"$ECHO" "$EXP_OPEN_OPTIONS" | SVL_GREP "\-$SVL_LOCAL_OPTION"`
	if test "$SVL_LOCAL_TMP" != ""
	then
	    SVL_LOCAL_TMP=`"$ECHO" "$SVL_LOCAL_RESULT" | SVL_GREP "\-$SVL_LOCAL_OPTION"`
	    if test "$SVL_LOCAL_TMP" = ""
	    then
		# -$SVL_LOCAL_OPTION option is not already in $SVL_LOCAL_RESULT
		SVL_LOCAL_RESULT="$SVL_LOCAL_RESULT -$SVL_LOCAL_OPTION"
	    fi
	fi
    done
    "$ECHO" "$SVL_LOCAL_RESULT"
}

#-----------------------------------------------------------------------------

SVL_SMART_REDUCTION () {
    ####
    # $1 is the tool (aldebaran, bcg_min, or default) chosen 
    # to perform reduction
    # $2 is the reduction relation : strong, observational, branching, 
    # divbranching, tau*.a, safety, trace, or weak trace
    # $3 is either "-prob", "-rate", or ""
    # $4 is the method : std, fly, bdd, dfs, bfs, acyclic
    # or default
    # $5 is the file to reduce (bcg or exp)
    # $6 is the output, of any type output of bcg_io 
    # $7 is either "partial" (partial reduction) or "" (total reduction)
    # $8 is an intermediate prefix
    ####
    if test `SVL_TYPE $5` != exp
    then
	# $5 is a bcg file
	SVL_REDUCTION "$1" "$2" "$3" "$4" "$5" "" "$6" "$7" "$8"
    else
	SVL_LOCAL_COMPOSITION_COUNT=1
	SVL_LOCAL_EXP2C_INPUT="$5"
	while true
	do
	    SVL_LOCAL_COMPOSITION_PREFIX="$8_composition_${SVL_LOCAL_COMPOSITION_COUNT}"
	    SVL_LOCAL_REMAINDER_PREFIX="$8_remainder_${SVL_LOCAL_COMPOSITION_COUNT}"
	    SVL_LOCAL_SMART_INPUT_PREFIX="$8_all_${SVL_LOCAL_COMPOSITION_COUNT}"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_COMPOSITION_PREFIX.exp"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_COMPOSITION_PREFIX.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_REMAINDER_PREFIX.exp"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_SMART_INPUT_PREFIX.exp"
	    "$CADP"/src/com/cadp_rm "$SVL_LOCAL_REMAINDER_PREFIX.exp"
	    SVL_CHECK_EXP_OPEN_OPTIONS
	    SVL_LOCAL_EXP2C_OPTIONS=`SVL_EXTRACT_EXP_OPEN_PARTIAL_ORDER_OPTION`
	    if test "$SVL_LOCAL_EXP2C_OPTIONS" != ""
	    then
		# partial order reduction option is already defined by the
		# user, we do not add one
		.
	    else
		# partial order reduction option is inferred from the context,
		# here only useful for branching or divbranching
		if test "$2" = "branching" -o "$2" = "divbranching"
		then
		    SVL_LOCAL_EXP2C_OPTIONS="-branching"
		fi
	    fi
	    SVL_LOCAL_EXP2C_OPTIONS="$3 $SVL_LOCAL_EXP2C_OPTIONS"
	    SVL_LOCAL_EXP2C_OPTIONS=`SVL_ADD_EXP_OPEN_RATE_PROB_OPTIONS_FOR_EXP2C "$SVL_LOCAL_EXP2C_OPTIONS"`
	    SVL_EXECUTE "`SVL_TIME`$EXP2C_EXECUTABLE $SVL_LOCAL_EXP2C_OPTIONS $SVL_USER_INTERFACE -smart $DEFAULT_SMART_LIMIT \"$SVL_LOCAL_COMPOSITION_PREFIX\" \"$SVL_LOCAL_REMAINDER_PREFIX\" \"$SVL_LOCAL_EXP2C_INPUT\""
	    SVL_CHECK_COMPILER_ERROR "$SVL_LOCAL_EXP2C_INPUT"
	    if test ! -f "$SVL_LOCAL_REMAINDER_PREFIX.exp"
	    then
		# exp2c did not generate $SVL_LOCAL_REMAINDER_PREFIX.exp, 
		# meaning that $SVL_LOCAL_EXP2C_INPUT must be generated as
		# a whole
		if SVL_DISTINCT_FILENAMES "$SVL_LOCAL_EXP2C_INPUT" "$5"
		then
		    SVL_SHOW_FILE "$SVL_LOCAL_EXP2C_INPUT" |
		    SVL_PRETTY_PRINT_SMART_EXP
		fi
		SVL_REDUCTION "$1" "$2" "$3" "$4" "$SVL_LOCAL_EXP2C_INPUT" "" "$6" "$7" "$8_all"
		break
	    else
		# exp2c did generate $SVL_LOCAL_REMAINDER_PREFIX.exp, meaning
		# that $SVL_LOCAL_COMPOSITION_PREFIX.exp only represents a
		# part of the system
		SVL_SHOW_FILE "$SVL_LOCAL_COMPOSITION_PREFIX.exp" |
		SVL_PRETTY_PRINT_SMART_EXP
		SVL_REDUCTION "$1" "$2" "$3" "$4" "$SVL_LOCAL_COMPOSITION_PREFIX.exp" "" "$SVL_LOCAL_COMPOSITION_PREFIX.bcg" "$7" "$8_${SVL_LOCAL_COMPOSITION_COUNT}"
		SVL_EXECUTE "cp -f \"$SVL_LOCAL_REMAINDER_PREFIX.exp\" \"$SVL_LOCAL_SMART_INPUT_PREFIX.exp\""
		SVL_LOCAL_EXP2C_INPUT="$SVL_LOCAL_SMART_INPUT_PREFIX.exp"
	    fi
	    SVL_LOCAL_COMPOSITION_COUNT=`SVL_EXPR $SVL_LOCAL_COMPOSITION_COUNT + 1`
	done
    fi
}

#-----------------------------------------------------------------------------

SVL_COMPARISON () {
    ####
    # $1 is the tool bisimulator, bcg_cmp, aldebaran, bcg_min, or default
    # $2 is the equivalence relation : strong, observational, branching, 
    # divbranching, tau*.a, safety, trace, or weak trace
    # $3 is a possible option for bcg_cmp (-prob, -rate)
    # $4 is the method : std, fly, bdd
    # $5 is the first input file (any type)
    # $6 is the possible root process associated to $5 if lotos/lnt/lts (FSP)
    # $7 is the second input file (any type)
    # $8 is the possible root process associated to $7 if lotos/lnt/lts (FSP)
    # $9 is an optional diagnostic file
    # ${10} is the operation : EQUAL, GREATER_OR_EQUAL, LESS_OR_EQUAL
    ####
    # all parameters are named and shift is used to access the tenth parameter,
    # because ${10} is not portable (it cannot be used under Solaris) 
    SVL_LOCAL_TOOL="$1"
    SVL_LOCAL_RELATION="$2"
    SVL_LOCAL_PROB_RATE="$3"
    SVL_LOCAL_METHOD="$4"
    SVL_LOCAL_INPUT_1="$5"
    SVL_LOCAL_ROOT_1="$6"
    SVL_LOCAL_INPUT_2="$7"
    SVL_LOCAL_ROOT_2="$8"
    SVL_LOCAL_COMPARISON_OUTPUT="$9"
    shift
    SVL_LOCAL_OP="$9"

    SVL_LOCAL_INITIAL_INPUT_1="$SVL_LOCAL_INPUT_1"
    SVL_LOCAL_INITIAL_INPUT_2="$SVL_LOCAL_INPUT_2"

    # on verifie l'existence de l'outil
    case "$SVL_LOCAL_TOOL" in
    "bisimulator" | "bcg_cmp" | "aldebaran" | "default" )
        ;;
    "bcg_min" | "evaluator" | "evaluator3" | "evaluator4" | "evaluator5" | "exhibitor" | "reductor" )
	SVL_WARNING "$SVL_LOCAL_TOOL cannot perform comparison" "using default tool instead"
	SVL_LOCAL_TOOL="default"
	;;
    * )
	SVL_ERROR "unknown tool $SVL_LOCAL_TOOL"
    esac

    # on verifie et on positionne l'outil et la relation d'equivalence en
    # fonction du type de comparaison (preordre ou equivalence)
    if test "$SVL_LOCAL_OP" != "EQUAL"
    then
	if test "$SVL_LOCAL_TOOL" = "default"
	then
	    SVL_LOCAL_TOOL="bisimulator"
	elif test "$SVL_LOCAL_TOOL" = "bcg_cmp"
	then
	    SVL_WARNING "$SVL_LOCAL_TOOL cannot perform preorder comparison" "using bisimulator instead"
	    SVL_LOCAL_TOOL="bisimulator"
	fi
	if test "$SVL_LOCAL_RELATION" = "divbranching"
	then
	    SVL_WARNING "$SVL_LOCAL_TOOL cannot perform divbranching preorder comparison" "using branching bisimulation instead"
	    SVL_LOCAL_RELATION="branching"
	fi
    fi

    # seul bcg_cmp implemente les options -prob / -stoch
    if test "$SVL_LOCAL_PROB_RATE" != ""
    then
	case "$SVL_LOCAL_PROB_RATE" in
	-prob )
	      RELATION_TYPE="probabilistic"
	      ;;
	-rate )
	      RELATION_TYPE="stochastic"
	      ;;
	esac
	case "$SVL_LOCAL_RELATION" in
	"strong" | "branching" | "divbranching")
	    ;;
	* )
	    SVL_WARNING "$SVL_LOCAL_RELATION $RELATION_TYPE comparison does not exist" "using branching $RELATION_TYPE comparison instead"
	    SVL_LOCAL_RELATION="branching"
	    ;;
	esac
	if test "$SVL_LOCAL_TOOL" = "default"
	then
	    SVL_LOCAL_TOOL="bcg_cmp"
	elif test "$SVL_LOCAL_TOOL" != "bcg_cmp"
	then
	    SVL_WARNING "$SVL_LOCAL_TOOL cannot perform $SVL_LOCAL_RELATION $RELATION_TYPE comparison" "using bcg_cmp instead"
	    SVL_LOCAL_TOOL="bcg_cmp"
	fi
    fi

    # on verifie et on positionne l'outil en fonction de la relation
    # d'equivalence
    case "$SVL_LOCAL_RELATION" in
    "strong" | "observational" | "branching" )
	if test "$SVL_LOCAL_TOOL" = "default"
	then
	    if test "`SVL_IS_EXPLICIT \"$SVL_LOCAL_INPUT_1\"`" = "yes" -a \
	       	    "`SVL_IS_EXPLICIT \"$SVL_LOCAL_INPUT_2\"`" = "yes"
	    then
		SVL_LOCAL_TOOL="bcg_cmp"
	    else
		SVL_LOCAL_TOOL="bisimulator"
	    fi
	fi
    	;;
    "divbranching" )
	if test "$SVL_LOCAL_TOOL" = "default"
	then
	    SVL_LOCAL_TOOL="bcg_cmp"
	elif test "$SVL_LOCAL_TOOL" != "bcg_cmp"
	then
	    SVL_WARNING "$SVL_LOCAL_TOOL cannot perform $SVL_LOCAL_RELATION comparison" "using bcg_cmp instead"
	    SVL_LOCAL_TOOL=bcg_cmp
	fi
	;;
    "tau*.a" | "safety" )
	if test "$SVL_LOCAL_TOOL" = "default"
	then
	    SVL_LOCAL_TOOL="bisimulator"
	elif test "$SVL_LOCAL_TOOL" = "bcg_cmp"
	then
	    SVL_WARNING "$SVL_LOCAL_TOOL cannot perform $SVL_LOCAL_RELATION comparison" "using bisimulator instead"
	    SVL_LOCAL_TOOL="bisimulator"
	fi
	;;
    "trace" | "weak trace" )
	if test "$SVL_LOCAL_TOOL" = "default"
	then
	    SVL_LOCAL_TOOL="bisimulator"
	elif test "$SVL_LOCAL_TOOL" != "bisimulator"
	then
	    SVL_WARNING "$SVL_LOCAL_TOOL cannot perform $SVL_LOCAL_RELATION comparison" "using bisimulator instead"
	    SVL_LOCAL_TOOL="bisimulator"
	fi
	;;
    "tau-confluence" | "tau-compression" | "tau-divergence" )
	SVL_WARNING "comparison modulo $SVL_LOCAL_RELATION is not available" "using branching instead"
	SVL_LOCAL_RELATION="branching"
	if test "$SVL_LOCAL_TOOL" = "default"
	then
	    if test "`SVL_IS_EXPLICIT \"$SVL_LOCAL_INPUT_1\"`" = "yes" -a \
	       	    "`SVL_IS_EXPLICIT \"$SVL_LOCAL_INPUT_2\"`" = "yes"
	    then
		SVL_LOCAL_TOOL="bcg_cmp"
	    else
		SVL_LOCAL_TOOL="bisimulator"
	    fi
	fi
	;;
    * )
	SVL_ERROR "unknown equivalence relation $SVL_LOCAL_RELATION"
    esac

    # On verifie et on positionne la methode en fonction de l'outil
    case "$SVL_LOCAL_TOOL" in
    "bcg_cmp" )
	if test "$SVL_LOCAL_METHOD" = "default"
	then
	    SVL_LOCAL_METHOD="std"
	elif test "$SVL_LOCAL_METHOD" != "std"
	then
	    SVL_WARNING "bcg_cmp cannot use method $SVL_LOCAL_METHOD" "using method std instead"
	    SVL_LOCAL_METHOD="std"
	fi
	;;
    "bisimulator" )
        if test "$SVL_LOCAL_METHOD" = "default"
	then
	    SVL_LOCAL_METHOD="dfs"
	elif test "$SVL_LOCAL_METHOD" != "dfs" -a "$SVL_LOCAL_METHOD" != "bfs"
	then
	    SVL_WARNING "bisimulator cannot use method $SVL_LOCAL_METHOD" "using method dfs instead"
	    SVL_LOCAL_METHOD="dfs"
	fi
	;;
    "aldebaran" )
    	if test "$SVL_LOCAL_METHOD" = "bdd"
	then
	    SVL_WARNING "method bdd is obsolete in aldebaran" "ignoring method bdd"
	    SVL_LOCAL_METHOD="default"
	fi
        if test "$SVL_LOCAL_OP" != "EQUAL"
	then
	    if test "$SVL_LOCAL_METHOD" = "default"
	    then
		SVL_LOCAL_METHOD="fly"
	    elif test "$SVL_LOCAL_METHOD" != "fly"
	    then
		SVL_WARNING "aldebaran cannot perform preorder comparison using method $SVL_LOCAL_METHOD" "using method fly instead"
		SVL_LOCAL_METHOD="fly"
	    fi
	fi
    	if test "$SVL_LOCAL_METHOD" = "default"
	then
	    if test `SVL_TYPE "$SVL_LOCAL_INPUT_1"` = "exp" -o \
	            `SVL_TYPE "$SVL_LOCAL_INPUT_2"` = "exp"
	    then
	        SVL_LOCAL_METHOD="fly"
	    else
		SVL_LOCAL_METHOD="std"
	    fi
	elif test "$SVL_LOCAL_METHOD" != "std" -a "$SVL_LOCAL_METHOD" != "fly"
	then
	    SVL_WARNING "aldebaran cannot use method $SVL_LOCAL_METHOD" "using method std instead"
	    SVL_LOCAL_METHOD="std"
	fi
    esac
    # Maintenant les parametres sont OK, on regarde les inputs

    SVL_LOCAL_TYPE_1=`SVL_TYPE "$SVL_LOCAL_INPUT_1"`
    case "$SVL_LOCAL_TYPE_1" in
    "lot" | "lnt" | "lts" )
	# si l'outil n'est pas bisimulator, on doit transformer cette input
	# au format bcg
	if test "$SVL_LOCAL_TOOL" != "bisimulator"
	then
	    if test "$SVL_LOCAL_ROOT_1" != ""
	    then
		SVL_WARNING "inserting \"generation of\" before \"$SVL_LOCAL_INPUT_1\":\"$SVL_LOCAL_ROOT_1\""
	    else
		SVL_WARNING "inserting \"generation of\" before \"$SVL_LOCAL_INPUT_1\""
	    fi
	    SVL_RECORD_FOR_SWEEP "${SVL_TMP_PREFIX}_input_1.bcg"
	    SVL_COMPILE "$SVL_LOCAL_INPUT_1" "bcg" "$SVL_LOCAL_ROOT_1" "${SVL_TMP_PREFIX}_input_1"
	    SVL_LOCAL_ROOT_1=""
	    SVL_LOCAL_INPUT_1="${SVL_TMP_PREFIX}_input_1.bcg"
	    SVL_LOCAL_TYPE_1="bcg"
	fi
	;;
    "exp" )
    	if test "$SVL_LOCAL_TOOL" != "bisimulator" -a \
		\( "$SVL_LOCAL_TOOL" != "aldebaran" -o \
		   "$SVL_LOCAL_METHOD" != "fly" \)
	then
	    SVL_WARNING "inserting \"generation of\" before \"$SVL_LOCAL_INPUT_1\""
	    SVL_RECORD_FOR_SWEEP "`SVL_PREFIX "$SVL_LOCAL_INPUT_1"`.bcg"
	    SVL_GENERATOR "$SVL_LOCAL_INPUT_1" "`SVL_PREFIX "$SVL_LOCAL_INPUT_1"`.bcg" "$SVL_LOCAL_RELATION" ""
	    SVL_LOCAL_INPUT_1="`SVL_PREFIX "$SVL_LOCAL_INPUT_1"`.bcg"
	    SVL_LOCAL_TYPE_1="bcg"
	fi
	;;
    * )
	;;
    esac

    SVL_LOCAL_TYPE_2=`SVL_TYPE "$SVL_LOCAL_INPUT_2"`
    case `SVL_TYPE "$SVL_LOCAL_INPUT_2"` in
    "lot" | "lnt" | "lts" )
	# si l'outil n'est pas bisimulator, on doit transformer cette input
	# au format bcg
	if test "$SVL_LOCAL_TOOL" != "bisimulator" -o \
	   	"$SVL_LOCAL_TYPE_1" = "lot" -o \
		"$SVL_LOCAL_TYPE_1" = "lnt" -o \
		"$SVL_LOCAL_TYPE_1" = "lts" -o \
		"$SVL_LOCAL_TYPE_1" = "exp"
	then
	    if test "$SVL_LOCAL_ROOT_2" != ""
	    then
		SVL_WARNING "inserting \"generation of\" before \"$SVL_LOCAL_INPUT_2\":\"$SVL_LOCAL_ROOT_2\""
	    else
		SVL_WARNING "inserting \"generation of\" before \"$SVL_LOCAL_INPUT_2\""
	    fi
	    SVL_RECORD_FOR_SWEEP "${SVL_TMP_PREFIX}_input_2.bcg"
	    SVL_COMPILE "$SVL_LOCAL_INPUT_2" "bcg" "$SVL_LOCAL_ROOT_2" "${SVL_TMP_PREFIX}_input_2"
	    SVL_LOCAL_ROOT_2=""
	    SVL_LOCAL_INPUT_2="${SVL_TMP_PREFIX}_input_2.bcg"
	fi
	;;
    "exp" )
    	if test \( "$SVL_LOCAL_TOOL" != "bisimulator" -a \
		   \( "$SVL_LOCAL_TOOL" != "aldebaran" -o \
		      "$SVL_LOCAL_METHOD" != "fly" \) \) -o \
		"$SVL_LOCAL_TYPE_1" = "lot" -o \
		"$SVL_LOCAL_TYPE_1" = "lnt" -o \
		"$SVL_LOCAL_TYPE_1" = "lts" -o \
		"$SVL_LOCAL_TYPE_1" = "exp"
	then
	    SVL_WARNING "inserting \"generation of\" before \"$SVL_LOCAL_INPUT_2\""
	    SVL_RECORD_FOR_SWEEP "`SVL_PREFIX "$SVL_LOCAL_INPUT_2"`.bcg"
	    SVL_GENERATOR "$SVL_LOCAL_INPUT_2" "`SVL_PREFIX "$SVL_LOCAL_INPUT_2"`.bcg" "$SVL_LOCAL_RELATION" ""
	    SVL_LOCAL_INPUT_2="`SVL_PREFIX "$SVL_LOCAL_INPUT_2"`.bcg"
	fi
	;;
    * )
	;;
    esac

    # Maintenant tout est OK pour appliquer les outils
    SVL_APPLY_COMPARISON "$SVL_LOCAL_TOOL" "$SVL_LOCAL_RELATION" "$SVL_LOCAL_PROB_RATE" "$SVL_LOCAL_METHOD" "$SVL_LOCAL_INPUT_1" "$SVL_LOCAL_ROOT_1" "$SVL_LOCAL_INPUT_2" "$SVL_LOCAL_ROOT_2" "$SVL_LOCAL_COMPARISON_OUTPUT" "$SVL_LOCAL_OP"
    if SVL_DISTINCT_FILENAMES "$SVL_LOCAL_INPUT_1" "$SVL_LOCAL_INITIAL_INPUT_1"
    then
	SVL_REMOVE "$SVL_LOCAL_INPUT_1"
    fi
    if SVL_DISTINCT_FILENAMES "$SVL_LOCAL_INPUT_2" "$SVL_LOCAL_INITIAL_INPUT_2"
    then
	SVL_REMOVE "$SVL_LOCAL_INPUT_2"
    fi
}

#-----------------------------------------------------------------------------

SVL_PREPARE_INTERFACE () {
    ####
    # $1 is the name of the interface (.bcg, .aut, .fc2, .seq)
    # $2 is the name of the hide file to apply on the interface
    # (it may be the empty string, in which case no hide is to apply)
    # $3 is the matching mode for hiding
    # $4 is the output i.e., interface hidden + reduced modulo safety
    ####
    SVL_PRINT_NEWLINE
    SVL_PRINT_MESSAGE "\"$4\" = safety reduction (* with hiding *) of \"$1\""
    if test `SVL_TYPE "$1"` != "bcg"
    then
	SVL_LOCAL_INPUT="${SVL_TMP_PREFIX}_input.bcg"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_INPUT"
	SVL_CONVERT "$1" "$SVL_LOCAL_INPUT"
    else
	SVL_LOCAL_INPUT="$1"
    fi
    if test "$2" != ""
    then
      SVL_LOCAL_PREPARE_INTERFACE_OUTPUT="`SVL_PREFIX "$2"`.bcg"
      SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_PREPARE_INTERFACE_OUTPUT"
      SVL_EXECUTE "`SVL_TIME`$BCG_LABELS_EXECUTABLE $BCG_OPTIONS ${BCG_LABELS_OPTIONS} -hide $3 \"$2\" \"${SVL_LOCAL_INPUT}\" \"${SVL_LOCAL_PREPARE_INTERFACE_OUTPUT}\""
    else
      SVL_LOCAL_PREPARE_INTERFACE_OUTPUT="$SVL_LOCAL_INPUT"
    fi
    # pre-minimization modulo branching
    SVL_EXECUTE "`SVL_TIME`$BCG_MIN_EXECUTABLE $BCG_OPTIONS $BCG_MIN_OPTIONS -branching \"$SVL_LOCAL_PREPARE_INTERFACE_OUTPUT\""
    SVL_REDUCTION "default" "safety" "" "std" "$SVL_LOCAL_PREPARE_INTERFACE_OUTPUT" "" "$4" "" >/dev/null
    SVL_INFO "$4"
    if SVL_DISTINCT_FILENAMES "$SVL_LOCAL_PREPARE_INTERFACE_OUTPUT" "$1"
    then
        SVL_REMOVE "$SVL_LOCAL_PREPARE_INTERFACE_OUTPUT"
    fi
    if test `SVL_TYPE "$1"` != "bcg"
    then
	SVL_REMOVE "$SVL_LOCAL_INPUT"
    fi
}

#-----------------------------------------------------------------------------

SVL_ABSTRACTION () { 
    ####
    # $1 is the behaviour to restrict
    # $2 is possibly a root if $1 is a lotos/lnt/lts (FSP) file
    # $3 is optionally -interfaceuser
    # $4 is the interface
    # $5 is the sync file (possibly the empty string if sync file is useless)
    # if $6 is set, all gates must be hidden; a .sync file will be generated
    # from the interface.
    # $7 is the matching mode (-gate, -total, -partial)
    # $8 is the output (any type)
    # $9 is either "userfile", or "items" according to the origin of $5
    # ${10} is a possible equivalence relation modulo which $8 can be reduced
    # (using partial order reduction)
    ####
    # all parameters are named and shift is used to access the tenth parameter,
    # because ${10} is not portable (it cannot be used under Solaris) 
    SVL_LOCAL_BEHAVIOUR="$1"
    SVL_LOCAL_BEHAVIOUR_ROOT="$2"
    SVL_LOCAL_INTERFACEUSER="$3"
    SVL_LOCAL_INTERFACE="$4"
    SVL_LOCAL_SYNC_FILE="$5"
    SVL_LOCAL_ALL_SYNCHRO="$6"
    SVL_LOCAL_MATCHING_MODE="$7"
    SVL_LOCAL_ABSTRACTION_OUTPUT_ANYTYPE="$8"
    SVL_LOCAL_SYNC_ORIGIN="$9"
    shift
    SVL_LOCAL_REDUCTION_EQUIVALENCE="$9"

    SVL_USER_OPTION=
    if test "$SVL_LOCAL_INTERFACEUSER" != ""
    then
	SVL_USER_OPTION="user "
    fi
    SVL_LOCAL_ABSTRACTION_MODE="`"$ECHO" "$SVL_LOCAL_MATCHING_MODE" | cut -d '-' -f 2`"
    if test "$SVL_LOCAL_ABSTRACTION_MODE" = "gate"
    then
	# gate is default matching option, not printed on the output
	SVL_LOCAL_ABSTRACTION_MODE=
    else
	SVL_LOCAL_ABSTRACTION_MODE="${SVL_LOCAL_ABSTRACTION_MODE} "
    fi
    SVL_LOCAL_BASENAME=`SVL_BASENAME_OPEN_CAESAR_TOOL "$PROJECTOR_EXECUTABLE"`
    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME"
    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME.o"
    SVL_RECORD_FOR_SWEEP "`SVL_PREFIX "$SVL_LOCAL_BEHAVIOUR"`.c"
    SVL_RECORD_FOR_SWEEP "`SVL_PREFIX "$SVL_LOCAL_BEHAVIOUR"`.o "
    SVL_PRINT_NEWLINE
    SVL_PRINT_MESSAGE "\"$SVL_LOCAL_ABSTRACTION_OUTPUT_ANYTYPE\" = ${SVL_LOCAL_ABSTRACTION_MODE}${SVL_USER_OPTION}abstraction \"$SVL_LOCAL_INTERFACE\""
    if test "$SVL_LOCAL_ALL_SYNCHRO" = ""
    then
      SVL_SET_HIDE_RENAME_SYNC "$SVL_LOCAL_SYNC_FILE" "$SVL_LOCAL_SYNC_ORIGIN"
      SVL_PRINT_MESSAGE "    sync ${SVL_HIDE_RENAME_SYNC}"
    else
    	# This is a "sync all" (no .sync file given); we create a sync file
	# from either the gates or the labels taken in the interface
	"$ECHO" "Sync" > "$SVL_LOCAL_SYNC_FILE"
	if test "$SVL_LOCAL_MATCHING_MODE" = "-gate"
	then
	    # we put the gates of $SVL_LOCAL_INTERFACE in $SVL_LOCAL_SYNC_FILE
	    bcg_info $BCG_OPTIONS -labels "$SVL_LOCAL_INTERFACE" | tr -d '\015' | sed -e '/^[0-9]*$/d;/^i$/d;s/^\([^ 	!(]*\).*/\1/' | sort -u >> "$SVL_LOCAL_SYNC_FILE"
	else
	    # we put the labels of $SVL_LOCAL_INTERFACE in $SVL_LOCAL_SYNC_FILE
	    bcg_info $BCG_OPTIONS -labels "$SVL_LOCAL_INTERFACE" | tr -d '\015' | sed -e '/^[0-9]*$/d;/^i$/d' >> "$SVL_LOCAL_SYNC_FILE"
	fi
    fi
    if test "$SVL_LOCAL_BEHAVIOUR_ROOT" != ""
    then
	SVL_PRINT_MESSAGE "    of \"$SVL_LOCAL_BEHAVIOUR\":\"$SVL_LOCAL_BEHAVIOUR_ROOT\""
    else
    	SVL_PRINT_MESSAGE "    of \"$SVL_LOCAL_BEHAVIOUR\""
    fi
    # now we test whether there are offers in -gate mode
    if test "$SVL_LOCAL_MATCHING_MODE" = "-gate" -a "$SVL_LOCAL_SYNC_FILE" != ""
    then
	eval SVL_CHECK_LABELS_IN_GATE_MODE "$SVL_LOCAL_SYNC_FILE"
    fi
    if test `SVL_TYPE "$SVL_LOCAL_ABSTRACTION_OUTPUT_ANYTYPE"` != "bcg"
    then
	SVL_LOCAL_BCG_OUTPUT="${SVL_TMP_PREFIX}_output.bcg"
    else
	SVL_LOCAL_BCG_OUTPUT="$SVL_LOCAL_ABSTRACTION_OUTPUT_ANYTYPE"
    fi
    if test `SVL_IS_OPEN "$SVL_LOCAL_BEHAVIOUR"`
    then
    	SVL_SET_OPEN_TOOL "$SVL_LOCAL_BEHAVIOUR"
	SVL_SET_OPEN_CC_OPTIONS "$SVL_LOCAL_BEHAVIOUR"
        # if $SVL_LOCAL_BEHAVIOUR is a .exp we might be able to apply partial
        # order reduction
	SVL_LOCAL_PARTIAL_ORDER_REDUCTION_OPTION=
	if test `SVL_TYPE "$SVL_LOCAL_BEHAVIOUR"` = "exp"
	then
	    SVL_CHECK_EXP_OPEN_OPTIONS
	    # check whether partial order reduction must be used
	    if test "`SVL_EXTRACT_EXP_OPEN_PARTIAL_ORDER_OPTION`" != ""
	    then
		# partial order reduction option is already defined by the
		# user, we do not add one
		SVL_LOCAL_PARTIAL_ORDER_REDUCTION_OPTION=
	    else
		# partial order reduction option is inferred from the context
		SVL_LOCAL_PARTIAL_ORDER_REDUCTION_OPTION=`SVL_GET_PARTIAL_ORDER_REDUCTION_OPTION "$SVL_LOCAL_REDUCTION_EQUIVALENCE"`
	    fi
	fi
    	if test "$SVL_LOCAL_BEHAVIOUR_ROOT" != ""
    	then
	    SVL_OPEN_TOOL="$SVL_OPEN_TOOL -root '$SVL_LOCAL_BEHAVIOUR_ROOT'"
    	fi
    	SVL_EXECUTE "`SVL_TIME`$SVL_OPEN_TOOL $SVL_LOCAL_PARTIAL_ORDER_REDUCTION_OPTION \"$SVL_LOCAL_BEHAVIOUR\" $SVL_OPEN_CC_OPTIONS $PROJECTOR_EXECUTABLE $PROJECTOR_OPTIONS $SVL_LOCAL_INTERFACEUSER -sync $SVL_LOCAL_MATCHING_MODE \"$SVL_LOCAL_SYNC_FILE\" \"$SVL_LOCAL_INTERFACE\" \"$SVL_LOCAL_BCG_OUTPUT\""
	SVL_REMOVE "`SVL_PREFIX "$SVL_LOCAL_BEHAVIOUR"`.h"
    else
	SVL_LOCAL_INPUT="${SVL_TMP_PREFIX}_input.bcg"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_INPUT"
	SVL_CONVERT "$SVL_LOCAL_BEHAVIOUR" "$SVL_LOCAL_INPUT"
	SVL_EXECUTE "`SVL_TIME`$BCG_OPEN_EXECUTABLE $BCG_OPTIONS $BCG_OPEN_OPTIONS \"$SVL_LOCAL_INPUT\" $BCG_OPEN_CC_OPTIONS $PROJECTOR_EXECUTABLE $PROJECTOR_OPTIONS $SVL_LOCAL_INTERFACEUSER -sync $SVL_LOCAL_MATCHING_MODE \"$SVL_LOCAL_SYNC_FILE\" \"$SVL_LOCAL_INTERFACE\" \"$SVL_LOCAL_BCG_OUTPUT\""
	SVL_REMOVE "$SVL_LOCAL_INPUT"
    fi
    # If -interfaceuser was set, it has to be set in future calls to exp.open
    if test "$SVL_LOCAL_INTERFACEUSER" != ""
    then
	SVL_USER_INTERFACE="-interfaceuser"
    fi
    SVL_CONVERT_AND_REMOVE "$SVL_LOCAL_BCG_OUTPUT" "$SVL_LOCAL_ABSTRACTION_OUTPUT_ANYTYPE"
    SVL_INFO "$SVL_LOCAL_ABSTRACTION_OUTPUT_ANYTYPE"
    SVL_CHECK_COMPILER_ERROR "$SVL_LOCAL_BEHAVIOUR"
    "$CADP"/src/com/cadp_rm projector
    SVL_REMOVE "`SVL_PREFIX "$SVL_LOCAL_BEHAVIOUR"`.c" "`SVL_PREFIX "$SVL_LOCAL_BEHAVIOUR"`.o"
}

#-----------------------------------------------------------------------------

SVL_XTL () {
    ####
    # $1 is the name of the .xtl file
    # $2 is the name of the BCG file to verify
    # $3 is additional options for xtl
    ####
    SVL_PRINT_NEWLINE
    SVL_PRINT_MESSAGE "verify \"$1\" in \"$2\""
    SVL_FAILED_FLAG=0
    SVL_EXECUTE "`SVL_TIME`$XTL_EXECUTABLE $3$XTL_OPTIONS \"$1\" \"$2\"" "SVL_FILTER_XTL" "" "verify"
    if test "$SVL_FAILED_FLAG" = 1
    then
	SVL_WARNING "an error occurred during formula evaluation with xtl" "see $SVL_LOG_FILE for a detailed diagnostic"
    fi
}

#-----------------------------------------------------------------------------

SVL_VERIFY_INLINE () {
    ####
    # $1 is the name of the property file
    # $2 is the name of LTS to verify in
    # $3 is a possible root in case $2 is a .lotos/.lnt/.lts (FSP)
    # $4 is a possible diagnostic file or the empty string
    # $5 is the method
    # $6 is the tool
    # $7 is the line increment to be passed to evaluator or xtl
    ####
    # options to be passed to evaluator3/evaluator4/evaluator5/xtl for error
    # messages concerning the inline formula
    SVL_LOCAL_ERROR_OPTIONS="-source \"`basename "$0"`.svl:$7\" "
    case "$6" in
    evaluator | evaluator3 )
	SVL_RECORD_FOR_SWEEP "$1.mcl"
	"$CADP"/src/com/cadp_rm "$1.mcl"
	if test "$DEFAULT_MCL_LIBRARIES" != ""
	then
	    "$ECHO" "library $DEFAULT_MCL_LIBRARIES end_library" >> "$1.mcl"
	fi
	if test "$DEFAULT_EVALUATOR3_LIBRARIES" != ""
	then
	    "$ECHO" "library $DEFAULT_EVALUATOR3_LIBRARIES end_library" >> "$1.mcl"
	fi
	cat "$1" >> "$1.mcl"
	SVL_REMOVE "$1"
	SVL_SHOW_FILE "$1.mcl"
	SVL_VERIFY "$1.mcl" "$2" "$3" "$4" "$5" "$6" "$SVL_LOCAL_ERROR_OPTIONS"
	SVL_REMOVE "$1.mcl"
	;;
    evaluator4 )
	SVL_RECORD_FOR_SWEEP "$1.mcl"
	SVL_RECORD_FOR_SWEEP "$1.xm"
	"$CADP"/src/com/cadp_rm "$1.mcl"
	if test "$DEFAULT_MCL_LIBRARIES" != ""
	then
	    "$ECHO" "library $DEFAULT_MCL_LIBRARIES end_library" >> "$1.mcl"
	fi
	if test "$DEFAULT_EVALUATOR4_LIBRARIES" != ""
	then
	    "$ECHO" "library $DEFAULT_EVALUATOR4_LIBRARIES end_library" >> "$1.mcl"
	fi
	cat "$1" >> "$1.mcl"
	SVL_REMOVE "$1"
	SVL_SHOW_FILE "$1.mcl"
	SVL_VERIFY "$1.mcl" "$2" "$3" "$4" "$5" "$6" "$SVL_LOCAL_ERROR_OPTIONS"
	SVL_REMOVE "$1.mcl"
	SVL_REMOVE "$1.xm"
	;;
    evaluator5 )
	SVL_RECORD_FOR_SWEEP "$1.mcl"
	SVL_RECORD_FOR_SWEEP "$1.xm"
	"$CADP"/src/com/cadp_rm "$1.mcl"
	if test "$DEFAULT_MCL_LIBRARIES" != ""
	then
	    "$ECHO" "library $DEFAULT_MCL_LIBRARIES end_library" >> "$1.mcl"
	fi
	if test "$DEFAULT_EVALUATOR5_LIBRARIES" != ""
	then
	    "$ECHO" "library $DEFAULT_EVALUATOR5_LIBRARIES end_library" >> "$1.mcl"
	fi
	cat "$1" >> "$1.mcl"
	SVL_REMOVE "$1"
	SVL_SHOW_FILE "$1.mcl"
	SVL_VERIFY "$1.mcl" "$2" "$3" "$4" "$5" "$6" "$SVL_LOCAL_ERROR_OPTIONS"
	SVL_REMOVE "$1.mcl"
	SVL_REMOVE "$1.xm"
	;;
    xtl )
	SVL_LOCAL_TYPE=`SVL_TYPE "$2"`
	# generation de BCG pour "$2"
	case "$SVL_LOCAL_TYPE" in
	"lot" | "lnt" | "lts" )
	    if test "$3" != ""
	    then
		SVL_WARNING "inserting \"generation of\" before \"$2\":\"$3\""
	    else	
		SVL_WARNING "inserting \"generation of\" before \"$2\""
	    fi
	    SVL_LOCAL_INPUT="${SVL_TMP_PREFIX}_input.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_INPUT"
	    SVL_COMPILE "$2" "bcg" "$3" "${SVL_TMP_PREFIX}_input"
	    ;;
	"exp" )
	    SVL_WARNING "inserting \"generation of\" before \"$2\""
	    SVL_LOCAL_INPUT="${SVL_TMP_PREFIX}_input.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_INPUT"
	    SVL_GENERATOR "$2" "$SVL_LOCAL_INPUT" "strong" ""
	    ;;
	"seq" | "fc2" | "aut" )
	    SVL_LOCAL_INPUT="`SVL_PREFIX "$2"`.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_INPUT"
	    SVL_CONVERT "$2" "$SVL_LOCAL_INPUT" "msg"
	    ;;
	"bcg" )
	    SVL_LOCAL_INPUT="$2"
	    ;;
	esac
	if test "$4" != ""
	then
	    SVL_WARNING "xtl cannot generate diagnostics, file \"$4\" is ignored"
	fi
	SVL_RECORD_FOR_SWEEP "$1.xtl"
	if test "$DEFAULT_XTL_LIBRARIES" != ""
	then
	    "$ECHO" "library $DEFAULT_XTL_LIBRARIES end_library" > "$1.xtl"
	    cat "$1" >> "$1.xtl"
	    SVL_REMOVE "$1"
	else
	    SVL_MOVE "$1" "$1.xtl"
	fi
	SVL_SHOW_FILE "$1.xtl"
	SVL_XTL "$1.xtl" "$SVL_LOCAL_INPUT" "$SVL_LOCAL_ERROR_OPTIONS"
	if SVL_DISTINCT_FILENAMES "$SVL_LOCAL_INPUT" "$2"
	then
	    SVL_REMOVE "$SVL_LOCAL_INPUT"
	fi
	SVL_REMOVE "$1.xtl"
	;;
    esac
}

#-----------------------------------------------------------------------------

SVL_EXEC_SHELL () {
    ####
    # $1 is the shell command to check
    ####
    SVL_PRINT_NEWLINE
    SVL_PRINT_MESSAGE "exec \"$1\""
    SVL_EXECUTE "$1" "SVL_FILTER_FINAL"
}

#-----------------------------------------------------------------------------

SVL_VERIFY () {
    ####
    # $1 is the name of the .mcl file
    # $2 is the name of LTS to verify in
    # $3 is a possible root in case $2 is a .lotos/.lnt/.lts (FSP)
    # $4 is a possible diagnostic file or the empty string
    # $5 is the method
    # $6 is the tool
    # $7 is additional options for evaluator3/evaluator4/evaluator5 (if any)
    ####
    if test "$3" != ""
    then
	SVL_LOCAL_BEHAVIOUR="\"$2\":\"$3\""
    else
	SVL_LOCAL_BEHAVIOUR="\"$2\""
    fi
    case $5 in
    bfs | dfs | acyclic)
	SVL_LOCAL_VERIFY_METHOD="-$5"
	;;
    *)
	SVL_WARNING "$6 cannot verify using method $5" "using method dfs instead"
	SVL_LOCAL_VERIFY_METHOD="-dfs"
	;;
    esac
    SVL_PRINT_NEWLINE
    if test "$4" != ""
    then
	SVL_PRINT_MESSAGE "\"$4\" = verify \"$1\" in $SVL_LOCAL_BEHAVIOUR"
        SVL_LOCAL_TMP_OUTPUT="${SVL_TMP_PREFIX}_output.bcg"
	SVL_LOCAL_EVALUATOR_OPTIONS="-diag \"$SVL_LOCAL_TMP_OUTPUT\""
	if test "$SVL_LOCAL_TMP_OUTPUT" != "$4"
	then
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_OUTPUT"
	fi
    else
	SVL_PRINT_MESSAGE "verify \"$1\" in $SVL_LOCAL_BEHAVIOUR"
	SVL_LOCAL_TMP_OUTPUT=""
	SVL_LOCAL_EVALUATOR_OPTIONS=""
    fi
    if test `SVL_IS_OPEN "$2"`
    then
	SVL_SET_OPEN_TOOL "$2"
	SVL_SET_OPEN_CC_OPTIONS "$2"
	SVL_LOCAL_TMP_INPUT="$2"
	if test "$3" != ""
	then
	    SVL_OPEN_TOOL="$SVL_OPEN_TOOL -root '$3'"
	fi
	if test `SVL_TYPE "$SVL_LOCAL_TMP_INPUT"` = "lot"
	then
	    SVL_RECORD_FOR_SWEEP "`SVL_PREFIX "$2"`.c"
	    SVL_RECORD_FOR_SWEEP "`SVL_PREFIX "$2"`.o"
	    SVL_RECORD_FOR_SWEEP "`SVL_PREFIX "$2"`.h"
	fi
    else
	SVL_OPEN_TOOL="$BCG_OPEN_EXECUTABLE $BCG_OPTIONS $BCG_OPEN_OPTIONS"
	SVL_OPEN_CC_OPTIONS="$BCG_OPEN_CC_OPTIONS"
	SVL_LOCAL_TMP_INPUT="${SVL_TMP_PREFIX}_input.bcg"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_INPUT"
	SVL_CONVERT "$2" "$SVL_LOCAL_TMP_INPUT"
    fi
    case $6 in
    evaluator )
	SVL_LOCAL_EVALUATOR_EXECUTABLE="$EVALUATOR_EXECUTABLE"
	SVL_LOCAL_EVALUATOR_OPTIONS="$SVL_LOCAL_EVALUATOR_OPTIONS $EVALUATOR_OPTIONS"
	SVL_LOCAL_FILTER=SVL_FILTER_BOOLEAN_GENERIC
	;;
    evaluator3 )
	SVL_LOCAL_EVALUATOR_EXECUTABLE="$EVALUATOR3_EXECUTABLE"
	SVL_LOCAL_EVALUATOR_OPTIONS="$SVL_LOCAL_EVALUATOR_OPTIONS $EVALUATOR_OPTIONS"
	SVL_LOCAL_FILTER=SVL_FILTER_BOOLEAN_GENERIC
	;;
    evaluator4 )
	SVL_LOCAL_EVALUATOR_EXECUTABLE="$EVALUATOR4_EXECUTABLE"
	SVL_LOCAL_EVALUATOR_OPTIONS="$SVL_LOCAL_EVALUATOR_OPTIONS $EVALUATOR4_OPTIONS"
	SVL_LOCAL_FILTER=SVL_FILTER_BOOLEAN_GENERIC
	;;
    evaluator5 )
	SVL_LOCAL_EVALUATOR_EXECUTABLE="$EVALUATOR5_EXECUTABLE"
	SVL_LOCAL_EVALUATOR_OPTIONS="$SVL_LOCAL_EVALUATOR_OPTIONS $EVALUATOR5_OPTIONS"
	SVL_LOCAL_FILTER=SVL_FILTER_EVALUATOR5
	;;
    esac
    SVL_LOCAL_BASENAME=`SVL_BASENAME_OPEN_CAESAR_TOOL "$SVL_LOCAL_EVALUATOR_EXECUTABLE"`
    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME"
    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME.o"
    SVL_FAILED_FLAG=0
    SVL_EXECUTE "`SVL_TIME`$SVL_OPEN_TOOL \"$SVL_LOCAL_TMP_INPUT\" $SVL_OPEN_CC_OPTIONS $SVL_LOCAL_EVALUATOR_EXECUTABLE $7$SVL_LOCAL_VERIFY_METHOD $SVL_LOCAL_EVALUATOR_OPTIONS \"$1\"" "$SVL_LOCAL_FILTER" "" "verify"
    if test "$SVL_FAILED_FLAG" = 1
    then
	SVL_WARNING "an error occurred during formula evaluation with $6" "see $SVL_LOG_FILE for a detailed diagnostic"
    fi
    SVL_CHECK_COMPILER_ERROR "$SVL_LOCAL_TMP_INPUT"
    if SVL_DISTINCT_FILENAMES "$SVL_LOCAL_TMP_INPUT" "$2"
    then
	SVL_REMOVE "$SVL_LOCAL_TMP_INPUT"
    fi
    if test -f "$SVL_LOCAL_TMP_OUTPUT" && \
       SVL_DISTINCT_FILENAMES "$SVL_LOCAL_TMP_OUTPUT" "$4"
    then
	SVL_CONVERT "$SVL_LOCAL_TMP_OUTPUT" "$4"
	SVL_REMOVE "$SVL_LOCAL_TMP_OUTPUT"
    fi
    "$CADP"/src/com/cadp_rm $SVL_LOCAL_BASENAME
}

#-----------------------------------------------------------------------------

SVL_CHECK_LOCK () {
    ####
    # $1 is "dead" or "live"
    # $2 is the tool used for checking deadlocks or livelocks
    # 	 possible tools are evaluator, evaluator3, evaluator4, evaluator5,
    #    exhibitor, and aldebaran
    # $3 is the name of LTS to check locks in (any type)
    # $4 is a possible root in case $3 is a .lotos/.lnt/.lts (FSP)
    # $5 is an optional diagnostic file
    ####
    if test "$DEFAULT_LOCK_TOOL" != ""
    then
	SVL_WARNING_OBSOLETE_VARIABLE "\$DEFAULT_LOCK_TOOL"  "\$DEFAULT_LIVELOCK_TOOL or \$DEFAULT_DEADLOCK_TOOL"
    fi
    SVL_LOCAL_TOOL="$2"
    SVL_LOCAL_INPUT_TYPE=`SVL_TYPE "$3"`
    if test "$SVL_LOCAL_TOOL" = "aldebaran" && test "$SVL_LOCAL_INPUT_TYPE" = "lot" -o "$SVL_LOCAL_INPUT_TYPE" = "lnt" -o "$SVL_LOCAL_INPUT_TYPE" = "lts"
    then
	if test "$1" = "live"
	then
	    SVL_LOCAL_TOOL="evaluator"
	else
	    SVL_LOCAL_TOOL="exhibitor"
	fi
	case "$SVL_LOCAL_INPUT_TYPE" in
	lnt)
	    SVL_LOCAL_LANGUAGE="an LNT"
	    ;;
	lot|lotos)
	    SVL_LOCAL_LANGUAGE="a LOTOS"
	    ;;
	lts)
	    SVL_LOCAL_LANGUAGE="an FSP"
	    ;;
	esac
	SVL_WARNING "$2 cannot perform $1lock detection on $SVL_LOCAL_LANGUAGE program" "using $SVL_LOCAL_TOOL instead"
    fi 
    if test "$SVL_LOCAL_TOOL" = "exhibitor" -a "$1" = "live"
    then
	SVL_WARNING "exhibitor cannot perform livelock detection" "using evaluator instead"
	SVL_LOCAL_TOOL="evaluator"
    fi
    SVL_PRINT_NEWLINE
    if test "$5" != ""
    then
	SVL_LOCAL_LHS="\"$5\" = "
    else
	SVL_LOCAL_LHS=
    fi
    if test "$4" != ""
    then
    	SVL_PRINT_MESSAGE "$SVL_LOCAL_LHS$1lock of \"$3\":\"$4\""
    else
	SVL_PRINT_MESSAGE "$SVL_LOCAL_LHS$1lock of \"$3\""
    fi
    case "$SVL_LOCAL_TOOL" in
    exhibitor)
	SVL_LOCAL_BASENAME=`SVL_BASENAME_OPEN_CAESAR_TOOL "$EXHIBITOR_EXECUTABLE"`
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME.o"
	if test "$5" != ""
	then
	    SVL_LOCAL_TMP_OUTPUT="`SVL_PREFIX "$5"`.seq"
	    if test "$SVL_LOCAL_TMP_OUTPUT" != "$5"
	    then
		SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_OUTPUT"
	    fi
	else
	    SVL_LOCAL_TMP_OUTPUT="${SVL_TMP_PREFIX}_output.seq"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_OUTPUT"
	fi
	2>>"$SVL_LOG_FILE" rm -f "$SVL_LOCAL_TMP_OUTPUT" ; touch "$SVL_LOCAL_TMP_OUTPUT"
	if test `SVL_IS_OPEN "$3"`
  	then
	    SVL_SET_OPEN_TOOL "$3"
	    SVL_SET_OPEN_CC_OPTIONS "$3"
	    SVL_LOCAL_TMP_INPUT="$3"
	    if test "$4" != ""
	    then
		SVL_OPEN_TOOL="$SVL_OPEN_TOOL -root '$4'"
	    fi
	    if test `SVL_TYPE "$SVL_LOCAL_TMP_INPUT"` = "lot"
	    then
	    	SVL_RECORD_FOR_SWEEP "`SVL_PREFIX "$3"`.c"
	    	SVL_RECORD_FOR_SWEEP "`SVL_PREFIX "$3"`.o"
	    	SVL_RECORD_FOR_SWEEP "`SVL_PREFIX "$3"`.h"
	    fi
	    SVL_EXECUTE "`SVL_TIME`$SVL_OPEN_TOOL \"$SVL_LOCAL_TMP_INPUT\" $SVL_OPEN_CC_OPTIONS $EXHIBITOR_EXECUTABLE $EXHIBITOR_OPTIONS < "$CADP"/src/eucalyptus/deadlock.seq" "SVL_FILTER_EXHIBITOR $SVL_LOCAL_TMP_OUTPUT" "SVL_FILTER_EXHIBITOR_LOG"
	    SVL_CHECK_COMPILER_ERROR "$SVL_LOCAL_TMP_INPUT"
	    SVL_REMOVE "`SVL_PREFIX "$3"`.c" "`SVL_PREFIX "$3"`.o" "`SVL_PREFIX "$3"`.h"
	else
	    SVL_LOCAL_TMP_INPUT="${SVL_TMP_PREFIX}_input.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_INPUT"
	    SVL_CONVERT "$3" "$SVL_LOCAL_TMP_INPUT"
	    SVL_EXECUTE "`SVL_TIME`$BCG_OPEN_EXECUTABLE $BCG_OPTIONS $BCG_OPEN_OPTIONS \"$SVL_LOCAL_TMP_INPUT\" $BCG_OPEN_CC_OPTIONS $EXHIBITOR_EXECUTABLE $EXHIBITOR_OPTIONS < "$CADP"/src/eucalyptus/deadlock.seq" "SVL_FILTER_EXHIBITOR $SVL_LOCAL_TMP_OUTPUT" "SVL_FILTER_EXHIBITOR_LOG"
	fi
	"$CADP"/src/com/cadp_rm exhibitor ;;
    evaluator* )
	case "$SVL_LOCAL_TOOL" in
	evaluator )
	    SVL_LOCAL_EVALUATOR_EXECUTABLE="$EVALUATOR_EXECUTABLE"
	    SVL_LOCAL_EVALUATOR_OPTIONS="$EVALUATOR_OPTIONS"
	    ;;
	evaluator3 )
	    SVL_LOCAL_EVALUATOR_EXECUTABLE="$EVALUATOR3_EXECUTABLE"
	    SVL_LOCAL_EVALUATOR_OPTIONS="$EVALUATOR_OPTIONS"
	    ;;
	evaluator4 )
	    SVL_LOCAL_EVALUATOR_EXECUTABLE="$EVALUATOR4_EXECUTABLE"
	    SVL_LOCAL_EVALUATOR_OPTIONS="$EVALUATOR4_OPTIONS"
	    ;;
	evaluator5 )
	    SVL_LOCAL_EVALUATOR_EXECUTABLE="$EVALUATOR5_EXECUTABLE"
	    SVL_LOCAL_EVALUATOR_OPTIONS="$EVALUATOR5_OPTIONS"
	    ;;
	esac
	SVL_LOCAL_BASENAME=`SVL_BASENAME_OPEN_CAESAR_TOOL "$SVL_LOCAL_EVALUATOR_EXECUTABLE"`
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME"
	SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME.o"
	if test "$5" != ""
	then
	    SVL_LOCAL_TMP_OUTPUT="`SVL_PREFIX "$5"`.bcg"
	    SVL_LOCAL_DIAG_OPTION=" -diag \"$SVL_LOCAL_TMP_OUTPUT\""
	    if SVL_DISTINCT_FILENAMES "$SVL_LOCAL_TMP_OUTPUT" "$5"
	    then
		SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_OUTPUT"
	    fi
	else
	    SVL_LOCAL_TMP_OUTPUT=
	    SVL_LOCAL_DIAG_OPTION=
	fi
	SVL_LOCAL_TMP_INPUT="$3"
	if test `SVL_IS_OPEN "$3"`
	then
	    SVL_SET_OPEN_TOOL "$3"
	    SVL_SET_OPEN_CC_OPTIONS "$3"
	    SVL_LOCAL_TMP_INPUT="$3"
	    if test "$4" != ""
	    then
		SVL_OPEN_TOOL="$SVL_OPEN_TOOL -root '$4'"
	    fi
	    if test `SVL_TYPE "$SVL_LOCAL_TMP_INPUT"` = "lot"
	    then
	    	SVL_RECORD_FOR_SWEEP "`SVL_PREFIX "$3"`.c"
	    	SVL_RECORD_FOR_SWEEP "`SVL_PREFIX "$3"`.o"
	    	SVL_RECORD_FOR_SWEEP "`SVL_PREFIX "$3"`.h"
	    fi
	    SVL_EXECUTE "`SVL_TIME`$SVL_OPEN_TOOL \"$SVL_LOCAL_TMP_INPUT\" $SVL_OPEN_CC_OPTIONS $SVL_LOCAL_EVALUATOR_EXECUTABLE $SVL_LOCAL_EVALUATOR_OPTIONS$SVL_LOCAL_DIAG_OPTION "$CADP"/src/xtl/$1lock.mcl" "SVL_FILTER_BOOLEAN_GENERIC"
	    SVL_CHECK_COMPILER_ERROR "$SVL_LOCAL_TMP_INPUT"
	    SVL_REMOVE "`SVL_PREFIX "$3"`.c" "`SVL_PREFIX "$3"`.o" "`SVL_PREFIX "$3"`.h"
	else
	    SVL_LOCAL_TMP_INPUT="${SVL_TMP_PREFIX}_input.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_INPUT"
	    SVL_CONVERT "$3" "$SVL_LOCAL_TMP_INPUT"
	    SVL_EXECUTE "`SVL_TIME`$BCG_OPEN_EXECUTABLE $BCG_OPTIONS $BCG_OPEN_OPTIONS \"$SVL_LOCAL_TMP_INPUT\" $BCG_OPEN_CC_OPTIONS $SVL_LOCAL_EVALUATOR_EXECUTABLE $SVL_LOCAL_EVALUATOR_OPTIONS$SVL_LOCAL_DIAG_OPTION "$CADP"/src/xtl/$1lock.mcl" "SVL_FILTER_BOOLEAN_GENERIC"
	fi
	"$CADP"/src/com/cadp_rm $SVL_LOCAL_BASENAME
	;;
    aldebaran)
	if test "$5" != ""
	then
	    SVL_LOCAL_TMP_OUTPUT="`SVL_PREFIX "$5"`.bcg"
	    if SVL_DISTINCT_FILENAMES "$SVL_LOCAL_TMP_OUTPUT" "$5"
	    then
		SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_OUTPUT"
	    fi
	else
	    SVL_LOCAL_TMP_OUTPUT=
	fi
	case `SVL_TYPE "$3"` in
	exp | bcg | aut)
	    SVL_LOCAL_TMP_INPUT="$3"
	    ;;
	*)
	    SVL_LOCAL_TMP_INPUT="${SVL_TMP_PREFIX}_input.bcg"
	    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_TMP_INPUT"
	    SVL_CONVERT "$3" "$SVL_LOCAL_TMP_INPUT"
	    ;;
	esac
	SVL_EXECUTE "`SVL_TIME`$ALDEBARAN_EXECUTABLE -$1 $ALDEBARAN_OPTIONS \"$SVL_LOCAL_TMP_INPUT\"" "SVL_FILTER_ALDEBARAN"
	# if a diagnostic was generated by aldebaran, then move this 
	# diagnostic into the expected output, if any
	if test -f "aldebaran.bcg"
	then
	    if test "$SVL_LOCAL_TMP_OUTPUT" != ""
	    then
		SVL_MOVE "aldebaran.bcg" "$SVL_LOCAL_TMP_OUTPUT"
	    else
		SVL_REMOVE "aldebaran.bcg"
	    fi
	fi
	;;
    fc2tools)
	SVL_ERROR "fc2tools are no longer supported"
	;;
    esac
    if SVL_DISTINCT_FILENAMES "$SVL_LOCAL_TMP_INPUT" "$3"
    then
	SVL_REMOVE "$SVL_LOCAL_TMP_INPUT"
    fi
    if test "$5" != "" -a -f "$SVL_LOCAL_TMP_OUTPUT" && \
       SVL_DISTINCT_FILENAMES "$SVL_LOCAL_TMP_OUTPUT" "$5"
    then
	SVL_CONVERT "$SVL_LOCAL_TMP_OUTPUT" "$5"
	SVL_REMOVE "$SVL_LOCAL_TMP_OUTPUT"
    fi
}

#-----------------------------------------------------------------------------

SVL_CHECK_FAIL () {
    ####
    # $1 is the name of a file in .aut, .bcg, .seq, or .fc2
    # issue a warning if the file contains some label with the substring
    # fail:
    ####
    case `SVL_TYPE "$1"` in
    bcg)
	SVL_FAIL_LABELS=`bcg_info $BCG_OPTIONS -labels "$1" | SVL_GREP "fail: " | sed -e 's/fail: \(.*\)/             \1/' | sort -u`;;
    *) 
	SVL_FAIL_LABELS=`SVL_GREP "fail: " "$1" | sed -e 's/.*"fail: \(.*\)".*/             \1/' | sort -u`;;
    esac
    if test "$SVL_FAIL_LABELS" != ""
    then
	SVL_WARNING "a user abstraction did cut some transitions on the following" "actions (among others):"
	"$ECHO" "$SVL_FAIL_LABELS" | tee -a "$SVL_LOG_FILE" 
	SVL_WARNING "$1 should be placed in an environment disallowing these" "transitions or some user interface should be re-designed"
    fi

}

#-----------------------------------------------------------------------------

SVL_STOP () {
    ####
    # $1 is the name of the generated graph (.bcg)
    ####
    SVL_PRINT_NEWLINE
    SVL_PRINT_MESSAGE "\"$1\" = stop"
    SVL_RECORD_FOR_SWEEP "$SVL_TMP_PREFIX.aut"
    SVL_EXECUTE "\"$ECHO\" \"des(0, 0, 1)\" > \"$SVL_TMP_PREFIX.aut\""
    SVL_EXECUTE "`SVL_TIME`$BCG_IO_EXECUTABLE $BCG_OPTIONS ${BCG_IO_OPTIONS_INPUT} \"$SVL_TMP_PREFIX.aut\" $BCG_OPTIONS ${BCG_IO_OPTIONS_OUTPUT} \"$1\""
    SVL_INFO "$1"
}

#-----------------------------------------------------------------------------

SVL_GRAPH () {
    ####
    # $1 is the graph generation option (chaos, bag n, fifo n)
    # $2 is the label definition file, if any
    # $3 is the number of labels, if not taken from a file
    # $4 is the first pattern, if any
    # $5 is the second pattern, if any
    # $6 is the name of the generated graph (.bcg)
    # if $7 is set then label definition file was generated
    ####
    SVL_LOCAL_MESSAGE="$1"
    SVL_LOCAL_BCG_GRAPH_OPTIONS="-$1"
    if test "$2" != ""
    then
	SVL_LOCAL_BCG_GRAPH_OPTIONS="$SVL_LOCAL_BCG_GRAPH_OPTIONS \"$2\""
	if test "$7" != ""
	then
	    SVL_LOCAL_MESSAGE="$SVL_LOCAL_MESSAGE with `cat "$2" | tr -d '\015' | sed -e 's/$/\"/;s/^/\"/;s/^/, /;1s/, //' | tr -d '\012'`"
	else
	    SVL_LOCAL_MESSAGE="$SVL_LOCAL_MESSAGE using \"$2\""
	fi
    else
	SVL_LOCAL_BCG_GRAPH_OPTIONS="$SVL_LOCAL_BCG_GRAPH_OPTIONS -labels $3 \"$4\""
	SVL_LOCAL_MESSAGE="$SVL_LOCAL_MESSAGE with $3 labels \"$4\""
	if test "$5" != ""
	then
	    SVL_LOCAL_BCG_GRAPH_OPTIONS="$SVL_LOCAL_BCG_GRAPH_OPTIONS \"$5\""
	    SVL_LOCAL_MESSAGE="$SVL_LOCAL_MESSAGE, \"$5\""
	fi
    fi
    SVL_PRINT_NEWLINE
    SVL_PRINT_MESSAGE "\"$6\" = $SVL_LOCAL_MESSAGE"
    SVL_RECORD_FOR_SWEEP "$SVL_TMP_PREFIX"
    SVL_EXECUTE "`SVL_TIME`$BCG_GRAPH_EXECUTABLE $BCG_OPTIONS $SVL_LOCAL_BCG_GRAPH_OPTIONS $BCG_GRAPH_OPTIONS -verbose \"$6\" > \"$SVL_TMP_PREFIX\""
    cat "$SVL_TMP_PREFIX" >> "$SVL_LOG_FILE"
    SVL_LOCAL_INFO=`cat "$SVL_TMP_PREFIX" | SVL_GREP state | SVL_GREP transition`
    SVL_REMOVE "$SVL_TMP_PREFIX"
    SVL_DISPLAY_INFO "$SVL_LOCAL_INFO" "$6"
}

#-----------------------------------------------------------------------------

SVL_GET_LTS_INDEX () {
    ###
    # $1 is the identifier of an LTS used in refined abstraction
    ###
    SVL_LOCAL_RESULT=1
    while read SVL_LOCAL_LINE
    do
	SVL_LOCAL_TMP=`"$ECHO" "$SVL_LOCAL_LINE" | SVL_GREP " (\* LEAF .* \*)"`
	if test "$SVL_LOCAL_TMP" != ""
	then
	    SVL_LOCAL_TMP=`"$ECHO" "$SVL_LOCAL_LINE" | SVL_GREP " (\* LEAF $1 \*)"`
	    if test "$SVL_LOCAL_TMP" != ""
	    then
		"$ECHO" $SVL_LOCAL_RESULT
		break
	    else
		SVL_LOCAL_RESULT=`SVL_EXPR $SVL_LOCAL_RESULT + 1`
	    fi
	fi
    done
}

#-----------------------------------------------------------------------------

SVL_EXP_CHAOS () {
    ####
    # $1 is the input .exp file
    # $2 the name of a .bcg file, which will contain a chaos LTS containing
    # the labels potentially occurring in the LTS of $1
    ####
    SVL_PRINT_MESSAGE
    SVL_PRINT_MESSAGE "\"$2\" = chaos with (* labels potentially occurring in \"$1\" *)"
    SVL_LOCAL_LABELS_FILE="`SVL_PREFIX "$2"`"
    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_LABELS_FILE"
    SVL_CHECK_EXP_OPEN_OPTIONS
    SVL_EXECUTE "`SVL_TIME`$EXP_OPEN_EXECUTABLE $SVL_USER_INTERFACE $EXP_OPEN_OPTIONS -labels \"$1\" | SVL_GREP -v \"exp2c: WARNING\" | \"$CADP\"/src/com/cadp_tail -n +2 > \"$SVL_LOCAL_LABELS_FILE\""
    SVL_EXECUTE "`SVL_TIME`$BCG_GRAPH_EXECUTABLE $BCG_OPTIONS $BCG_GRAPH_OPTIONS -chaos \"$SVL_LOCAL_LABELS_FILE\" \"$2\""
    SVL_REMOVE "$SVL_LOCAL_LABELS_FILE"
    SVL_INFO "$2"
    SVL_CHECK_COMPILER_ERROR "$1"
}

#-----------------------------------------------------------------------------

SVL_SUBSTITUTE_EXPRESSION () {
    ####
    # $1 the input .exp file
    # $2 the number of the expression to replace
    # $3 the name of file replacing the expression
    # $4 the output .exp file
    ####
    rm -f "$4"
    SVL_LOCAL_COUNT=1
    SVL_LOCAL_MAX=`cat "$1" | wc -l` 
    SVL_LOCAL_ACTION=COPY
    while test "$SVL_LOCAL_COUNT" -le "$SVL_LOCAL_MAX"
    do
	SVL_LOCAL_LINE=`"$CADP"/src/com/cadp_tail -n +$SVL_LOCAL_COUNT "$1" | head -n 1`
	if test "(* BEGIN NODE $2 *)" = "$SVL_LOCAL_LINE"
	# ne pas ecrire le test ci-dessus sous la forme
	#    test "$SVL_LOCAL_LINE" = "(* BEGIN NODE $2 *)"
	# car il echouerait si "$SVL_LOCAL_LINE" vaut "("
	then
	    SVL_LOCAL_ACTION=REPLACE
	elif test "(* END NODE $2 *)" = "$SVL_LOCAL_LINE"
	# ne pas ecrire le test ci-dessus sous la forme
	#    test "$SVL_LOCAL_LINE" = "(* END NODE $2 *)"
	# car il echouerait si "$SVL_LOCAL_LINE" vaut "("
	then
	    SVL_LOCAL_ACTION=COPY
	else
	    case $SVL_LOCAL_ACTION in
	    SKIP)
		;;
	    COPY)
		"$ECHO" "$SVL_LOCAL_LINE" >> "$4"
		;;
	    REPLACE)
		INDENT="`"$ECHO" "$SVL_LOCAL_LINE" | tr -d '\015' | sed -e 's/^\([ ]*\)[^ ].*$/\1/'`"
		"$ECHO" "$INDENT\"$3\" (* LEAF _ *)" >> "$4"
		SVL_LOCAL_ACTION=SKIP
		;;
	    esac
	fi
	SVL_LOCAL_COUNT=`SVL_EXPR $SVL_LOCAL_COUNT + 1`
    done
}

#-----------------------------------------------------------------------------

SVL_REFINED_ABSTRACTION () {
    ####
    # $1 is the name of the context .exp file
    # $2 is the behaviour to restrict
    # $3 is its root, if any
    # $4 is the optional -interfaceuser option
    # $5 is the occurrence in $1 of the LTS for which an interface must be
    # computed
    # $6 is the prefix of the BCG interface and sync file
    # $7 is the name of the resulting LTS
    # $8 is the list of labels identifying the graphs to consider in the 
    # interface, separated by commas
    # $9 is a possible equivalence relation modulo which $7 can be reduced
    # (using partial order reduction)
    ####
    SVL_LOCAL_EXP_FILE="$1"
    SVL_LOCAL_BEHAVIOUR_TO_RESTRICT="$2"
    SVL_LOCAL_BEHAVIOUR_ROOT="$3"
    SVL_LOCAL_INTERFACEUSER_OPTION="$4"
    SVL_LOCAL_ABSTRACT_LTS_INDEX="$5"
    SVL_LOCAL_INTERFACE_PREFIX="$6"
    SVL_LOCAL_RESULTING_LTS="$7"
    SVL_LOCAL_NEIGHBOUR_IDENTIFIERS="`"$ECHO" "$8" | sed -e 's/\"//g'`"
    SVL_LOCAL_INTERFACE_LTS_INDEX=
    while test "$SVL_LOCAL_NEIGHBOUR_IDENTIFIERS" != ""
    do
        SVL_LOCAL_LABEL="`"$ECHO" "$SVL_LOCAL_NEIGHBOUR_IDENTIFIERS" | sed -e 's/\([^,]*\).*/\1/'`"
	SVL_LOCAL_NEIGHBOUR_IDENTIFIERS="`"$ECHO" "$SVL_LOCAL_NEIGHBOUR_IDENTIFIERS" | sed -e 's/[^,]*//;s/^, //'`"
	SVL_LOCAL_NUMBER_MATCHES=`cat "$SVL_LOCAL_EXP_FILE" | SVL_GREP "(\* LEAF $SVL_LOCAL_LABEL \*)" | wc -l`
	if test "$SVL_LOCAL_NUMBER_MATCHES" -eq 0
	then
	    SVL_ERROR "in refined abstraction, label $SVL_LOCAL_LABEL" "does not match any graph of \"$SVL_LOCAL_EXP_FILE\""
	elif test "$SVL_LOCAL_NUMBER_MATCHES" -gt 1
	then
	    SVL_ERROR "in refined abstraction, label $SVL_LOCAL_LABEL" "matches more than one graph of \"$SVL_LOCAL_EXP_FILE\""
	fi
	SVL_LOCAL_ARG_NUMBER=`cat "$SVL_LOCAL_EXP_FILE" | SVL_GET_LTS_INDEX "$SVL_LOCAL_LABEL"`
	SVL_LOCAL_FILE_NAME="`cat \"$SVL_LOCAL_EXP_FILE\" | SVL_GREP \"(\* LEAF $SVL_LOCAL_LABEL \*)\" | tr -d '\015' | sed -e 's/.*\"\(.*\)\".*$/\1/'`"
	SVL_REDUCTION "default" "safety" "" std "$SVL_LOCAL_FILE_NAME" "" "$SVL_LOCAL_FILE_NAME" ""
	SVL_LOCAL_INTERFACE_LTS_INDEX="$SVL_LOCAL_INTERFACE_LTS_INDEX $SVL_LOCAL_ARG_NUMBER"
    done
    SVL_LOCAL_INTERFACE_COMMAND="$SVL_LOCAL_ABSTRACT_LTS_INDEX:$SVL_LOCAL_INTERFACE_LTS_INDEX"
    # interface computation
    SVL_PRINT_MESSAGE
    SVL_PRINT_MESSAGE "\"$SVL_LOCAL_INTERFACE_PREFIX.bcg\" (* and \"$SVL_LOCAL_INTERFACE_PREFIX.sync\" *) ="
    SVL_PRINT_MESSAGE "    generation of (* interface using $8 in *) \"$SVL_LOCAL_EXP_FILE\""
    SVL_LOCAL_BASENAME=`SVL_BASENAME_OPEN_CAESAR_TOOL "$GENERATOR_EXECUTABLE"`
    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME"
    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_BASENAME.o"
    SVL_CHECK_EXP_OPEN_OPTIONS
    # check whether partial order reduction must be used
    if test "`SVL_EXTRACT_EXP_OPEN_PARTIAL_ORDER_OPTION`" != ""
    then
	# partial order reduction option is already defined by the user,
	# we do not add one
	SVL_LOCAL_PARTIAL_ORDER_REDUCTION_OPTION=
    else
	# partial order reduction option is inferred from the context
	SVL_LOCAL_PARTIAL_ORDER_REDUCTION_OPTION=-branching
    fi
    SVL_EXECUTE "`SVL_TIME`$EXP_OPEN_EXECUTABLE $SVL_USER_INTERFACE $EXP_OPEN_OPTIONS $SVL_LOCAL_PARTIAL_ORDER_REDUCTION_OPTION -interface \"$SVL_LOCAL_INTERFACE_COMMAND\" \"$SVL_LOCAL_EXP_FILE\" $EXP_OPEN_CC_OPTIONS $GENERATOR_EXECUTABLE $GENERATOR_OPTIONS \"$SVL_LOCAL_INTERFACE_PREFIX.bcg\""
    SVL_REMOVE "generator"
    SVL_INFO "$SVL_LOCAL_INTERFACE_PREFIX.bcg"
    SVL_CHECK_COMPILER_ERROR "$SVL_LOCAL_EXP_FILE"
    mv -f "`SVL_PREFIX "$SVL_LOCAL_EXP_FILE"`.sync" "$SVL_LOCAL_INTERFACE_PREFIX.sync"
    SVL_RECORD_FOR_SWEEP "$SVL_LOCAL_INTERFACE_PREFIX.hid"
    SVL_SYNC_TO_HIDE "$SVL_LOCAL_INTERFACE_PREFIX.sync" "$SVL_LOCAL_INTERFACE_PREFIX.hid"
    SVL_PREPARE_INTERFACE "$SVL_LOCAL_INTERFACE_PREFIX.bcg" "$SVL_LOCAL_INTERFACE_PREFIX.hid" "-total" "$SVL_LOCAL_INTERFACE_PREFIX.bcg"
    # call to projector
    SVL_ABSTRACTION "$SVL_LOCAL_BEHAVIOUR_TO_RESTRICT" "$SVL_LOCAL_BEHAVIOUR_ROOT" "$SVL_LOCAL_INTERFACEUSER_OPTION" "$SVL_LOCAL_INTERFACE_PREFIX.bcg" "$SVL_LOCAL_INTERFACE_PREFIX.sync" "" "-total" "$SVL_LOCAL_RESULTING_LTS" "userfile" "$9"
}

#-----------------------------------------------------------------------------

SVL_PROPERTY_BEGIN () {
    ####
    # $1 is NONE if the property has no expected value, SOME if the property
    # has an expected value, or ANY otherwise
    # $2 is the property name
    ####
    SVL_LOCAL_PREVIOUS_EXPECT_VALUE=$SVL_PROPERTY_EXPECT_VALUE
    case $1 in
    NONE )
	if [ "$SVL_PROPERTY_EXPECT_VALUE" = SOME ]
	then
	    SVL_ERROR "property $2 has no expected value but is checked" \
		      "inside a property that expects values"
	fi
	SVL_PROPERTY_EXPECT_VALUE=NONE
	;;
    SOME )
	if [ "$SVL_PROPERTY_EXPECT_VALUE" = NONE ]
	then
	    SVL_ERROR "property $2 has an expected value but is checked" \
		      "inside a property that expects no values"
	fi
	SVL_PROPERTY_EXPECT_VALUE=SOME
	;;
    ANY )
	# do nothing
	;;
    esac
    if [ "$PROPERTY_DISPLAY_MODE" = 0 ]
    then
	if [ "$SVL_PROPERTY_CURRENT_DEPTH" = 0 ]
	then
	    SVL_SILENT_SAVE=$SVL_SILENT
	    SVL_SILENT=1
	fi
    else
	SVL_INDENTING="$SVL_INDENTING$SVL_PROPERTY_UNIT_INDENTING"
    fi
    if [ "$SVL_PROPERTY_EXPECT_VALUE" = "SOME" -a \
	 "$SVL_LOCAL_PREVIOUS_EXPECT_VALUE" = "ANY" ]
    then
	# the property has an expected value, so we define a file to store
	# verification outputs and a variable to compute the final status
	SVL_DISPLAY_FILE="${SVL_TMP_PREFIX}_display.txt"
	SVL_RECORD_FOR_SWEEP "$SVL_DISPLAY_FILE"
	SVL_PROPERTY_NUM_CHECK=0
	SVL_PROPERTY_NUM_PASS=0
    fi
    SVL_PROPERTY_CURRENT_DEPTH=`SVL_EXPR $SVL_PROPERTY_CURRENT_DEPTH + 1`
}

#-----------------------------------------------------------------------------

SVL_PROPERTY_END () {
    SVL_PROPERTY_CURRENT_DEPTH=`SVL_EXPR $SVL_PROPERTY_CURRENT_DEPTH - 1`
    if [ "$PROPERTY_DISPLAY_MODE" = 0 ]
    then
	if [ "$SVL_PROPERTY_CURRENT_DEPTH" = 0 ]
	then
	    SVL_SILENT=$SVL_SILENT_SAVE
	fi
    else
	SVL_INDENTING=`"$ECHO" "$SVL_INDENTING" |
		sed -e "s/$SVL_PROPERTY_UNIT_INDENTING//"`
    fi
    if [ "$SVL_PROPERTY_CURRENT_DEPTH" = 0 ]
    then
	if [ "$SVL_PROPERTY_EXPECT_VALUE" = "SOME" ]
	then
	    SVL_REMOVE "$SVL_DISPLAY_FILE"
	    SVL_DISPLAY_FILE=
	    SVL_PRINT_NEWLINE
	    if [ "$SVL_PROPERTY_NUM_CHECK" -gt 1 ]
	    then
		SVL_LOCAL_RATIO=" ($SVL_PROPERTY_NUM_PASS/$SVL_PROPERTY_NUM_CHECK)"
	    else
		SVL_LOCAL_RATIO=
	    fi
	    if [ "$SVL_PROPERTY_NUM_CHECK" -eq "$SVL_PROPERTY_NUM_PASS" ]
	    then
		SVL_PRINT_MESSAGE "PASS$SVL_LOCAL_RATIO"
	    else
		SVL_PRINT_MESSAGE "FAIL$SVL_LOCAL_RATIO"
	    fi
	fi
	SVL_PROPERTY_EXPECT_VALUE=ANY
    fi
}

#-----------------------------------------------------------------------------

SVL_CHECK_EXPECTED_VALUE () {
    ####
    # $1 is the expected value
    ####
    SVL_PROPERTY_NUM_CHECK=`SVL_EXPR $SVL_PROPERTY_NUM_CHECK + 1`
    SVL_LOCAL_TMP=`cat "$SVL_DISPLAY_FILE" |
			tr -d '\015' |
			sed -e '/^[ ]*$/d' |
			$CADP/src/com/cadp_tail -n 1 |
			SVL_EGREP "$1"`
    if test "$SVL_LOCAL_TMP" != ""
    then
	# expected value found in $SVL_DISPLAY_FILE
	SVL_PROPERTY_NUM_PASS=`SVL_EXPR $SVL_PROPERTY_NUM_PASS + 1`
    fi
    SVL_REMOVE "$SVL_DISPLAY_FILE"
}

#-----------------------------------------------------------------------------

SVL_QUOTE_PROPERTY_ARG () {
    ####
    # $1 is an argument of a property
    ####
    SVL_LOCAL_TMP=`"$ECHO" "$1" | sed -e 's/[A-Za-z0-9_]//g'`
    if test "$SVL_LOCAL_TMP" = ""
    then
	"$ECHO" "$1"
    else
	"$ECHO" "\"$1\""
    fi
}

#-----------------------------------------------------------------------------

SVL_PROPERTY_COMMENT_OPEN () {
    if test "$PROPERTY_COMMENT_PRINT" = 1 -a "$PROPERTY_COMMENT_OPEN" != ""
    then
	SVL_PRINT_MESSAGE "$PROPERTY_COMMENT_OPEN"
    fi
}

#-----------------------------------------------------------------------------

SVL_PROPERTY_COMMENT_MIDDLE () {
    ####
    # $1 is a line of a property commet
    ####
    if test "$PROPERTY_COMMENT_PRINT" = 1
    then
	SVL_PRINT_MESSAGE "$PROPERTY_COMMENT_MIDDLE$1"
    fi
}

#-----------------------------------------------------------------------------

SVL_PROPERTY_COMMENT_CLOSE () {
    if test "$PROPERTY_COMMENT_PRINT" = 1 -a "$PROPERTY_COMMENT_CLOSE" != ""
    then
	SVL_PRINT_MESSAGE "$PROPERTY_COMMENT_CLOSE"
    fi
}

#-----------------------------------------------------------------------------

SVL_SET_PROPERTY_COMMENT_STYLE () {
    ####
    # $1 is the property comment style
    ####
    case "$1" in
    silent )
	PROPERTY_COMMENT_PRINT=0
	;;
    none )
	PROPERTY_COMMENT_PRINT=1
	PROPERTY_COMMENT_OPEN=
	PROPERTY_COMMENT_MIDDLE=
	PROPERTY_COMMENT_CLOSE=
	;;
    standard )
	PROPERTY_COMMENT_PRINT=1
	PROPERTY_COMMENT_OPEN=
	PROPERTY_COMMENT_MIDDLE=" | "
	PROPERTY_COMMENT_CLOSE=
	;;
    indent )
	PROPERTY_COMMENT_PRINT=1
	PROPERTY_COMMENT_OPEN=
	PROPERTY_COMMENT_MIDDLE="   "
	PROPERTY_COMMENT_CLOSE=
	;;
    ada )
	PROPERTY_COMMENT_PRINT=1
	PROPERTY_COMMENT_OPEN=
	PROPERTY_COMMENT_MIDDLE="-- "
	PROPERTY_COMMENT_CLOSE=
	;;
    c )
	PROPERTY_COMMENT_PRINT=1
	PROPERTY_COMMENT_OPEN="/*"
	PROPERTY_COMMENT_MIDDLE=" * "
	PROPERTY_COMMENT_CLOSE=" */"
	;;
    pascal )
	PROPERTY_COMMENT_PRINT=1
	PROPERTY_COMMENT_OPEN="(*"
	PROPERTY_COMMENT_MIDDLE=" * "
	PROPERTY_COMMENT_CLOSE=" *)"
	;;
    sh )
	PROPERTY_COMMENT_PRINT=1
	PROPERTY_COMMENT_OPEN=
	PROPERTY_COMMENT_MIDDLE=" # "
	PROPERTY_COMMENT_CLOSE=
	;;
    * )
	SVL_WARNING "ignoring unknown comment style $1"
	;;
    esac
}

#-----------------------------------------------------------------------------


#######
# END #
#######
