(******************************************************************************
 *                              E V A L U A T O R
 *-----------------------------------------------------------------------------
 *   INRIA - Unite de Recherche Rhone-Alpes
 *   655, avenue de l'Europe
 *   38330 Montbonnot Saint Martin
 *   FRANCE
 *-----------------------------------------------------------------------------
 *   Module             :       actl_pattern.mcl
 *   Auteurs            :       Radu MATEESCU et Mihaela SIGHIREANU
 *   Version            :       1.4
 *   Date               :       2001/07/05 11:00:29
 *****************************************************************************)

(*
 * Definition of property patterns in ACTL (Action Computation Tree Logic).
 * The patterns have been proposed by Matthew Dwyer and al. in the paper
 *   [Dwyer-Avrunin-Corbett-99] M.B. Dwyer, G.S. Avrunin, and J.C. Corbett.
 *     Patterns in Property Specifications for Finite-State Verification.
 *     In Proceedings of the 21st International Conference on Software
 *     Engineering ICSE'99 (Los Angeles, CA, USA), 1999.
 * For further information on the pattern system, see the Specification
 * Patterns Home Page (http://www.cis.ksu.edu/santos/spec-patterns).
 *
 * Note: the patterns specified below are intended to be appropriate for
 * action-based description languages (such as process algebras) rather
 * than state-based languages. Therefore, they are expressed in terms of
 * action predicates (P, Q, R, ...) rather than state predicates.
 *)

(* Library of ACTL operators *)

library actl.mcl end_library

(*===========================================================================*)
(*
 * Absence (P is false)
 *)

(*---------------------------------------------------------------------------*)
(* Globally *)

macro Absence_Globally (P) =
    AG_A (true, [ P ] false)
end_macro

(*---------------------------------------------------------------------------*)
(* Before R *)

macro Absence_Before (P, R) =
    AG_A (not (R), [ P ] AG_A (not (R), [ R ] false))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q *)

macro Absence_After (P, Q) =
    AG_A (not (Q), [ Q ] AG_A (true, [ P ] false))
end_macro

(*---------------------------------------------------------------------------*)
(* Between Q and R *)

macro Absence_Between (P, Q, R) =
    AG_A (true, [ Q ] AG_A (not (R), [ P ] AG_A (not (R), [ R ] false)))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q until R *)

macro Absence_After_Until (P, Q, R) =
    AG_A (true, [ Q ] AG_A (not (R), [ P ] false))
end_macro

(*===========================================================================*)
(*
 * Existence (P occurs)
 *)

(*---------------------------------------------------------------------------*)
(* Globally *)

macro Existence_Globally (P) =
    AU_A_A (true, true, (P), true)
end_macro

(*---------------------------------------------------------------------------*)
(* Before R *)

macro Existence_Before (P, R) =
    AG_A (not (P), [ R ] false)
end_macro

(*---------------------------------------------------------------------------*)
(* After Q *)

macro Existence_After (P, Q) =
    AG_A (not (Q), [ Q ] AU_A_A (true, true, (P), true))
end_macro

(*---------------------------------------------------------------------------*)
(* Between Q and R *)

macro Existence_Between (P, Q, R) =
    AG_A (true, [ Q ] AG_A (not ((P) or (R)), [ R ] false))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q until R *)

macro Existence_After_Until (P, Q, R) =
    AG_A (true, [ Q ] AU_A_A (true, not (R), (P), true))
end_macro

(*===========================================================================*)
(*
 * Bounded existence (P occurs at most k=2 times)
 *)

(*---------------------------------------------------------------------------*)
(* Globally *)

macro Bounded_Existence_Globally (P) =
    AG_A (not (P), [ P ] AG_A (not (P), [ P ] AG_A (not (P), [ P ] false)))
end_macro

(*---------------------------------------------------------------------------*)
(* Before R *)

macro Bounded_Existence_Before (P, R) =
    AG_A (not (R), [ P ] AG_A (not (R), [ P ] AG_A (not (R),
        [ P ] AG_A (not (R), [ R ] false))))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q *)

macro Bounded_Existence_After (P, Q) =
    AG_A (not (Q), [ Q ] AG_A (not (P), [ P ] AG_A (not (P),
        [ P ] AG_A (not (P), [ P ] false))))
end_macro

(*---------------------------------------------------------------------------*)
(* Between Q and R *)

macro Bounded_Existence_Between (P, Q, R) =
    AG_A (true, [ Q ] AG_A (not (R), [ P ] AG_A (not (R),
        [ P ] AG_A (not (R), [ P ] AG_A (not (R), [ R ] false)))))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q until R *)

macro Bounded_Existence_After_Until (P, Q, R) =
    AG_A (true, [ Q ] AG_A (not (R), [ P ] AG_A (not (R),
        [ P ] AG_A (not (R), [ P ] false))))
end_macro

(*===========================================================================*)
(*
 * Universality (P is true)
 *)

(*---------------------------------------------------------------------------*)
(* Globally *)

macro Universality_Globally (P) =
    AG_A (true, [ not (P) ] false)
end_macro

(*---------------------------------------------------------------------------*)
(* Before R *)

macro Universality_Before (P, R) =
    AG_A (not (R), [ not ((P) or (R)) ] AG_A (not (R), [ R ] false))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q *)

macro Universality_After (P, Q) =
    AG_A (not (Q), [ Q ] AG_A (true, [ not (P) ] false))
end_macro

(*---------------------------------------------------------------------------*)
(* Between Q and R *)

macro Universality_Between (P, Q, R) =
    AG_A (true, [ Q ] AG_A (not (R), [ not ((P) or (R)) ] AG_A (not (R),
        [ R ] false)))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q until R *)

macro Universality_After_Until (P, Q, R) =
    AG_A (true, [ Q ] AG_A (not (R), [ not ((P) or (R)) ] false))
end_macro

(*===========================================================================*)
(*
 * Precedence (S precedes P)
 *)

(*---------------------------------------------------------------------------*)
(* Globally *)

macro Precedence_Globally (S, P) =
    AG_A (not (S), [ P ] false)
end_macro

(*---------------------------------------------------------------------------*)
(* Before R *)

macro Precedence_Before (S, P, R) =
    AG_A (not ((S) or (R)), [ P ] AG_A (not (R), [ R ] false))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q *)

macro Precedence_After (S, P, Q) =
    AG_A (not (Q), [ Q ] AG_A (not (S), [ P ] false))
end_macro

(*---------------------------------------------------------------------------*)
(* Between Q and R *)

macro Precedence_Between (S, P, Q, R) =
    AG_A (true, [ Q ] AG_A (not ((S) or (R)), [ P ] AG_A (not (R),
        [ R ] false)))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q until R *)

macro Precedence_After_Until (S, P, Q, R) =
    AG_A (true, [ Q ] AG_A (not ((S) or (R)), [ P ] false))
end_macro

(*===========================================================================*)
(*
 * Response (S responds to P)
 *)

(*---------------------------------------------------------------------------*)
(* Globally *)

macro Response_Globally (S, P) =
    AG_A (true, [ P ] AU_A_A (true, true, (S), true))
end_macro

(*---------------------------------------------------------------------------*)
(* Before R *)

macro Response_Before (S, P, R) =
    AG_A (not (R), [ P ] AG_A (not ((S) or (R)), [ R ] false))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q *)

macro Response_After (S, P, Q) =
    AG_A (not (Q), [ Q ] AG_A (true, [ P ] AU_A_A (true, true, (S), true)))
end_macro

(*---------------------------------------------------------------------------*)
(* Between Q and R *)

macro Response_Between (S, P, Q, R) =
    AG_A (true, [ Q ] AG_A (not (R), [ P ] AG_A (not ((S) or (R)),
        [ R ] false)))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q until R *)

macro Response_After_Until (S, P, Q, R) =
    AG_A (true, [ Q ] AG_A (not (R), [ P ] AU_A_A (true, not (R), (S), true)))
end_macro

(*===========================================================================*)
(*
 * Precedence Chain (S, T precede P)
 *)

(*---------------------------------------------------------------------------*)
(* Globally *)

macro Precedence_Chain_2_1_Globally (S, T, P) =
    AG_A (not (S), ([ P ] false and [ S ] AG_A (not (T), [ P ] false)))
end_macro

(*---------------------------------------------------------------------------*)
(* Before R *)

macro Precedence_Chain_2_1_Before (S, T, P, R) =
    AG_A (not ((S) or (R)), ([ P ] AG_A (not (R), [ R ] false) and
        [ S ] AG_A (not ((T) or (R)), [ P ] AG_A (not (R), [ R ] false))))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q *)

macro Precedence_Chain_2_1_After (S, T, P, Q) =
    AG_A (not (Q), [ Q ] AG_A (not (S), ([ P ] false and
        [ S ] AG_A (not (T), [ P ] false))))
end_macro

(*---------------------------------------------------------------------------*)
(* Between Q and R *)

macro Precedence_Chain_2_1_Between (S, T, P, Q, R) =
    AG_A (true, [ Q ] AG_A (not ((S) or (R)),
        ([ P ] AG_A (not (R), [ R ] false) and
         [ S ] AG_A (not ((T) or (R)), [ P ] AG_A (not (R), [ R ] false)))))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q until R *)

macro Precedence_Chain_2_1_After_Until (S, T, P, Q, R) =
    AG_A (true, [ Q ] AG_A (not ((S) or (R)), ([ P ] false and
        [ S ] AG_A (not ((T) or (R)), [ P ] false))))
end_macro

(*===========================================================================*)
(*
 * Precedence Chain (P precedes S, T)
 *)

(*---------------------------------------------------------------------------*)
(* Globally *)

macro Precedence_Chain_1_2_Globally (S, T, P) =
    AG_A (not (P), [ S ] AG_A (not (T), [ T ] false))
end_macro

(*---------------------------------------------------------------------------*)
(* Before R *)

macro Precedence_Chain_1_2_Before (S, T, P, R) =
    AG_A (not ((P) or (R)), [ S ] AG_A (not ((T) or (R)),
        [ T ] AG_A (not (R), [ R ] false)))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q *)

macro Precedence_Chain_1_2_After (S, T, P, Q) =
    AG_A (not (Q), [ Q ] AG_A (not (P), [ S ] AG_A (not (T), [ T ] false)))
end_macro

(*---------------------------------------------------------------------------*)
(* Between Q and R *)

macro Precedence_Chain_1_2_Between (S, T, P, Q, R) =
    AG_A (true, [ Q ] AG_A (not ((P) or (R)), [ S ] AG_A (not ((T) or (R)),
        [ T ] AG_A (not (R), [ R ] false))))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q until R *)

macro Precedence_Chain_1_2_After_Until (S, T, P, Q, R) =
    AG_A (true, [ Q ] AG_A (not ((P) or (R)), [ S ] AG_A (not ((T) or (R)),
        [ T ] false)))
end_macro

(*===========================================================================*)
(*
 * Response Chain (P responds to S, T)
 *)

(*---------------------------------------------------------------------------*)
(* Globally *)

macro Response_Chain_2_1_Globally (S, T, P) =
    AG_A (true, [ S ] AG_A (not (T), [ T ] AU_A_A (true, true, (P), true)))
end_macro

(*---------------------------------------------------------------------------*)
(* Before R *)

macro Response_Chain_2_1_Before (S, T, P, R) =
    AG_A (true, [ S ] AG_A (not (T), [ T ] AG_A (not (P), [ R ] false)))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q *)

macro Response_Chain_2_1_After (S, T, P, Q) =
    AG_A (not (Q), [ Q ] AG_A (true, [ S ] AG_A (not (T),
        [ T ] AU_A_A (true, true, (P), true))))
end_macro

(*---------------------------------------------------------------------------*)
(* Between Q and R *)

macro Response_Chain_2_1_Between (S, T, P, Q, R) =
    AG_A (true, [ Q ] AG_A (not ((S) or (R)), [ S ] AG_A (not ((T) or (R)),
        [ T ] AG_A (not ((P) or (R)), [ R ] false))))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q until R *)

macro Response_Chain_2_1_After_Until (S, T, P, Q, R) =
    AG_A (true, [ Q ] AG_A (not ((S) or (R)), [ S ] AG_A (not ((T) or (R)),
        [ T ] AU_A_A (true, not (R), (P), true))))
end_macro

(*===========================================================================*)
(*
 * Response Chain (S, T respond to P)
 *)

(*---------------------------------------------------------------------------*)
(* Globally *)

macro Response_Chain_1_2_Globally (S, T, P) =
    AG_A (true, [ P ] AU_A_A (true, true, (S), AU_A_A (true, true, (T), true)))
end_macro

(*---------------------------------------------------------------------------*)
(* Before R *)

macro Response_Chain_1_2_Before (S, T, P, R) =
    AG_A (not (R), [ P ] AG_A (not ((S) or (R)),
        ([ R ] false and [ S ] AG_A (not ((T) or (R)), [ R ] false))))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q *)

macro Response_Chain_1_2_After (S, T, P, Q) =
    AG_A (not (Q), [ Q ] AG_A (true, [ P ] AU_A_A (true, true, (S),
        AU_A_A (true, true, (T), true))))
end_macro

(*---------------------------------------------------------------------------*)
(* Between Q and R *)

macro Response_Chain_1_2_Between (S, T, P, Q, R) =
    AG_A (true, [ Q ] AG_A (not (R), [ P ] AG_A (not ((S) or (R)),
        ([ R ] false and [ S ] AG_A (not ((T) or (R)), [ R ] false)))))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q until R *)

macro Response_Chain_1_2_After_Until (S, T, P, Q, R) =
    AG_A (true, [ Q ] AG_A (not (R), [ P ] AU_A_A (true, not (R), (S),
        AU_A_A (true, not (R), (T), true))))
end_macro

(*===========================================================================*)
(*
 * Constrained Chain Patterns (S, T without Z respond to P)
 *)

(*---------------------------------------------------------------------------*)
(* Globally *)

macro Response_Constrained_Chain_1_2_Globally (S, T, Z, P) =
    AG_A (true, [ P ] AU_A_A (true, true, (S),
        AU_A_A (true, not (Z), (T), true)))
end_macro

(*---------------------------------------------------------------------------*)
(* Before R *)

macro Response_Constrained_Chain_1_2_Before (S, T, Z, P, R) =
    AG_A (not (R), [ P ] AG_A (not ((S) or (R)), ([ R ] false and
        [ S ] (AG_A (not ((T) or (R)), [ R ] false) and
        AG_A (not ((T) or (R)), [ Z ] AG_A (not ((T) or (R)), [ R ] false))))))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q *)

macro Response_Constrained_Chain_1_2_After (S, T, Z, P, Q) =
    AG_A (not (Q), [ Q ] AG_A (true, [ P ] AU_A_A (true, true, (S),
        AU_A_A (true, not (Z), (T), true))))
end_macro

(*---------------------------------------------------------------------------*)
(* Between Q and R *)

macro Response_Constrained_Chain_1_2_Between (S, T, Z, P, Q, R) =
    AG_A (true, [ Q ] AG_A (not (R), [ P ] AG_A (not ((S) or (R)),
        ([ R ] false and [ S ] (AG_A (not ((T) or (R)), [ R ] false) and
        AG_A (not ((T) or (R)), [ Z ] AG_A (not ((T) or (R)), [ R ] false)))))))
end_macro

(*---------------------------------------------------------------------------*)
(* After Q until R *)

macro Response_Constrained_Chain_1_2_After_Until (S, T, Z, P, Q, R) =
    AG_A (true, [ Q ] AG_A (not (R), [ P ] AU_A_A (true, not (R), (S),
        AU_A_A (true, not ((Z) or (R)), (T), true))))
end_macro

