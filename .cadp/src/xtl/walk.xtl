(****************************************************************
 * @(#)walk.xtl	- 1998/01/08 - Charles Pecheur, INRIA Rhone-Alpes
 * Patched by Radu Mateescu on 2008/08/08.
 * Patched by Radu Mateescu on 2008/09/05.
 * Patched by Radu Mateescu on 2009/07/17,
 * Patched by Radu Mateescu on 2009/07/23.
 * Patched by Hubert Garavel on 2014/12/20.
 * Patched by Hubert Garavel on 2017/11/22.
 *
 * Find and print traces in a graph.
 *
 *****************************************************************)
 
library basic.xtl, misc.xtl end_library

(****************************************************************
 * Note: Names with prefix "WALK__" are used internally and should
 * not be used for other purposes.
 *****************************************************************)

(****************************************************************
 * TRACE PRINTING FUNCTIONS
 ****************************************************************
 * This library is parameterized by a collection of 7 macros:
 *  - WALK__PRINT_EDGE
 *  - WALK__PRINT_STATE
 *  - WALK__PRINT_LOOP
 *  - WALK__PRINT_FOUND
 *  - WALK__PRINT_NOTFOUND
 *  - WALK__PRINT_DEADLOCK
 *  - WALK__PRINT_NONDTM
 * that must be imported from another library, e.g., 
 * walk_print_basic.xtl or walk_print_nice.xtl
 *
 * These macros WALK__PRINT_xxx are called to produce the printout of
 * successful traces. They can be re-defined by the user to change the
 * layout of the output, in particular using the values of WALK__DEPTH
 * and WALK__LEVEL described above. The default definitions given here
 * only print the edges of the trace, each on its own line.
 ****************************************************************)

(****************************************************************
 *  The arguments PROP in the following macros are WALK EXPRESSIONS:
 *
 *  walk_expression = boolean[WALK__STATE:state]
 *
 * That is, PROP is an open boolean expression with free occurrences
 * of a variable WALK__STATE:state.
 *
 * PROP is supposed to check some reachability property from
 * WALK__STATE. It should print (backwards) a trace demonstrating the
 * property, when such a trace makes sense and unless it is required
 * to work silently (see below).
 *
 * Three other variables are also maintained:
 *
 * - WALK__DEPTH contains the depth of WALK__STATE, i.e. the number of
 * transitions from the initial state.
 *
 * - WALK__LEVEL contains some measure of the number of nested
 * temporal operators at the current stage of evaluation. This library
 * only provides an operator to increment this level; it is up to
 * derived operators in other libraries to use it appropriately.
 *
 * - WALK__SILENTTRUE and WALK__SILENTFALSE are boolean flags; when
 * set, the PROPS perform silently, i.e.do not report traces, resp. on
 * TRUE and FALSE results. Any printing during a search should be
 * conditioned on these variables; see W_DO that provides this.
 *
 * It is intended that all PROPs be built using the macros provided in
 * this package, so that the user should hardly care about the
 * internal variables.
 *
 * NOTE: the following expressions are valid PROPs:
 *
 *   true
 *   false
 *   if C then PROP1 else PROP2
 *   let D in PROP end_let
 *
 *  This is conditioned by the fact that at most one PROP is ever
 * evaluated. In other cases one must use W_SILENTTRUE and
 * W_SILENTFALSE to ensure that only one trace is ever reported:
 *
 *   exists X:S in SILENTFALSE(PROP) end_exists
 *   forall X:S in SILENTTRUE(PROP) end_forall
 *
 * These cases require a sequential, non-strict implementation of
 * "exists" and "forall", which XTL currently provides.
 *
 * Conversely, the pre-defined "and" and "or" always evaluate both
 * arguments and therefore cannot be used to build PROPs. Safe
 * versions W_OR and W_AND are defined here. "not" cannot be used
 * either; W_NOT must be used instead.
 *
 * For every macro which defines variables using the "let" construct,
 * there is systematically an "use" construct present for each
 * variable defined. This is to prevent the situation when the walk
 * expression passed as argument to the macro does not contain free
 * occurrences of these variables, which would cause the C compiler
 * to issue warnings concerning variables set but not used in the C
 * code generated by XTL.
 ****************************************************************)

(****************************************************************
 *  WALK__TRACE(TREE:edgeset, END:state):action
 *
 *  Print path backwards, starting from END, through edges in
 *  TREE. TREE is supposed to be acyclic; no loop detection is
 *  performed.
 *
 *  The variable WALK__DEPTH is maintained, its initial value must be
 *  the depth of node END.
 *
 *  This is used internally in W_UNTIL.
 *****************************************************************)

macro WALK__TRACE(TREE,END) =
  let (any state, any boolean, any number) =
    (* print backward path from END to WALK__STATE *)
    for
    in (CURRENT:state, DONE:boolean, WALK__DEPTH:number)
    while
     not(DONE)
    apply (replace, or, -)
    from (END, false, WALK__DEPTH - 1)
    to 
      if
	(* is there a visited edge leading to CURRENT ? *) 
	exists E:edge among in(CURRENT) in E among TREE end_exists
      then 
	(* yes, print it and step back *)
	let the:action = WALK__PRINT_EDGE(E) in 
	  (source(E), false, #1)
	end_let
      else 
	(* no, we're done *)
	(CURRENT, true, #0)
      end_if
    end_for
  in
    nop
  end_let
end_macro

(****************************************************************
 * PRIMITIVE OPERATORS FOR WALK EXPRESSIONS
 ****************************************************************
 * The following operators are intended to provide all needed
 * primitive operations, and should be used to define all other
 * operations.
 *
 * Conditions on edges are expressed as expressions of type
 *
 *   edge_filter = boolean[WALK__STATE:state,WALK__EDGE:edge]
 *
 * i.e. boolean expressions with free occurrences of variables
 * WALK__EDGE and WALK__STATE. WALK__STATE ranges over source states,
 * WALK__EDGE over edges. Any walk expression occurring in FILTER
 * should be made silent.
 * 
 * The following macros are provided to build up edge filters:
 *
 * WALK__LBLIN(A:labelset):edge_filter
 * WALK__LBLIN(A:labelset, B:labelset):edge_filter
 * WALK__LBLIN(A:labelset, B:labelset, C:labelset):edge_filter
 *
 * Filters on the label of current edge. Avoids boolean operations on
 * label sets, to spare memory space and improve speed.
 *
 * WALK__SRCSAT(PROP:walk_expression):edge_filter
 * WALK__TGTSAT(PROP:walk_expression):edge_filter
 *
 * Check (silently) PROP on the source and target state of current
 * edge, respectively.
 ****************************************************************)

macro WALK__LBLIN(A) = 
  (label(WALK__EDGE) among (A))
end_macro

macro WALK__LBLIN(A,B) = 
  orelse(WALK__LBLIN(A), WALK__LBLIN(B))
end_macro

macro WALK__LBLIN(A,B,C) = 
  orelse(WALK__LBLIN(A), WALK__LBLIN(B,C))
end_macro

macro WALK__SRCSAT(PROP) =
  W_SILENT(PROP)
end_macro

macro WALK__TGTSAT(PROP) =
  let WALK__STATE:state = target(WALK__EDGE) in
    use WALK__STATE in
      W_SILENT(PROP)
    end_use
  end_let
end_macro

(****************************************************************
 *  W_NEXT_F(FILTER:edge_filter, PROP:walk_expression)
 *    :walk_expression
 *
 * Performs a single-step search from current state, through edges
 * satisfying FILTER, for a state satisfying PROP. Reports edge in
 * case of success.
 *****************************************************************)

macro W_NEXT_F(FILTER, PROP) =
  W_SILENTFALSE(
    exists WALK__EDGE:edge among out(WALK__STATE) in
      andalso(FILTER,
	W_DO(WALK__PRINT_EDGE(WALK__EDGE),
	  let 
	    WALK__STATE:state = target(WALK__EDGE),
	    WALK__DEPTH:number = WALK__DEPTH + 1
	  in 
	    use WALK__STATE, WALK__DEPTH in
              (PROP)
            end_use
	  end_let
      ) )
    end_exists
  )
end_macro

(****************************************************************
 *  W_UNTIL_F(FILTER:edge_filter, PROP:walk_expression)
 *    :walk_expression
 *
 * Performs a breadth-first search from current state, through edges
 * such that FILTER holds, for a state satisfying PROP. Reports trace
 * in case of success.
 *
 * Since the search is breadth first, a minimal trace is reported.
 *****************************************************************)

macro W_UNTIL_F(FILTER, PROP) =
  W_SILENTFALSE(
    let (any stateset, any stateset, any edgeset, 
         any number, FOUND:boolean) =
      (* loop on search depth *)
      for
      in (CURRENT:stateset, VISITED:stateset, TREE:edgeset, 
          WALK__DEPTH:number, FOUND:boolean)
      while 
	andalso(not(FOUND), (CURRENT <> empty))
      apply (replace, union, union, +, or)
      from ({WALK__STATE}, {WALK__STATE}, {}, WALK__DEPTH, false)
      to
	if
	  (* is there a state at current depth that satisfies PROP ? *)
	  exists WALK__STATE:state among CURRENT in
	    (* if found, print the trace *)
	    W_DO(
	      WALK__TRACE(TREE,WALK__STATE),
	      PROP
	    ) 
	  end_exists
	then
	  (* yes, stop search *)
	  (CURRENT, {}, {}, #0, true)
	else
	  (* no, compute all new states at next depth *)
	  let (NEW:stateset, TREESTEP:edgeset) =
	    <| (insert,insert) 
	       on 
                 WALK__STATE:state among CURRENT, 
                 WALK__EDGE:edge among out(WALK__STATE)
	       where
		 andalso(FILTER, not(target(WALK__EDGE) among VISITED))
	    |> (target(WALK__EDGE), WALK__EDGE)
	  in
	    (NEW, NEW, TREESTEP, #1, false)
	  end_let
	end_if
      end_for
    in
      FOUND 
    end_let
  )
end_macro

(****************************************************************
 *  W_MARK(X:state_var,PROP:walk_expression):walk_expression
 *
 * Bind X to current state then search for PROP.  To be used in tandem
 * with W_AT(X) to search for loops.
 *****************************************************************)

macro W_MARK(X,PROP) =
  let X:state = WALK__STATE in use X in (PROP) end_use end_let
end_macro

(****************************************************************
 *  W_LET(X:stateset_var,PROP1:walk_expression,PROP2:walk_expression)
 *    :walk_expression
 *
 * Bind X to set of states satisfying PROP1 in PROP2. PROP1 is used
 * silently. Useful to optimize search on properties that cannot be
 * traced, such as invariants.
 *****************************************************************)

macro W_LET(X,PROP1,PROP2) =
  let X:stateset = {WALK__STATE:state where W_SILENT(PROP1)} in
    use X in (PROP2) end_use
  end_let
end_macro

(****************************************************************
 * W_SILENTTRUE(PROP:walk_expression):walk_expression
 * W_SILENTFALSE(PROP:walk_expression):walk_expression
 * W_SILENT(PROP:walk_expression):walk_expression
 *
 * Search PROP silently, i.e. do not print trace, resp. in case of
 * success, failure or both.
 ****************************************************************)

macro W_SILENTTRUE(PROP) =
  let WALK__SILENTTRUE:boolean = true in
    use WALK__SILENTTRUE in (PROP) end_use
  end_let
end_macro

macro W_SILENTFALSE(PROP) =
  let WALK__SILENTFALSE:boolean = true in
    use WALK__SILENTFALSE in (PROP) end_use
  end_let
end_macro

macro W_SILENT(PROP) =
  W_SILENTTRUE(W_SILENTFALSE(PROP))
end_macro

(****************************************************************
 * W_DO(A1:action,A2:action,PROP:walk_expression):walk_expression
 * W_DO(A:action,PROP:walk_expression):walk_expression
 *
 * Search PROP and do either A1 or A2 at current state, resp. if PROP
 * holds and not SILENTTRUE or PROP does not hold and not
 * SILENTFALSE. Typically A1 and A2 will print some further diagnostic
 * info about the trace. the second forms does nothing if P does not
 * hold.
 ****************************************************************)

macro W_DO(A1, A2, PROP) =
  if (PROP)
  then 
    if WALK__SILENTTRUE
    then true
    else do(A1, true)
    end_if
  else
    if WALK__SILENTFALSE
    then false
    else do(A2, false)
    end_if
  end_if
end_macro

macro W_DO(A, PROP) =
  if (PROP)
  then 
    if WALK__SILENTTRUE
    then true
    else do(A, true)
    end_if
  else
    use WALK__SILENTFALSE in false end_use
  end_if
end_macro

(****************************************************************
 * W_TEST(B:boolean):walk_expression
 *
 * Report current state if B is true, where B normally depends on
 * WALK__STATE. This is the normal way to report a terminal
 * walk_expression.
 ****************************************************************)

macro W_TEST(B) =
  W_DO(WALK__PRINT_STATE(WALK__STATE), B) 
end_macro

(****************************************************************
 * W_LEVEL(PROP:walk_expression):walk_expression
 *
 * Increment WALK__LEVEL in PROP.
 ****************************************************************)

macro W_LEVEL(PROP) =
  let WALK__LEVEL:number = WALK__LEVEL + 1 in
    use WALK__LEVEL in (PROP) end_use
  end_let
end_macro

(****************************************************************
 * W_NOT(PROP:walk_expression):walk_expression
 *
 * W_NOT(PROP) = not(PROP)
 *****************************************************************)

macro W_NOT(PROP) =
  let
    (WALK__SILENTTRUE:boolean, WALK__SILENTFALSE:boolean) =
      (WALK__SILENTFALSE, WALK__SILENTTRUE)
  in
    use WALK__SILENTTRUE, WALK__SILENTFALSE in
      not(PROP)
    end_use
  end_let
end_macro

(****************************************************************
 * W_AND(PROP1:walk_expression, PROP2:walk_expression):walk_expression
 * W_OR(PROP1:walk_expression, PROP2:walk_expression):walk_expression
 *
 * Boolean combinators, with suitable restrictions to avoid reporting
 * irrelevant traces.
 *****************************************************************)

macro W_AND(PROP1, PROP2) =
  if W_SILENTTRUE(PROP1)
  then (PROP2)
  else false
  end_if
end_macro

macro W_OR(PROP1, PROP2) =
  if W_SILENTFALSE(PROP1)
  then true
  else (PROP2)
  end_if
end_macro

(****************************************************************
 * TOP-LEVEL INVOCATION
 ****************************************************************
 * WALK(PROP:walk_expression):boolean 
 * Search for PROP from initial state.
 *
 * Note: outermost parentheses required to avoid a mysterious bug in
 * the pre-processor: if PROP contains calls to W_DO, then the
 * expansion of WALK is appended to the previous token without the
 * needed spacing.
 *****************************************************************)

macro WALK(PROP) =
  (let 
     WALK__STATE:state = init,
     WALK__DEPTH:number = #0,
     WALK__LEVEL:number = #0,
     WALK__SILENTTRUE:boolean = false,
     WALK__SILENTFALSE:boolean = false
   in
    use WALK__STATE,
        WALK__DEPTH,
        WALK__LEVEL,
        WALK__SILENTTRUE,
        WALK__SILENTFALSE
    in
      if (PROP)
      then WALK__PRINT_FOUND
      else WALK__PRINT_NOTFOUND
      end_if
    end_use
  end_let)
end_macro

(****************************************************************
 * DERIVED TERMINAL WALK EXPRESSIONS
 *****************************************************************)

(****************************************************************
 *  W_AT(X:state):walk_expression
 *
 *  Test if current state is X.
 *  Reports state if true. To be used in tandem with W_MARK(X,PROP)
 *****************************************************************)

macro W_AT(X) =
  WALK__STATE = (X)
end_macro

(****************************************************************
 *  W_AMONG(F:state):walk_expression
 *
 *  Test if current state is in F.
 *  Reports state if true.
 *****************************************************************)

macro W_AMONG(F) =
  WALK__STATE among (F)
end_macro

(****************************************************************
 *  W_DEADLOCK():walk_expression
 *
 *  Test if current state is a deadlock.
 *  Reports state if true.
 *****************************************************************)

macro W_DEADLOCK() =
  W_DO(WALK__PRINT_DEADLOCK(WALK__STATE),
    out(WALK__STATE) = empty
  )
end_macro

(****************************************************************
 *  W_NONDTM():walk_expression
 *
 *  Test if current state is non-deterministic.
 *  Reports state if true.
 *****************************************************************)

macro W_NONDTM() =
  exists E1:edge among out(WALK__STATE) in
    exists E2:edge among out(WALK__STATE) in
      W_DO(WALK__PRINT_NONDTM(E1, E2),
	andalso(E1 <> E2, label(E1) = label(E2))
      )
    end_exists
  end_exists
end_macro

(****************************************************************
 * DERIVED NEXT-LIKE WALK OPERATIONS
 ****************************************************************)

(****************************************************************
 *  W_NEXT_O(O:offer,PROP:walk_expression):walk_expression
 *
 * Performs a single-step search from current state, through edges
 * s-l->s' such that l |= O, for a state satisfying PROP. Note that
 * the pattern O may bind variables that occur in PROP. This is a
 * consequence of the use of "orelse", itself derived from
 * if-then-else, and the fact that bindings of O in "if E -> [O] then
 * E1 else E2 end_if" are visible in E1.
 *****************************************************************)

macro W_NEXT_O(O, PROP) =
  W_NEXT_F(WALK__EDGE -> [O], PROP)
end_macro

(****************************************************************
 *  W_NEXT(A:labelset,PROP:walk_expression):walk_expression
 *
 * Performs a single-step search from current state, through edges
 * s-l->s' such that l in A, for a state satisfying PROP. In terms of
 * temporal logic this corresponds to existential NEXT.
 *
 *  s |= NEXT(A,F) iff 
 *  exists l, s' . (s -l-> s') and (l in A) and (s' |= F)
 *****************************************************************)

macro W_NEXT(A, PROP) =
  W_NEXT_F(label(WALK__EDGE) among (A), PROP)
end_macro

(****************************************************************
 *  W_NEXT(PROP:walk_expression):walk_expression
 *
 * Performs a single-step search from current state, through all edges,
 * for a state satisfying PROP.
 *****************************************************************)

macro W_NEXT(PROP) = W_NEXT_F(true, PROP) end_macro

(****************************************************************
 * DERIVED UNTIL-TYPE WALK EXPRESSIONS
 ****************************************************************)

(****************************************************************
 *  W_LOOP_F(FILTER:boolean)
 *    :walk_expression
 *
 * Performs a breadth-first search for a loop from and to current
 * state, through edges EVAR such that FILTER holds.
 *
 * Since the search is breadth first, a minimal loop is reported.
 *
 * The length of the loop is computed and passed as parameter to
 * WALK__PRINT_LOOP.
 *****************************************************************)

macro W_LOOP_F(FILTER) =
  W_MARK(WALK__LOOP,
    let WALK__LOOP_DEPTH:number = WALK__DEPTH in
      use WALK__LOOP_DEPTH in
        W_NEXT_F(FILTER,
	  W_UNTIL_F(FILTER, 
	    W_DO(WALK__PRINT_LOOP(WALK__DEPTH-WALK__LOOP_DEPTH),
	      W_AT(WALK__LOOP)
        ) ) )
      end_use
    end_let
  )
end_macro

(****************************************************************
 *  W_UNLESS_F(FILTER:boolean, PROP:walk_expression)
 *    :walk_expression
 *
 * Same as W_UNTIL_F, except that infinite traces are also searched
 * for.
 *
 *  Since the graph is finite, infinite traces necessarily end with a
 *  loop. In this case, the non looping prefix is minimal, then the
 *  loop is minimal for that prefix.
 *****************************************************************)

macro W_UNLESS_F(FILTER, PROP) =
  W_UNTIL_F(FILTER, W_OR(PROP, W_LOOP_F(FILTER)))
end_macro

(****************************************************************
 *  W_UNTIL(F:stateset, A:labelset, PROP:walk_expression)
 *    :walk_expression
 *  W_UNLESS(F:stateset, A:labelset, PROP:walk_expression)
 *    :walk_expression
 *  W_LOOP(F:stateset, A:labelset)
 *    :walk_expression
 *
 * Search through edges s-l->s' such that s in F and l in A.
 *
 * In terms of temporal logic, UNTIL and UNLESS correspond to strong
 * and weak existential UNTIL, respectively.
 *
 *  UNTIL(F,A,G) = lfp X . G or (F and <A> X)
 *  UNLESS(F,A,G) = gfp X . G or (F and <A> X)
 *
 *  s |= UNTIL(F,A,G) iff
 *  exists s1, l1, s2, l2, ... .
 *    (s -l1-> s1 -l2-> s2 ...) and exists n .
 *      (s, s1, ..., sn-1 |= F) and
 *      (l1, ..., ln-1 |= A) and
 *      (sn |= G)
 *
 *  s |= UNLESS(F,A,G) iff 
 *  UNTIL(F,A,G) or
 *  exists s1, l1, s2, l2, ... .
 *    (s -l1-> s1 -l2-> s2 ...) and
 *    (s, s1, s2, ... |= F) and
 *    (l1, l2, ... |= A)
 *
 * W_LOOP is a refined form of the ACTL EG. It is finer than modal
 * logic since it can distinguish individual states (and thus strongly
 * bisimilar processes).
 *
 *  s |= LOOP(F,A) iff 
 *  exists s1, l1, s2, l2, ..., sn .
 *    (s -l1-> s1 -l2-> s2 ... -ln-1-> sn) and exists n .
 *      (s, s1, ..., sn-1 |= F) and
 *      (l1, ..., ln-1 |= A) and
 *      (sn = s)
 *****************************************************************)

macro W_UNTIL(F, A, PROP) =
  W_UNTIL_F(
    andalso(
      WALK__STATE among (F),
      label(WALK__EDGE) among (A)
    ), 
    (PROP)
  )
end_macro

macro W_UNLESS(F, A, PROP) =
  W_UNLESS_F(
    andalso(
      WALK__STATE among (F),
      label(WALK__EDGE) among (A)
    ), 
    (PROP)
  )
end_macro

macro W_LOOP(F, A) =
  W_LOOP_F(
    andalso(
      WALK__STATE among (F),
      label(WALK__EDGE) among (A)
  ) )
end_macro

(****************************************************************
 *  W_UNTIL(A:labelset, PROP:walk_expression)
 *    :walk_expression
 *  W_UNLESS(A:labelset, PROP:walk_expression)
 *    :walk_expression
 *  W_LOOP(A:labelset)
 *    :walk_expression
 *
 * Search through edges s-l->s' such that l in A.
 ****************************************************************)

macro W_UNTIL(A,PROP) = 
  W_UNTIL_F(label(WALK__EDGE) among (A), PROP)
end_macro

macro W_UNLESS(A,PROP) =
  W_UNLESS_F(label(WALK__EDGE) among (A), PROP)
end_macro

macro W_LOOP(A) = 
  W_LOOP_F(label(WALK__EDGE) among (A)) 
end_macro

(****************************************************************
 *  W_UNTIL(PROP:walk_expression)
 *    :walk_expression
 *  W_UNLESS(PROP:walk_expression)
 *    :walk_expression
 *  W_LOOP()
 *    :walk_expression
 *
 * Search through all edges.
 ****************************************************************)

macro W_UNTIL(PROP) = 
  W_UNTIL_F(true, PROP) 
end_macro

macro W_UNLESS(PROP) = 
  W_UNLESS_F(true, PROP) 
end_macro

macro W_LOOP() = 
  W_LOOP_F(true) 
end_macro

(****************************************************************
 * DERIVED TOP-LEVEL INVOCATIONS
 ****************************************************************)

(****************************************************************
 * WALK_UNTIL(PROP:walk_expression):boolean 
 * Search for PROP from any reachable state.
 ****************************************************************)

macro WALK_UNTIL(PROP) =
  (WALK(W_UNTIL_F(true, PROP)))
end_macro
