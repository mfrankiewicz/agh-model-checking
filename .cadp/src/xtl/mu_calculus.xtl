(******************************************************************************
 *                                X T L
 *-----------------------------------------------------------------------------
 *   INRIA - Unite de Recherche Rhone-Alpes
 *   655, avenue de l'Europe
 *   38330 Montbonnot Saint Martin
 *   FRANCE
 *-----------------------------------------------------------------------------
 *   Module             :       mu_calculus.xtl
 *   Author             :       Radu MATEESCU
 *   Version            :       1.9
 *   Date               :       2014/12/22 18:28:02
 *****************************************************************************)

(*
 * Definition of a value-based extension of the modal mu-calculus in XTL.
 * References (for standard mu-calculus):
 * [1] D. Kozen, "Results on the Propositional Mu-Calculus", Theoretical
 *     Computer Science, v. 27, p. 333-354, 1983
 * [2] E. A. Emerson and C-L. Lei, "Efficient Model-Checking in Fragments
 *     of the Propositional Mu-Calculus", Proceedings of the 1st LICS,
 *     p. 267-278, 1986
 * References (for value-based modal logic):
 * [3] M. Hennessy and X. Liu, "A Modal Logic for Message Passing Processes",
 *     Technical Report no. 3/93, School of Cognitive and Computing Sciences,
 *     University of Sussex, January 1993
 *
 * The boolean operators are built-in in the XTL language. This file defines
 * the modal operators (extended to allow pattern-matching over actions) and
 * the fixed point operators.
 * The semantics of formulas is defined over a Labelled Transition System (LTS)
 * M = (Q, A, T, q0), where:
 *  - Q is the set of states
 *  - A is the set of actions
 *  - T in Q * A * Q is the transition relation
 *  - q0 in Q is the initial state.
 * The actions l in A may either be atomic (i.e., gate names G), or they may
 * contain values exchanged during the rendez-vous (i.e., G v1 ... vn). In the
 * former case, the user can write standard mu-calculus formulas; in the latter
 * case, value-based formulas (with pattern-matching over actions) can be used.
 * The satisfaction relation for state and action formulas is noted `|='. The
 * semantics of a state formula `f' (resp. action formula `a'), noted `[[.]]',
 * is the set of states (resp. actions) satisfying it:
 * [[a]] = { l in A | l |= a }; [[f]] = { p in Q | p |= f }.
 *)

(*===========================================================================*)
(* Libraries used *)

library basic.xtl end_library

(*===========================================================================*)
(* Hennessy-Milner modalities allowing pattern-matching over actions *)

(*
 * Diamond modality
 * <a> f
 * [[ <a> f ]] = { p | exists l, q, (p, l, q) in T and l |= a and q |= f }
 *)

macro Dia_fwd (A, F) =
    { S : state where
	exists T : edge among out (S) in
	    if T -> [ A ] then target (T) among (F) else false end_if
	end_exists
    }
end_macro

(*
 * <true> f
 * [[ <true> f ]] = { p | exists l, q, (p, l, q) in T and q |= f }
 *)

macro Dia_fwd (F) =
    let R : stateset = (F) in
	{ S : state where not ((succ (S) inter R) = {}) }
    end_let
end_macro

(*---------------------------------------------------------------------------*)
(*
 * Box modality
 * [a] f
 * [[ [a] f ]] = { p | forall l, q, ((p, l, q) in T and l |= a) => q |= f }
 *)

macro Box_fwd (A, F) =
    { S : state where
	forall T : edge among out (S) in
	    if T -> [ A ] then target (T) among (F) else true end_if
	end_forall
    }
end_macro

(*
 * [true] f
 * [[ [true] f ]] = { p | forall l, q, (p, l, q) in T => q |= f }
 *)

macro Box_fwd (F) =
    let R : stateset = (F) in
	{ S : state where R includes succ (S) }
    end_let
end_macro

(*---------------------------------------------------------------------------*)
(*
 * More efficient versions, to be used when no variables are propagated
 * from the action pattern `a' to the state formula `f'. In particular,
 * these versions are useful in standard mu-calculus formulas.
 *)

(* Diamond modality *)

macro Dia_fwd_closed (A, F) =
    let R : stateset = (F) in
	{ S : state where
	    exists T : edge among out (S) in
		if T -> [ A ] then target (T) among R else false end_if
	    end_exists
	}
    end_let
end_macro

(* Box modality *)

macro Box_fwd_closed (A, F) =
    let R : stateset = (F) in
	{ S : state where
	    forall T : edge among out (S) in
		if T -> [ A ] then target (T) among R else true end_if
	    end_forall
	}
    end_let
end_macro

(*===========================================================================*)
(* Simple fixed point operators *)

(*
 * Least fixed point
 * lfp X . f (X)
 * [[ lfp X . f (X) ]] = least solution of X = f (X)
 *)

macro lfp (X, F) =
    let (R : stateset, any boolean) =
	for
	    in    (X : stateset, STABLE : boolean)
	    while not (STABLE)
	    apply (or, or)
	    from  (false, false)
	    to    let Y : stateset = (F) in
		      (Y, X = Y)
		  end_let
	end_for
    in
	R
    end_let
end_macro

(*---------------------------------------------------------------------------*)
(*
 * Greatest fixed point
 * gfp X . f (X)
 * [[ gfp X . f (X) ]] = greatest solution of X = f (X)
 *)

macro gfp (X, F) =
    let (R : stateset, any boolean) =
	for
	    in    (X : stateset, STABLE : boolean)
	    while not (STABLE)
	    apply (and, or)
	    from  (true, false)
	    to    let Y : stateset = (F) in
		      (Y, X = Y)
		  end_let
	end_for
    in
	R
    end_let
end_macro

(*===========================================================================*)
(*
 * n-ary fixed point operators. These operators allow a more efficient
 * evaluation of the formulas written in standard mu-calculus (i.e., without
 * pattern-matching over actions) containing "n" nested fixed points with
 * the same sign. The user can define n-ary fixed point operators (for a given
 * arity "n") following the iterative scheme used below for binary and ternary
 * fixed point operators.
 * Example: the possibility to perform an action sequence satisfying the
 *     regular expression ((A*.B)*.C) can be expressed by the binary formula
 *	   lfp_2 (
 *             X1, <> (C, true) or X2,
 *             X2, <> (B, X1) or <> (A, X2)
 *         )
 *     which is equivalent to (but more efficient than) the nested formula
 *	   lfp (X1, <> (C, true) or lfp (X2, <> (B, X1) or <> (A, X2)))
 *)

(*
 * Binary least fixed point
 * lfp X1, X2 . (f1 (X1, X2), f2 (X1, X2))
 * [[ lfp X1, X2 . (f1 (X1, X2), f2 (X1, X2)) ]] =
 *     [[ lfp X1 . f1 (X1, lfp X2 . f2 (X1, X2)) ]]
 *)

macro lfp_2 (X1, F1, X2, F2) =
    let (R1 : stateset, any stateset, any boolean) =
	for
	    in    (X1, X2 : stateset, STABLE : boolean)
	    while not (STABLE)
	    apply (or, or, or)
	    from  (false, false, false)
	    to    let (Y1, Y2 : stateset) = (F1, F2) in
		      (Y1, Y2, (X1 = Y1) and (X2 = Y2))
		  end_let
	end_for
    in
	R1
    end_let
end_macro

(* Binary greatest fixed point *)

(*
 * Binary greatest fixed point
 * gfp X1, X2 . (f1 (X1, X2), f2 (X1, X2))
 * [[ gfp X1, X2 . (f1 (X1, X2), f2 (X1, X2)) ]] =
 *     [[ gfp X1 . f1 (X1, gfp X2 . f2 (X1, X2)) ]]
 *)

macro gfp_2 (X1, F1, X2, F2) =
    let (R1 : stateset, any stateset, any boolean) =
	for
	    in    (X1, X2 : stateset, STABLE : boolean)
	    while not (STABLE)
	    apply (and, and, or)
	    from  (true, true, false)
	    to    let (Y1, Y2 : stateset) = (F1, F2) in
		      (Y1, Y2, (X1 = Y1) and (X2 = Y2))
		  end_let
	end_for
    in
	R1
    end_let
end_macro

(*---------------------------------------------------------------------------*)
(* Ternary least fixed point *)

macro lfp_3 (X1, F1, X2, F2, X3, F3) =
    let (R1 : stateset, any stateset, any stateset, any boolean) =
	for
	    in    (X1, X2, X3 : stateset, STABLE : boolean)
	    while not (STABLE)
	    apply (or, or, or, or)
	    from  (false, false, false, false)
	    to    let (Y1, Y2, Y3 : stateset) = (F1, F2, F3) in
		      (Y1, Y2, Y3, (X1 = Y1) and (X2 = Y2) and (X3 = Y3))
		  end_let
	end_for
    in
	R1
    end_let
end_macro

(* Ternary greatest fixed point *)

macro gfp_3 (X1, F1, X2, F2, X3, F3) =
    let (R1 : stateset, any stateset, any stateset, any boolean) =
	for
	    in    (X1, X2, X3 : stateset, STABLE : boolean)
	    while not (STABLE)
	    apply (and, and, and, or)
	    from  (true, true, true, false)
	    to    let (Y1, Y2, Y3 : stateset) = (F1, F2, F3) in
		      (Y1, Y2, Y3, (X1 = Y1) and (X2 = Y2) and (X3 = Y3))
		  end_let
	end_for
    in
	R1
    end_let
end_macro

